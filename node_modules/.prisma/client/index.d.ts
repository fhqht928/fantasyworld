
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model NPC
 * 
 */
export type NPC = $Result.DefaultSelection<Prisma.$NPCPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model WildArea
 * 
 */
export type WildArea = $Result.DefaultSelection<Prisma.$WildAreaPayload>
/**
 * Model Dungeon
 * 
 */
export type Dungeon = $Result.DefaultSelection<Prisma.$DungeonPayload>
/**
 * Model Quest
 * 
 */
export type Quest = $Result.DefaultSelection<Prisma.$QuestPayload>
/**
 * Model PlayerProfession
 * 
 */
export type PlayerProfession = $Result.DefaultSelection<Prisma.$PlayerProfessionPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemInstance
 * 
 */
export type ItemInstance = $Result.DefaultSelection<Prisma.$ItemInstancePayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeMaterial
 * 
 */
export type RecipeMaterial = $Result.DefaultSelection<Prisma.$RecipeMaterialPayload>
/**
 * Model Corpse
 * 
 */
export type Corpse = $Result.DefaultSelection<Prisma.$CorpsePayload>
/**
 * Model AnimalPopulation
 * 
 */
export type AnimalPopulation = $Result.DefaultSelection<Prisma.$AnimalPopulationPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model UserLanguage
 * 
 */
export type UserLanguage = $Result.DefaultSelection<Prisma.$UserLanguagePayload>
/**
 * Model Religion
 * 
 */
export type Religion = $Result.DefaultSelection<Prisma.$ReligionPayload>
/**
 * Model Artifact
 * 
 */
export type Artifact = $Result.DefaultSelection<Prisma.$ArtifactPayload>
/**
 * Model GlobalEvent
 * 
 */
export type GlobalEvent = $Result.DefaultSelection<Prisma.$GlobalEventPayload>
/**
 * Model Weather
 * 
 */
export type Weather = $Result.DefaultSelection<Prisma.$WeatherPayload>
/**
 * Model NPCStory
 * 
 */
export type NPCStory = $Result.DefaultSelection<Prisma.$NPCStoryPayload>
/**
 * Model PlayerTitle
 * 
 */
export type PlayerTitle = $Result.DefaultSelection<Prisma.$PlayerTitlePayload>
/**
 * Model Economy
 * 
 */
export type Economy = $Result.DefaultSelection<Prisma.$EconomyPayload>
/**
 * Model WorldTime
 * 
 */
export type WorldTime = $Result.DefaultSelection<Prisma.$WorldTimePayload>
/**
 * Model WorldSnapshot
 * 
 */
export type WorldSnapshot = $Result.DefaultSelection<Prisma.$WorldSnapshotPayload>
/**
 * Model TaxPolicy
 * 
 */
export type TaxPolicy = $Result.DefaultSelection<Prisma.$TaxPolicyPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nPC`: Exposes CRUD operations for the **NPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPCS
    * const nPCS = await prisma.nPC.findMany()
    * ```
    */
  get nPC(): Prisma.NPCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wildArea`: Exposes CRUD operations for the **WildArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WildAreas
    * const wildAreas = await prisma.wildArea.findMany()
    * ```
    */
  get wildArea(): Prisma.WildAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dungeon`: Exposes CRUD operations for the **Dungeon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dungeons
    * const dungeons = await prisma.dungeon.findMany()
    * ```
    */
  get dungeon(): Prisma.DungeonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quest`: Exposes CRUD operations for the **Quest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quest.findMany()
    * ```
    */
  get quest(): Prisma.QuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerProfession`: Exposes CRUD operations for the **PlayerProfession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerProfessions
    * const playerProfessions = await prisma.playerProfession.findMany()
    * ```
    */
  get playerProfession(): Prisma.PlayerProfessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemInstance`: Exposes CRUD operations for the **ItemInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemInstances
    * const itemInstances = await prisma.itemInstance.findMany()
    * ```
    */
  get itemInstance(): Prisma.ItemInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeMaterial`: Exposes CRUD operations for the **RecipeMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeMaterials
    * const recipeMaterials = await prisma.recipeMaterial.findMany()
    * ```
    */
  get recipeMaterial(): Prisma.RecipeMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.corpse`: Exposes CRUD operations for the **Corpse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Corpses
    * const corpses = await prisma.corpse.findMany()
    * ```
    */
  get corpse(): Prisma.CorpseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.animalPopulation`: Exposes CRUD operations for the **AnimalPopulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnimalPopulations
    * const animalPopulations = await prisma.animalPopulation.findMany()
    * ```
    */
  get animalPopulation(): Prisma.AnimalPopulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLanguage`: Exposes CRUD operations for the **UserLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLanguages
    * const userLanguages = await prisma.userLanguage.findMany()
    * ```
    */
  get userLanguage(): Prisma.UserLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.religion`: Exposes CRUD operations for the **Religion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Religions
    * const religions = await prisma.religion.findMany()
    * ```
    */
  get religion(): Prisma.ReligionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artifact`: Exposes CRUD operations for the **Artifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artifacts
    * const artifacts = await prisma.artifact.findMany()
    * ```
    */
  get artifact(): Prisma.ArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.globalEvent`: Exposes CRUD operations for the **GlobalEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalEvents
    * const globalEvents = await prisma.globalEvent.findMany()
    * ```
    */
  get globalEvent(): Prisma.GlobalEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **Weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.WeatherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nPCStory`: Exposes CRUD operations for the **NPCStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPCStories
    * const nPCStories = await prisma.nPCStory.findMany()
    * ```
    */
  get nPCStory(): Prisma.NPCStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerTitle`: Exposes CRUD operations for the **PlayerTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerTitles
    * const playerTitles = await prisma.playerTitle.findMany()
    * ```
    */
  get playerTitle(): Prisma.PlayerTitleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.economy`: Exposes CRUD operations for the **Economy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Economies
    * const economies = await prisma.economy.findMany()
    * ```
    */
  get economy(): Prisma.EconomyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.worldTime`: Exposes CRUD operations for the **WorldTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorldTimes
    * const worldTimes = await prisma.worldTime.findMany()
    * ```
    */
  get worldTime(): Prisma.WorldTimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.worldSnapshot`: Exposes CRUD operations for the **WorldSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorldSnapshots
    * const worldSnapshots = await prisma.worldSnapshot.findMany()
    * ```
    */
  get worldSnapshot(): Prisma.WorldSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxPolicy`: Exposes CRUD operations for the **TaxPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxPolicies
    * const taxPolicies = await prisma.taxPolicy.findMany()
    * ```
    */
  get taxPolicy(): Prisma.TaxPolicyDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    NPC: 'NPC',
    City: 'City',
    Country: 'Country',
    WildArea: 'WildArea',
    Dungeon: 'Dungeon',
    Quest: 'Quest',
    PlayerProfession: 'PlayerProfession',
    Item: 'Item',
    ItemInstance: 'ItemInstance',
    Recipe: 'Recipe',
    RecipeMaterial: 'RecipeMaterial',
    Corpse: 'Corpse',
    AnimalPopulation: 'AnimalPopulation',
    Language: 'Language',
    UserLanguage: 'UserLanguage',
    Religion: 'Religion',
    Artifact: 'Artifact',
    GlobalEvent: 'GlobalEvent',
    Weather: 'Weather',
    NPCStory: 'NPCStory',
    PlayerTitle: 'PlayerTitle',
    Economy: 'Economy',
    WorldTime: 'WorldTime',
    WorldSnapshot: 'WorldSnapshot',
    TaxPolicy: 'TaxPolicy'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "nPC" | "city" | "country" | "wildArea" | "dungeon" | "quest" | "playerProfession" | "item" | "itemInstance" | "recipe" | "recipeMaterial" | "corpse" | "animalPopulation" | "language" | "userLanguage" | "religion" | "artifact" | "globalEvent" | "weather" | "nPCStory" | "playerTitle" | "economy" | "worldTime" | "worldSnapshot" | "taxPolicy"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      NPC: {
        payload: Prisma.$NPCPayload<ExtArgs>
        fields: Prisma.NPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findFirst: {
            args: Prisma.NPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findMany: {
            args: Prisma.NPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          create: {
            args: Prisma.NPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          createMany: {
            args: Prisma.NPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          delete: {
            args: Prisma.NPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          update: {
            args: Prisma.NPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          deleteMany: {
            args: Prisma.NPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NPCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          upsert: {
            args: Prisma.NPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          aggregate: {
            args: Prisma.NPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPC>
          }
          groupBy: {
            args: Prisma.NPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPCCountArgs<ExtArgs>
            result: $Utils.Optional<NPCCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      WildArea: {
        payload: Prisma.$WildAreaPayload<ExtArgs>
        fields: Prisma.WildAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WildAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WildAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>
          }
          findFirst: {
            args: Prisma.WildAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WildAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>
          }
          findMany: {
            args: Prisma.WildAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>[]
          }
          create: {
            args: Prisma.WildAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>
          }
          createMany: {
            args: Prisma.WildAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WildAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>[]
          }
          delete: {
            args: Prisma.WildAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>
          }
          update: {
            args: Prisma.WildAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>
          }
          deleteMany: {
            args: Prisma.WildAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WildAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WildAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>[]
          }
          upsert: {
            args: Prisma.WildAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WildAreaPayload>
          }
          aggregate: {
            args: Prisma.WildAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWildArea>
          }
          groupBy: {
            args: Prisma.WildAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<WildAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.WildAreaCountArgs<ExtArgs>
            result: $Utils.Optional<WildAreaCountAggregateOutputType> | number
          }
        }
      }
      Dungeon: {
        payload: Prisma.$DungeonPayload<ExtArgs>
        fields: Prisma.DungeonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DungeonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DungeonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>
          }
          findFirst: {
            args: Prisma.DungeonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DungeonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>
          }
          findMany: {
            args: Prisma.DungeonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>[]
          }
          create: {
            args: Prisma.DungeonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>
          }
          createMany: {
            args: Prisma.DungeonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DungeonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>[]
          }
          delete: {
            args: Prisma.DungeonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>
          }
          update: {
            args: Prisma.DungeonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>
          }
          deleteMany: {
            args: Prisma.DungeonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DungeonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DungeonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>[]
          }
          upsert: {
            args: Prisma.DungeonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DungeonPayload>
          }
          aggregate: {
            args: Prisma.DungeonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDungeon>
          }
          groupBy: {
            args: Prisma.DungeonGroupByArgs<ExtArgs>
            result: $Utils.Optional<DungeonGroupByOutputType>[]
          }
          count: {
            args: Prisma.DungeonCountArgs<ExtArgs>
            result: $Utils.Optional<DungeonCountAggregateOutputType> | number
          }
        }
      }
      Quest: {
        payload: Prisma.$QuestPayload<ExtArgs>
        fields: Prisma.QuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findFirst: {
            args: Prisma.QuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findMany: {
            args: Prisma.QuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          create: {
            args: Prisma.QuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          createMany: {
            args: Prisma.QuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          delete: {
            args: Prisma.QuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          update: {
            args: Prisma.QuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          deleteMany: {
            args: Prisma.QuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          upsert: {
            args: Prisma.QuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          aggregate: {
            args: Prisma.QuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuest>
          }
          groupBy: {
            args: Prisma.QuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestCountArgs<ExtArgs>
            result: $Utils.Optional<QuestCountAggregateOutputType> | number
          }
        }
      }
      PlayerProfession: {
        payload: Prisma.$PlayerProfessionPayload<ExtArgs>
        fields: Prisma.PlayerProfessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerProfessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerProfessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>
          }
          findFirst: {
            args: Prisma.PlayerProfessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerProfessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>
          }
          findMany: {
            args: Prisma.PlayerProfessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>[]
          }
          create: {
            args: Prisma.PlayerProfessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>
          }
          createMany: {
            args: Prisma.PlayerProfessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerProfessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>[]
          }
          delete: {
            args: Prisma.PlayerProfessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>
          }
          update: {
            args: Prisma.PlayerProfessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>
          }
          deleteMany: {
            args: Prisma.PlayerProfessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerProfessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerProfessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>[]
          }
          upsert: {
            args: Prisma.PlayerProfessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfessionPayload>
          }
          aggregate: {
            args: Prisma.PlayerProfessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerProfession>
          }
          groupBy: {
            args: Prisma.PlayerProfessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerProfessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerProfessionCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerProfessionCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemInstance: {
        payload: Prisma.$ItemInstancePayload<ExtArgs>
        fields: Prisma.ItemInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>
          }
          findFirst: {
            args: Prisma.ItemInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>
          }
          findMany: {
            args: Prisma.ItemInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>[]
          }
          create: {
            args: Prisma.ItemInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>
          }
          createMany: {
            args: Prisma.ItemInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>[]
          }
          delete: {
            args: Prisma.ItemInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>
          }
          update: {
            args: Prisma.ItemInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>
          }
          deleteMany: {
            args: Prisma.ItemInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemInstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>[]
          }
          upsert: {
            args: Prisma.ItemInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemInstancePayload>
          }
          aggregate: {
            args: Prisma.ItemInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemInstance>
          }
          groupBy: {
            args: Prisma.ItemInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<ItemInstanceCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeMaterial: {
        payload: Prisma.$RecipeMaterialPayload<ExtArgs>
        fields: Prisma.RecipeMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>
          }
          findFirst: {
            args: Prisma.RecipeMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>
          }
          findMany: {
            args: Prisma.RecipeMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>[]
          }
          create: {
            args: Prisma.RecipeMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>
          }
          createMany: {
            args: Prisma.RecipeMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>[]
          }
          delete: {
            args: Prisma.RecipeMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>
          }
          update: {
            args: Prisma.RecipeMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>
          }
          deleteMany: {
            args: Prisma.RecipeMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>[]
          }
          upsert: {
            args: Prisma.RecipeMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMaterialPayload>
          }
          aggregate: {
            args: Prisma.RecipeMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeMaterial>
          }
          groupBy: {
            args: Prisma.RecipeMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeMaterialCountAggregateOutputType> | number
          }
        }
      }
      Corpse: {
        payload: Prisma.$CorpsePayload<ExtArgs>
        fields: Prisma.CorpseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorpseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorpseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>
          }
          findFirst: {
            args: Prisma.CorpseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorpseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>
          }
          findMany: {
            args: Prisma.CorpseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>[]
          }
          create: {
            args: Prisma.CorpseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>
          }
          createMany: {
            args: Prisma.CorpseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorpseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>[]
          }
          delete: {
            args: Prisma.CorpseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>
          }
          update: {
            args: Prisma.CorpseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>
          }
          deleteMany: {
            args: Prisma.CorpseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorpseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CorpseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>[]
          }
          upsert: {
            args: Prisma.CorpseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorpsePayload>
          }
          aggregate: {
            args: Prisma.CorpseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorpse>
          }
          groupBy: {
            args: Prisma.CorpseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorpseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorpseCountArgs<ExtArgs>
            result: $Utils.Optional<CorpseCountAggregateOutputType> | number
          }
        }
      }
      AnimalPopulation: {
        payload: Prisma.$AnimalPopulationPayload<ExtArgs>
        fields: Prisma.AnimalPopulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimalPopulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimalPopulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>
          }
          findFirst: {
            args: Prisma.AnimalPopulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimalPopulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>
          }
          findMany: {
            args: Prisma.AnimalPopulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>[]
          }
          create: {
            args: Prisma.AnimalPopulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>
          }
          createMany: {
            args: Prisma.AnimalPopulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimalPopulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>[]
          }
          delete: {
            args: Prisma.AnimalPopulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>
          }
          update: {
            args: Prisma.AnimalPopulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>
          }
          deleteMany: {
            args: Prisma.AnimalPopulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimalPopulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnimalPopulationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>[]
          }
          upsert: {
            args: Prisma.AnimalPopulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPopulationPayload>
          }
          aggregate: {
            args: Prisma.AnimalPopulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnimalPopulation>
          }
          groupBy: {
            args: Prisma.AnimalPopulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimalPopulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimalPopulationCountArgs<ExtArgs>
            result: $Utils.Optional<AnimalPopulationCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      UserLanguage: {
        payload: Prisma.$UserLanguagePayload<ExtArgs>
        fields: Prisma.UserLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>
          }
          findFirst: {
            args: Prisma.UserLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>
          }
          findMany: {
            args: Prisma.UserLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>[]
          }
          create: {
            args: Prisma.UserLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>
          }
          createMany: {
            args: Prisma.UserLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>[]
          }
          delete: {
            args: Prisma.UserLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>
          }
          update: {
            args: Prisma.UserLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>
          }
          deleteMany: {
            args: Prisma.UserLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>[]
          }
          upsert: {
            args: Prisma.UserLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLanguagePayload>
          }
          aggregate: {
            args: Prisma.UserLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLanguage>
          }
          groupBy: {
            args: Prisma.UserLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<UserLanguageCountAggregateOutputType> | number
          }
        }
      }
      Religion: {
        payload: Prisma.$ReligionPayload<ExtArgs>
        fields: Prisma.ReligionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReligionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReligionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          findFirst: {
            args: Prisma.ReligionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReligionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          findMany: {
            args: Prisma.ReligionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>[]
          }
          create: {
            args: Prisma.ReligionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          createMany: {
            args: Prisma.ReligionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReligionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>[]
          }
          delete: {
            args: Prisma.ReligionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          update: {
            args: Prisma.ReligionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          deleteMany: {
            args: Prisma.ReligionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReligionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReligionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>[]
          }
          upsert: {
            args: Prisma.ReligionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          aggregate: {
            args: Prisma.ReligionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReligion>
          }
          groupBy: {
            args: Prisma.ReligionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReligionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReligionCountArgs<ExtArgs>
            result: $Utils.Optional<ReligionCountAggregateOutputType> | number
          }
        }
      }
      Artifact: {
        payload: Prisma.$ArtifactPayload<ExtArgs>
        fields: Prisma.ArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findFirst: {
            args: Prisma.ArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findMany: {
            args: Prisma.ArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          create: {
            args: Prisma.ArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          createMany: {
            args: Prisma.ArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          delete: {
            args: Prisma.ArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          update: {
            args: Prisma.ArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          aggregate: {
            args: Prisma.ArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifact>
          }
          groupBy: {
            args: Prisma.ArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactCountAggregateOutputType> | number
          }
        }
      }
      GlobalEvent: {
        payload: Prisma.$GlobalEventPayload<ExtArgs>
        fields: Prisma.GlobalEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>
          }
          findFirst: {
            args: Prisma.GlobalEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>
          }
          findMany: {
            args: Prisma.GlobalEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>[]
          }
          create: {
            args: Prisma.GlobalEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>
          }
          createMany: {
            args: Prisma.GlobalEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>[]
          }
          delete: {
            args: Prisma.GlobalEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>
          }
          update: {
            args: Prisma.GlobalEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>
          }
          deleteMany: {
            args: Prisma.GlobalEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlobalEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>[]
          }
          upsert: {
            args: Prisma.GlobalEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalEventPayload>
          }
          aggregate: {
            args: Prisma.GlobalEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalEvent>
          }
          groupBy: {
            args: Prisma.GlobalEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalEventCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalEventCountAggregateOutputType> | number
          }
        }
      }
      Weather: {
        payload: Prisma.$WeatherPayload<ExtArgs>
        fields: Prisma.WeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findFirst: {
            args: Prisma.WeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findMany: {
            args: Prisma.WeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          create: {
            args: Prisma.WeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          createMany: {
            args: Prisma.WeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          delete: {
            args: Prisma.WeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          update: {
            args: Prisma.WeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          deleteMany: {
            args: Prisma.WeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          upsert: {
            args: Prisma.WeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          aggregate: {
            args: Prisma.WeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeather>
          }
          groupBy: {
            args: Prisma.WeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherCountAggregateOutputType> | number
          }
        }
      }
      NPCStory: {
        payload: Prisma.$NPCStoryPayload<ExtArgs>
        fields: Prisma.NPCStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPCStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPCStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>
          }
          findFirst: {
            args: Prisma.NPCStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPCStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>
          }
          findMany: {
            args: Prisma.NPCStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>[]
          }
          create: {
            args: Prisma.NPCStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>
          }
          createMany: {
            args: Prisma.NPCStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPCStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>[]
          }
          delete: {
            args: Prisma.NPCStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>
          }
          update: {
            args: Prisma.NPCStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>
          }
          deleteMany: {
            args: Prisma.NPCStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPCStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NPCStoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>[]
          }
          upsert: {
            args: Prisma.NPCStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCStoryPayload>
          }
          aggregate: {
            args: Prisma.NPCStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPCStory>
          }
          groupBy: {
            args: Prisma.NPCStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPCStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPCStoryCountArgs<ExtArgs>
            result: $Utils.Optional<NPCStoryCountAggregateOutputType> | number
          }
        }
      }
      PlayerTitle: {
        payload: Prisma.$PlayerTitlePayload<ExtArgs>
        fields: Prisma.PlayerTitleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerTitleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerTitleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>
          }
          findFirst: {
            args: Prisma.PlayerTitleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerTitleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>
          }
          findMany: {
            args: Prisma.PlayerTitleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>[]
          }
          create: {
            args: Prisma.PlayerTitleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>
          }
          createMany: {
            args: Prisma.PlayerTitleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerTitleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>[]
          }
          delete: {
            args: Prisma.PlayerTitleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>
          }
          update: {
            args: Prisma.PlayerTitleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>
          }
          deleteMany: {
            args: Prisma.PlayerTitleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerTitleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerTitleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>[]
          }
          upsert: {
            args: Prisma.PlayerTitleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerTitlePayload>
          }
          aggregate: {
            args: Prisma.PlayerTitleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerTitle>
          }
          groupBy: {
            args: Prisma.PlayerTitleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerTitleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerTitleCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerTitleCountAggregateOutputType> | number
          }
        }
      }
      Economy: {
        payload: Prisma.$EconomyPayload<ExtArgs>
        fields: Prisma.EconomyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EconomyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EconomyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>
          }
          findFirst: {
            args: Prisma.EconomyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EconomyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>
          }
          findMany: {
            args: Prisma.EconomyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>[]
          }
          create: {
            args: Prisma.EconomyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>
          }
          createMany: {
            args: Prisma.EconomyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EconomyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>[]
          }
          delete: {
            args: Prisma.EconomyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>
          }
          update: {
            args: Prisma.EconomyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>
          }
          deleteMany: {
            args: Prisma.EconomyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EconomyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EconomyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>[]
          }
          upsert: {
            args: Prisma.EconomyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EconomyPayload>
          }
          aggregate: {
            args: Prisma.EconomyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEconomy>
          }
          groupBy: {
            args: Prisma.EconomyGroupByArgs<ExtArgs>
            result: $Utils.Optional<EconomyGroupByOutputType>[]
          }
          count: {
            args: Prisma.EconomyCountArgs<ExtArgs>
            result: $Utils.Optional<EconomyCountAggregateOutputType> | number
          }
        }
      }
      WorldTime: {
        payload: Prisma.$WorldTimePayload<ExtArgs>
        fields: Prisma.WorldTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorldTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorldTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>
          }
          findFirst: {
            args: Prisma.WorldTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorldTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>
          }
          findMany: {
            args: Prisma.WorldTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>[]
          }
          create: {
            args: Prisma.WorldTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>
          }
          createMany: {
            args: Prisma.WorldTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorldTimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>[]
          }
          delete: {
            args: Prisma.WorldTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>
          }
          update: {
            args: Prisma.WorldTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>
          }
          deleteMany: {
            args: Prisma.WorldTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorldTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorldTimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>[]
          }
          upsert: {
            args: Prisma.WorldTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldTimePayload>
          }
          aggregate: {
            args: Prisma.WorldTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorldTime>
          }
          groupBy: {
            args: Prisma.WorldTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorldTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorldTimeCountArgs<ExtArgs>
            result: $Utils.Optional<WorldTimeCountAggregateOutputType> | number
          }
        }
      }
      WorldSnapshot: {
        payload: Prisma.$WorldSnapshotPayload<ExtArgs>
        fields: Prisma.WorldSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorldSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorldSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>
          }
          findFirst: {
            args: Prisma.WorldSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorldSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>
          }
          findMany: {
            args: Prisma.WorldSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>[]
          }
          create: {
            args: Prisma.WorldSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>
          }
          createMany: {
            args: Prisma.WorldSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorldSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>[]
          }
          delete: {
            args: Prisma.WorldSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>
          }
          update: {
            args: Prisma.WorldSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.WorldSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorldSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorldSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.WorldSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldSnapshotPayload>
          }
          aggregate: {
            args: Prisma.WorldSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorldSnapshot>
          }
          groupBy: {
            args: Prisma.WorldSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorldSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorldSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<WorldSnapshotCountAggregateOutputType> | number
          }
        }
      }
      TaxPolicy: {
        payload: Prisma.$TaxPolicyPayload<ExtArgs>
        fields: Prisma.TaxPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>
          }
          findFirst: {
            args: Prisma.TaxPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>
          }
          findMany: {
            args: Prisma.TaxPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>[]
          }
          create: {
            args: Prisma.TaxPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>
          }
          createMany: {
            args: Prisma.TaxPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>[]
          }
          delete: {
            args: Prisma.TaxPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>
          }
          update: {
            args: Prisma.TaxPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>
          }
          deleteMany: {
            args: Prisma.TaxPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>[]
          }
          upsert: {
            args: Prisma.TaxPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPolicyPayload>
          }
          aggregate: {
            args: Prisma.TaxPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxPolicy>
          }
          groupBy: {
            args: Prisma.TaxPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<TaxPolicyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    nPC?: NPCOmit
    city?: CityOmit
    country?: CountryOmit
    wildArea?: WildAreaOmit
    dungeon?: DungeonOmit
    quest?: QuestOmit
    playerProfession?: PlayerProfessionOmit
    item?: ItemOmit
    itemInstance?: ItemInstanceOmit
    recipe?: RecipeOmit
    recipeMaterial?: RecipeMaterialOmit
    corpse?: CorpseOmit
    animalPopulation?: AnimalPopulationOmit
    language?: LanguageOmit
    userLanguage?: UserLanguageOmit
    religion?: ReligionOmit
    artifact?: ArtifactOmit
    globalEvent?: GlobalEventOmit
    weather?: WeatherOmit
    nPCStory?: NPCStoryOmit
    playerTitle?: PlayerTitleOmit
    economy?: EconomyOmit
    worldTime?: WorldTimeOmit
    worldSnapshot?: WorldSnapshotOmit
    taxPolicy?: TaxPolicyOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    profession: number
    inventory: number
    titles: number
    languages: number
    quests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profession?: boolean | UserCountOutputTypeCountProfessionArgs
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    titles?: boolean | UserCountOutputTypeCountTitlesArgs
    languages?: boolean | UserCountOutputTypeCountLanguagesArgs
    quests?: boolean | UserCountOutputTypeCountQuestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerProfessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemInstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerTitleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLanguageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }


  /**
   * Count Type NPCCountOutputType
   */

  export type NPCCountOutputType = {
    stories: number
    quests: number
  }

  export type NPCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stories?: boolean | NPCCountOutputTypeCountStoriesArgs
    quests?: boolean | NPCCountOutputTypeCountQuestsArgs
  }

  // Custom InputTypes
  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCCountOutputType
     */
    select?: NPCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCStoryWhereInput
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    wildAreas: number
    dungeons: number
    npcs: number
    economies: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wildAreas?: boolean | CityCountOutputTypeCountWildAreasArgs
    dungeons?: boolean | CityCountOutputTypeCountDungeonsArgs
    npcs?: boolean | CityCountOutputTypeCountNpcsArgs
    economies?: boolean | CityCountOutputTypeCountEconomiesArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountWildAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WildAreaWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDungeonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DungeonWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountEconomiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EconomyWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
    wildAreas: number
    dungeons: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    wildAreas?: boolean | CountryCountOutputTypeCountWildAreasArgs
    dungeons?: boolean | CountryCountOutputTypeCountDungeonsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountWildAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WildAreaWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountDungeonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DungeonWhereInput
  }


  /**
   * Count Type WildAreaCountOutputType
   */

  export type WildAreaCountOutputType = {
    populations: number
  }

  export type WildAreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    populations?: boolean | WildAreaCountOutputTypeCountPopulationsArgs
  }

  // Custom InputTypes
  /**
   * WildAreaCountOutputType without action
   */
  export type WildAreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildAreaCountOutputType
     */
    select?: WildAreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WildAreaCountOutputType without action
   */
  export type WildAreaCountOutputTypeCountPopulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalPopulationWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    instances: number
    recipesAsProduct: number
    recipeMaterials: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | ItemCountOutputTypeCountInstancesArgs
    recipesAsProduct?: boolean | ItemCountOutputTypeCountRecipesAsProductArgs
    recipeMaterials?: boolean | ItemCountOutputTypeCountRecipeMaterialsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemInstanceWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountRecipesAsProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountRecipeMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeMaterialWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    materials: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | RecipeCountOutputTypeCountMaterialsArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeMaterialWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    speakers: number
    userLanguages: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speakers?: boolean | LanguageCountOutputTypeCountSpeakersArgs
    userLanguages?: boolean | LanguageCountOutputTypeCountUserLanguagesArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountUserLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLanguageWhereInput
  }


  /**
   * Count Type ReligionCountOutputType
   */

  export type ReligionCountOutputType = {
    artifacts: number
    followers: number
  }

  export type ReligionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | ReligionCountOutputTypeCountArtifactsArgs
    followers?: boolean | ReligionCountOutputTypeCountFollowersArgs
  }

  // Custom InputTypes
  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionCountOutputType
     */
    select?: ReligionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    positionX: number | null
    positionY: number | null
    reputation: number | null
    notoriety: number | null
    maxHp: number | null
    maxMp: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    positionX: number | null
    positionY: number | null
    reputation: number | null
    notoriety: number | null
    maxHp: number | null
    maxMp: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    positionX: number | null
    positionY: number | null
    reputation: number | null
    notoriety: number | null
    maxHp: number | null
    maxMp: number | null
    isOnline: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    positionX: number | null
    positionY: number | null
    reputation: number | null
    notoriety: number | null
    maxHp: number | null
    maxMp: number | null
    isOnline: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    positionX: number
    positionY: number
    reputation: number
    notoriety: number
    maxHp: number
    maxMp: number
    isOnline: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    positionX?: true
    positionY?: true
    reputation?: true
    notoriety?: true
    maxHp?: true
    maxMp?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    positionX?: true
    positionY?: true
    reputation?: true
    notoriety?: true
    maxHp?: true
    maxMp?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    positionX?: true
    positionY?: true
    reputation?: true
    notoriety?: true
    maxHp?: true
    maxMp?: true
    isOnline?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    positionX?: true
    positionY?: true
    reputation?: true
    notoriety?: true
    maxHp?: true
    maxMp?: true
    isOnline?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    positionX?: true
    positionY?: true
    reputation?: true
    notoriety?: true
    maxHp?: true
    maxMp?: true
    isOnline?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    positionX: number
    positionY: number
    reputation: number
    notoriety: number
    maxHp: number
    maxMp: number
    isOnline: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    positionX?: boolean
    positionY?: boolean
    reputation?: boolean
    notoriety?: boolean
    maxHp?: boolean
    maxMp?: boolean
    isOnline?: boolean
    profession?: boolean | User$professionArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    titles?: boolean | User$titlesArgs<ExtArgs>
    languages?: boolean | User$languagesArgs<ExtArgs>
    quests?: boolean | User$questsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    positionX?: boolean
    positionY?: boolean
    reputation?: boolean
    notoriety?: boolean
    maxHp?: boolean
    maxMp?: boolean
    isOnline?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    positionX?: boolean
    positionY?: boolean
    reputation?: boolean
    notoriety?: boolean
    maxHp?: boolean
    maxMp?: boolean
    isOnline?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    positionX?: boolean
    positionY?: boolean
    reputation?: boolean
    notoriety?: boolean
    maxHp?: boolean
    maxMp?: boolean
    isOnline?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "positionX" | "positionY" | "reputation" | "notoriety" | "maxHp" | "maxMp" | "isOnline", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profession?: boolean | User$professionArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    titles?: boolean | User$titlesArgs<ExtArgs>
    languages?: boolean | User$languagesArgs<ExtArgs>
    quests?: boolean | User$questsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profession: Prisma.$PlayerProfessionPayload<ExtArgs>[]
      inventory: Prisma.$ItemInstancePayload<ExtArgs>[]
      titles: Prisma.$PlayerTitlePayload<ExtArgs>[]
      languages: Prisma.$UserLanguagePayload<ExtArgs>[]
      quests: Prisma.$QuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      positionX: number
      positionY: number
      reputation: number
      notoriety: number
      maxHp: number
      maxMp: number
      isOnline: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profession<T extends User$professionArgs<ExtArgs> = {}>(args?: Subset<T, User$professionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    titles<T extends User$titlesArgs<ExtArgs> = {}>(args?: Subset<T, User$titlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languages<T extends User$languagesArgs<ExtArgs> = {}>(args?: Subset<T, User$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quests<T extends User$questsArgs<ExtArgs> = {}>(args?: Subset<T, User$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly positionX: FieldRef<"User", 'Float'>
    readonly positionY: FieldRef<"User", 'Float'>
    readonly reputation: FieldRef<"User", 'Int'>
    readonly notoriety: FieldRef<"User", 'Int'>
    readonly maxHp: FieldRef<"User", 'Int'>
    readonly maxMp: FieldRef<"User", 'Int'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profession
   */
  export type User$professionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    where?: PlayerProfessionWhereInput
    orderBy?: PlayerProfessionOrderByWithRelationInput | PlayerProfessionOrderByWithRelationInput[]
    cursor?: PlayerProfessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerProfessionScalarFieldEnum | PlayerProfessionScalarFieldEnum[]
  }

  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    where?: ItemInstanceWhereInput
    orderBy?: ItemInstanceOrderByWithRelationInput | ItemInstanceOrderByWithRelationInput[]
    cursor?: ItemInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemInstanceScalarFieldEnum | ItemInstanceScalarFieldEnum[]
  }

  /**
   * User.titles
   */
  export type User$titlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    where?: PlayerTitleWhereInput
    orderBy?: PlayerTitleOrderByWithRelationInput | PlayerTitleOrderByWithRelationInput[]
    cursor?: PlayerTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerTitleScalarFieldEnum | PlayerTitleScalarFieldEnum[]
  }

  /**
   * User.languages
   */
  export type User$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    where?: UserLanguageWhereInput
    orderBy?: UserLanguageOrderByWithRelationInput | UserLanguageOrderByWithRelationInput[]
    cursor?: UserLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLanguageScalarFieldEnum | UserLanguageScalarFieldEnum[]
  }

  /**
   * User.quests
   */
  export type User$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model NPC
   */

  export type AggregateNPC = {
    _count: NPCCountAggregateOutputType | null
    _avg: NPCAvgAggregateOutputType | null
    _sum: NPCSumAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  export type NPCAvgAggregateOutputType = {
    id: number | null
    birthYear: number | null
    deathYear: number | null
    fame: number | null
    notoriety: number | null
    cityId: number | null
    partnerId: number | null
    parent1Id: number | null
    parent2Id: number | null
    languageId: number | null
    religionId: number | null
  }

  export type NPCSumAggregateOutputType = {
    id: number | null
    birthYear: number | null
    deathYear: number | null
    fame: number | null
    notoriety: number | null
    cityId: number | null
    partnerId: number | null
    parent1Id: number | null
    parent2Id: number | null
    languageId: number | null
    religionId: number | null
  }

  export type NPCMinAggregateOutputType = {
    id: number | null
    name: string | null
    gender: string | null
    birthYear: number | null
    deathYear: number | null
    isAlive: boolean | null
    mood: string | null
    fame: number | null
    notoriety: number | null
    cityId: number | null
    partnerId: number | null
    parent1Id: number | null
    parent2Id: number | null
    isNoble: boolean | null
    nobleTitle: string | null
    personality: string | null
    background: string | null
    job: string | null
    skills: string | null
    languageId: number | null
    religionId: number | null
  }

  export type NPCMaxAggregateOutputType = {
    id: number | null
    name: string | null
    gender: string | null
    birthYear: number | null
    deathYear: number | null
    isAlive: boolean | null
    mood: string | null
    fame: number | null
    notoriety: number | null
    cityId: number | null
    partnerId: number | null
    parent1Id: number | null
    parent2Id: number | null
    isNoble: boolean | null
    nobleTitle: string | null
    personality: string | null
    background: string | null
    job: string | null
    skills: string | null
    languageId: number | null
    religionId: number | null
  }

  export type NPCCountAggregateOutputType = {
    id: number
    name: number
    gender: number
    birthYear: number
    deathYear: number
    isAlive: number
    mood: number
    fame: number
    notoriety: number
    cityId: number
    partnerId: number
    parent1Id: number
    parent2Id: number
    isNoble: number
    nobleTitle: number
    personality: number
    background: number
    job: number
    skills: number
    languageId: number
    religionId: number
    _all: number
  }


  export type NPCAvgAggregateInputType = {
    id?: true
    birthYear?: true
    deathYear?: true
    fame?: true
    notoriety?: true
    cityId?: true
    partnerId?: true
    parent1Id?: true
    parent2Id?: true
    languageId?: true
    religionId?: true
  }

  export type NPCSumAggregateInputType = {
    id?: true
    birthYear?: true
    deathYear?: true
    fame?: true
    notoriety?: true
    cityId?: true
    partnerId?: true
    parent1Id?: true
    parent2Id?: true
    languageId?: true
    religionId?: true
  }

  export type NPCMinAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    birthYear?: true
    deathYear?: true
    isAlive?: true
    mood?: true
    fame?: true
    notoriety?: true
    cityId?: true
    partnerId?: true
    parent1Id?: true
    parent2Id?: true
    isNoble?: true
    nobleTitle?: true
    personality?: true
    background?: true
    job?: true
    skills?: true
    languageId?: true
    religionId?: true
  }

  export type NPCMaxAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    birthYear?: true
    deathYear?: true
    isAlive?: true
    mood?: true
    fame?: true
    notoriety?: true
    cityId?: true
    partnerId?: true
    parent1Id?: true
    parent2Id?: true
    isNoble?: true
    nobleTitle?: true
    personality?: true
    background?: true
    job?: true
    skills?: true
    languageId?: true
    religionId?: true
  }

  export type NPCCountAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    birthYear?: true
    deathYear?: true
    isAlive?: true
    mood?: true
    fame?: true
    notoriety?: true
    cityId?: true
    partnerId?: true
    parent1Id?: true
    parent2Id?: true
    isNoble?: true
    nobleTitle?: true
    personality?: true
    background?: true
    job?: true
    skills?: true
    languageId?: true
    religionId?: true
    _all?: true
  }

  export type NPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPC to aggregate.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPCS
    **/
    _count?: true | NPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NPCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NPCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPCMaxAggregateInputType
  }

  export type GetNPCAggregateType<T extends NPCAggregateArgs> = {
        [P in keyof T & keyof AggregateNPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPC[P]>
      : GetScalarType<T[P], AggregateNPC[P]>
  }




  export type NPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithAggregationInput | NPCOrderByWithAggregationInput[]
    by: NPCScalarFieldEnum[] | NPCScalarFieldEnum
    having?: NPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPCCountAggregateInputType | true
    _avg?: NPCAvgAggregateInputType
    _sum?: NPCSumAggregateInputType
    _min?: NPCMinAggregateInputType
    _max?: NPCMaxAggregateInputType
  }

  export type NPCGroupByOutputType = {
    id: number
    name: string
    gender: string
    birthYear: number
    deathYear: number | null
    isAlive: boolean
    mood: string
    fame: number
    notoriety: number
    cityId: number
    partnerId: number | null
    parent1Id: number | null
    parent2Id: number | null
    isNoble: boolean
    nobleTitle: string | null
    personality: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId: number | null
    _count: NPCCountAggregateOutputType | null
    _avg: NPCAvgAggregateOutputType | null
    _sum: NPCSumAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  type GetNPCGroupByPayload<T extends NPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPCGroupByOutputType[P]>
            : GetScalarType<T[P], NPCGroupByOutputType[P]>
        }
      >
    >


  export type NPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    birthYear?: boolean
    deathYear?: boolean
    isAlive?: boolean
    mood?: boolean
    fame?: boolean
    notoriety?: boolean
    cityId?: boolean
    partnerId?: boolean
    parent1Id?: boolean
    parent2Id?: boolean
    isNoble?: boolean
    nobleTitle?: boolean
    personality?: boolean
    background?: boolean
    job?: boolean
    skills?: boolean
    languageId?: boolean
    religionId?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    religion?: boolean | NPC$religionArgs<ExtArgs>
    stories?: boolean | NPC$storiesArgs<ExtArgs>
    quests?: boolean | NPC$questsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    birthYear?: boolean
    deathYear?: boolean
    isAlive?: boolean
    mood?: boolean
    fame?: boolean
    notoriety?: boolean
    cityId?: boolean
    partnerId?: boolean
    parent1Id?: boolean
    parent2Id?: boolean
    isNoble?: boolean
    nobleTitle?: boolean
    personality?: boolean
    background?: boolean
    job?: boolean
    skills?: boolean
    languageId?: boolean
    religionId?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    religion?: boolean | NPC$religionArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    birthYear?: boolean
    deathYear?: boolean
    isAlive?: boolean
    mood?: boolean
    fame?: boolean
    notoriety?: boolean
    cityId?: boolean
    partnerId?: boolean
    parent1Id?: boolean
    parent2Id?: boolean
    isNoble?: boolean
    nobleTitle?: boolean
    personality?: boolean
    background?: boolean
    job?: boolean
    skills?: boolean
    languageId?: boolean
    religionId?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    religion?: boolean | NPC$religionArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectScalar = {
    id?: boolean
    name?: boolean
    gender?: boolean
    birthYear?: boolean
    deathYear?: boolean
    isAlive?: boolean
    mood?: boolean
    fame?: boolean
    notoriety?: boolean
    cityId?: boolean
    partnerId?: boolean
    parent1Id?: boolean
    parent2Id?: boolean
    isNoble?: boolean
    nobleTitle?: boolean
    personality?: boolean
    background?: boolean
    job?: boolean
    skills?: boolean
    languageId?: boolean
    religionId?: boolean
  }

  export type NPCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "gender" | "birthYear" | "deathYear" | "isAlive" | "mood" | "fame" | "notoriety" | "cityId" | "partnerId" | "parent1Id" | "parent2Id" | "isNoble" | "nobleTitle" | "personality" | "background" | "job" | "skills" | "languageId" | "religionId", ExtArgs["result"]["nPC"]>
  export type NPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    religion?: boolean | NPC$religionArgs<ExtArgs>
    stories?: boolean | NPC$storiesArgs<ExtArgs>
    quests?: boolean | NPC$questsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    religion?: boolean | NPC$religionArgs<ExtArgs>
  }
  export type NPCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    religion?: boolean | NPC$religionArgs<ExtArgs>
  }

  export type $NPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPC"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
      religion: Prisma.$ReligionPayload<ExtArgs> | null
      stories: Prisma.$NPCStoryPayload<ExtArgs>[]
      quests: Prisma.$QuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      gender: string
      birthYear: number
      deathYear: number | null
      isAlive: boolean
      mood: string
      fame: number
      notoriety: number
      cityId: number
      partnerId: number | null
      parent1Id: number | null
      parent2Id: number | null
      isNoble: boolean
      nobleTitle: string | null
      personality: string | null
      background: string
      job: string
      skills: string
      languageId: number
      religionId: number | null
    }, ExtArgs["result"]["nPC"]>
    composites: {}
  }

  type NPCGetPayload<S extends boolean | null | undefined | NPCDefaultArgs> = $Result.GetResult<Prisma.$NPCPayload, S>

  type NPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NPCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NPCCountAggregateInputType | true
    }

  export interface NPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPC'], meta: { name: 'NPC' } }
    /**
     * Find zero or one NPC that matches the filter.
     * @param {NPCFindUniqueArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPCFindUniqueArgs>(args: SelectSubset<T, NPCFindUniqueArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NPC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NPCFindUniqueOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPCFindUniqueOrThrowArgs>(args: SelectSubset<T, NPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPCFindFirstArgs>(args?: SelectSubset<T, NPCFindFirstArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPCFindFirstOrThrowArgs>(args?: SelectSubset<T, NPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPCS
     * const nPCS = await prisma.nPC.findMany()
     * 
     * // Get first 10 NPCS
     * const nPCS = await prisma.nPC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nPCWithIdOnly = await prisma.nPC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NPCFindManyArgs>(args?: SelectSubset<T, NPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NPC.
     * @param {NPCCreateArgs} args - Arguments to create a NPC.
     * @example
     * // Create one NPC
     * const NPC = await prisma.nPC.create({
     *   data: {
     *     // ... data to create a NPC
     *   }
     * })
     * 
     */
    create<T extends NPCCreateArgs>(args: SelectSubset<T, NPCCreateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NPCS.
     * @param {NPCCreateManyArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPCCreateManyArgs>(args?: SelectSubset<T, NPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPCS and returns the data saved in the database.
     * @param {NPCCreateManyAndReturnArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPCCreateManyAndReturnArgs>(args?: SelectSubset<T, NPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NPC.
     * @param {NPCDeleteArgs} args - Arguments to delete one NPC.
     * @example
     * // Delete one NPC
     * const NPC = await prisma.nPC.delete({
     *   where: {
     *     // ... filter to delete one NPC
     *   }
     * })
     * 
     */
    delete<T extends NPCDeleteArgs>(args: SelectSubset<T, NPCDeleteArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NPC.
     * @param {NPCUpdateArgs} args - Arguments to update one NPC.
     * @example
     * // Update one NPC
     * const nPC = await prisma.nPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPCUpdateArgs>(args: SelectSubset<T, NPCUpdateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NPCS.
     * @param {NPCDeleteManyArgs} args - Arguments to filter NPCS to delete.
     * @example
     * // Delete a few NPCS
     * const { count } = await prisma.nPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPCDeleteManyArgs>(args?: SelectSubset<T, NPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPCUpdateManyArgs>(args: SelectSubset<T, NPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS and returns the data updated in the database.
     * @param {NPCUpdateManyAndReturnArgs} args - Arguments to update many NPCS.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NPCUpdateManyAndReturnArgs>(args: SelectSubset<T, NPCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NPC.
     * @param {NPCUpsertArgs} args - Arguments to update or create a NPC.
     * @example
     * // Update or create a NPC
     * const nPC = await prisma.nPC.upsert({
     *   create: {
     *     // ... data to create a NPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPC we want to update
     *   }
     * })
     */
    upsert<T extends NPCUpsertArgs>(args: SelectSubset<T, NPCUpsertArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCCountArgs} args - Arguments to filter NPCS to count.
     * @example
     * // Count the number of NPCS
     * const count = await prisma.nPC.count({
     *   where: {
     *     // ... the filter for the NPCS we want to count
     *   }
     * })
    **/
    count<T extends NPCCountArgs>(
      args?: Subset<T, NPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPCAggregateArgs>(args: Subset<T, NPCAggregateArgs>): Prisma.PrismaPromise<GetNPCAggregateType<T>>

    /**
     * Group by NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPCGroupByArgs['orderBy'] }
        : { orderBy?: NPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPC model
   */
  readonly fields: NPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    religion<T extends NPC$religionArgs<ExtArgs> = {}>(args?: Subset<T, NPC$religionArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stories<T extends NPC$storiesArgs<ExtArgs> = {}>(args?: Subset<T, NPC$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quests<T extends NPC$questsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPC model
   */
  interface NPCFieldRefs {
    readonly id: FieldRef<"NPC", 'Int'>
    readonly name: FieldRef<"NPC", 'String'>
    readonly gender: FieldRef<"NPC", 'String'>
    readonly birthYear: FieldRef<"NPC", 'Int'>
    readonly deathYear: FieldRef<"NPC", 'Int'>
    readonly isAlive: FieldRef<"NPC", 'Boolean'>
    readonly mood: FieldRef<"NPC", 'String'>
    readonly fame: FieldRef<"NPC", 'Int'>
    readonly notoriety: FieldRef<"NPC", 'Int'>
    readonly cityId: FieldRef<"NPC", 'Int'>
    readonly partnerId: FieldRef<"NPC", 'Int'>
    readonly parent1Id: FieldRef<"NPC", 'Int'>
    readonly parent2Id: FieldRef<"NPC", 'Int'>
    readonly isNoble: FieldRef<"NPC", 'Boolean'>
    readonly nobleTitle: FieldRef<"NPC", 'String'>
    readonly personality: FieldRef<"NPC", 'String'>
    readonly background: FieldRef<"NPC", 'String'>
    readonly job: FieldRef<"NPC", 'String'>
    readonly skills: FieldRef<"NPC", 'String'>
    readonly languageId: FieldRef<"NPC", 'Int'>
    readonly religionId: FieldRef<"NPC", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NPC findUnique
   */
  export type NPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findUniqueOrThrow
   */
  export type NPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findFirst
   */
  export type NPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findFirstOrThrow
   */
  export type NPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findMany
   */
  export type NPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPCS to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC create
   */
  export type NPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to create a NPC.
     */
    data: XOR<NPCCreateInput, NPCUncheckedCreateInput>
  }

  /**
   * NPC createMany
   */
  export type NPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NPC createManyAndReturn
   */
  export type NPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC update
   */
  export type NPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to update a NPC.
     */
    data: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
    /**
     * Choose, which NPC to update.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC updateMany
   */
  export type NPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to update.
     */
    limit?: number
  }

  /**
   * NPC updateManyAndReturn
   */
  export type NPCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC upsert
   */
  export type NPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The filter to search for the NPC to update in case it exists.
     */
    where: NPCWhereUniqueInput
    /**
     * In case the NPC found by the `where` argument doesn't exist, create a new NPC with this data.
     */
    create: XOR<NPCCreateInput, NPCUncheckedCreateInput>
    /**
     * In case the NPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
  }

  /**
   * NPC delete
   */
  export type NPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter which NPC to delete.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC deleteMany
   */
  export type NPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCS to delete
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to delete.
     */
    limit?: number
  }

  /**
   * NPC.religion
   */
  export type NPC$religionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    where?: ReligionWhereInput
  }

  /**
   * NPC.stories
   */
  export type NPC$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    where?: NPCStoryWhereInput
    orderBy?: NPCStoryOrderByWithRelationInput | NPCStoryOrderByWithRelationInput[]
    cursor?: NPCStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCStoryScalarFieldEnum | NPCStoryScalarFieldEnum[]
  }

  /**
   * NPC.quests
   */
  export type NPC$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * NPC without action
   */
  export type NPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    population: number | null
    countryId: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    population: number | null
    countryId: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    population: number | null
    countryId: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    population: number | null
    countryId: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    population: number
    countryId: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    population?: true
    countryId?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    population?: true
    countryId?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    population?: true
    countryId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    population?: true
    countryId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    population?: true
    countryId?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: number
    name: string
    description: string
    population: number
    countryId: number
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    population?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    wildAreas?: boolean | City$wildAreasArgs<ExtArgs>
    dungeons?: boolean | City$dungeonsArgs<ExtArgs>
    weather?: boolean | City$weatherArgs<ExtArgs>
    npcs?: boolean | City$npcsArgs<ExtArgs>
    economies?: boolean | City$economiesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    population?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    population?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    population?: boolean
    countryId?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "population" | "countryId", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    wildAreas?: boolean | City$wildAreasArgs<ExtArgs>
    dungeons?: boolean | City$dungeonsArgs<ExtArgs>
    weather?: boolean | City$weatherArgs<ExtArgs>
    npcs?: boolean | City$npcsArgs<ExtArgs>
    economies?: boolean | City$economiesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      wildAreas: Prisma.$WildAreaPayload<ExtArgs>[]
      dungeons: Prisma.$DungeonPayload<ExtArgs>[]
      weather: Prisma.$WeatherPayload<ExtArgs> | null
      npcs: Prisma.$NPCPayload<ExtArgs>[]
      economies: Prisma.$EconomyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      population: number
      countryId: number
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    wildAreas<T extends City$wildAreasArgs<ExtArgs> = {}>(args?: Subset<T, City$wildAreasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dungeons<T extends City$dungeonsArgs<ExtArgs> = {}>(args?: Subset<T, City$dungeonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weather<T extends City$weatherArgs<ExtArgs> = {}>(args?: Subset<T, City$weatherArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    npcs<T extends City$npcsArgs<ExtArgs> = {}>(args?: Subset<T, City$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    economies<T extends City$economiesArgs<ExtArgs> = {}>(args?: Subset<T, City$economiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'Int'>
    readonly name: FieldRef<"City", 'String'>
    readonly description: FieldRef<"City", 'String'>
    readonly population: FieldRef<"City", 'Int'>
    readonly countryId: FieldRef<"City", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.wildAreas
   */
  export type City$wildAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    where?: WildAreaWhereInput
    orderBy?: WildAreaOrderByWithRelationInput | WildAreaOrderByWithRelationInput[]
    cursor?: WildAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WildAreaScalarFieldEnum | WildAreaScalarFieldEnum[]
  }

  /**
   * City.dungeons
   */
  export type City$dungeonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    where?: DungeonWhereInput
    orderBy?: DungeonOrderByWithRelationInput | DungeonOrderByWithRelationInput[]
    cursor?: DungeonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DungeonScalarFieldEnum | DungeonScalarFieldEnum[]
  }

  /**
   * City.weather
   */
  export type City$weatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    where?: WeatherWhereInput
  }

  /**
   * City.npcs
   */
  export type City$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    cursor?: NPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * City.economies
   */
  export type City$economiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    where?: EconomyWhereInput
    orderBy?: EconomyOrderByWithRelationInput | EconomyOrderByWithRelationInput[]
    cursor?: EconomyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EconomyScalarFieldEnum | EconomyScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    language: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    language: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    language: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    language?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    language?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    language?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    description: string
    language: string
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    language?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    wildAreas?: boolean | Country$wildAreasArgs<ExtArgs>
    dungeons?: boolean | Country$dungeonsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    language?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    language?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    language?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "language", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    wildAreas?: boolean | Country$wildAreasArgs<ExtArgs>
    dungeons?: boolean | Country$dungeonsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      wildAreas: Prisma.$WildAreaPayload<ExtArgs>[]
      dungeons: Prisma.$DungeonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      language: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wildAreas<T extends Country$wildAreasArgs<ExtArgs> = {}>(args?: Subset<T, Country$wildAreasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dungeons<T extends Country$dungeonsArgs<ExtArgs> = {}>(args?: Subset<T, Country$dungeonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly description: FieldRef<"Country", 'String'>
    readonly language: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.wildAreas
   */
  export type Country$wildAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    where?: WildAreaWhereInput
    orderBy?: WildAreaOrderByWithRelationInput | WildAreaOrderByWithRelationInput[]
    cursor?: WildAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WildAreaScalarFieldEnum | WildAreaScalarFieldEnum[]
  }

  /**
   * Country.dungeons
   */
  export type Country$dungeonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    where?: DungeonWhereInput
    orderBy?: DungeonOrderByWithRelationInput | DungeonOrderByWithRelationInput[]
    cursor?: DungeonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DungeonScalarFieldEnum | DungeonScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model WildArea
   */

  export type AggregateWildArea = {
    _count: WildAreaCountAggregateOutputType | null
    _avg: WildAreaAvgAggregateOutputType | null
    _sum: WildAreaSumAggregateOutputType | null
    _min: WildAreaMinAggregateOutputType | null
    _max: WildAreaMaxAggregateOutputType | null
  }

  export type WildAreaAvgAggregateOutputType = {
    id: number | null
    dangerLevel: number | null
    countryId: number | null
    cityId: number | null
  }

  export type WildAreaSumAggregateOutputType = {
    id: number | null
    dangerLevel: number | null
    countryId: number | null
    cityId: number | null
  }

  export type WildAreaMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    dangerLevel: number | null
    countryId: number | null
    cityId: number | null
  }

  export type WildAreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    dangerLevel: number | null
    countryId: number | null
    cityId: number | null
  }

  export type WildAreaCountAggregateOutputType = {
    id: number
    name: number
    type: number
    dangerLevel: number
    countryId: number
    cityId: number
    _all: number
  }


  export type WildAreaAvgAggregateInputType = {
    id?: true
    dangerLevel?: true
    countryId?: true
    cityId?: true
  }

  export type WildAreaSumAggregateInputType = {
    id?: true
    dangerLevel?: true
    countryId?: true
    cityId?: true
  }

  export type WildAreaMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    dangerLevel?: true
    countryId?: true
    cityId?: true
  }

  export type WildAreaMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    dangerLevel?: true
    countryId?: true
    cityId?: true
  }

  export type WildAreaCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    dangerLevel?: true
    countryId?: true
    cityId?: true
    _all?: true
  }

  export type WildAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WildArea to aggregate.
     */
    where?: WildAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WildAreas to fetch.
     */
    orderBy?: WildAreaOrderByWithRelationInput | WildAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WildAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WildAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WildAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WildAreas
    **/
    _count?: true | WildAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WildAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WildAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WildAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WildAreaMaxAggregateInputType
  }

  export type GetWildAreaAggregateType<T extends WildAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateWildArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWildArea[P]>
      : GetScalarType<T[P], AggregateWildArea[P]>
  }




  export type WildAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WildAreaWhereInput
    orderBy?: WildAreaOrderByWithAggregationInput | WildAreaOrderByWithAggregationInput[]
    by: WildAreaScalarFieldEnum[] | WildAreaScalarFieldEnum
    having?: WildAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WildAreaCountAggregateInputType | true
    _avg?: WildAreaAvgAggregateInputType
    _sum?: WildAreaSumAggregateInputType
    _min?: WildAreaMinAggregateInputType
    _max?: WildAreaMaxAggregateInputType
  }

  export type WildAreaGroupByOutputType = {
    id: number
    name: string
    type: string
    dangerLevel: number
    countryId: number
    cityId: number | null
    _count: WildAreaCountAggregateOutputType | null
    _avg: WildAreaAvgAggregateOutputType | null
    _sum: WildAreaSumAggregateOutputType | null
    _min: WildAreaMinAggregateOutputType | null
    _max: WildAreaMaxAggregateOutputType | null
  }

  type GetWildAreaGroupByPayload<T extends WildAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WildAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WildAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WildAreaGroupByOutputType[P]>
            : GetScalarType<T[P], WildAreaGroupByOutputType[P]>
        }
      >
    >


  export type WildAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    dangerLevel?: boolean
    countryId?: boolean
    cityId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    populations?: boolean | WildArea$populationsArgs<ExtArgs>
    city?: boolean | WildArea$cityArgs<ExtArgs>
    _count?: boolean | WildAreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wildArea"]>

  export type WildAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    dangerLevel?: boolean
    countryId?: boolean
    cityId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | WildArea$cityArgs<ExtArgs>
  }, ExtArgs["result"]["wildArea"]>

  export type WildAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    dangerLevel?: boolean
    countryId?: boolean
    cityId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | WildArea$cityArgs<ExtArgs>
  }, ExtArgs["result"]["wildArea"]>

  export type WildAreaSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    dangerLevel?: boolean
    countryId?: boolean
    cityId?: boolean
  }

  export type WildAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "dangerLevel" | "countryId" | "cityId", ExtArgs["result"]["wildArea"]>
  export type WildAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    populations?: boolean | WildArea$populationsArgs<ExtArgs>
    city?: boolean | WildArea$cityArgs<ExtArgs>
    _count?: boolean | WildAreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WildAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | WildArea$cityArgs<ExtArgs>
  }
  export type WildAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | WildArea$cityArgs<ExtArgs>
  }

  export type $WildAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WildArea"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      populations: Prisma.$AnimalPopulationPayload<ExtArgs>[]
      city: Prisma.$CityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      dangerLevel: number
      countryId: number
      cityId: number | null
    }, ExtArgs["result"]["wildArea"]>
    composites: {}
  }

  type WildAreaGetPayload<S extends boolean | null | undefined | WildAreaDefaultArgs> = $Result.GetResult<Prisma.$WildAreaPayload, S>

  type WildAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WildAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WildAreaCountAggregateInputType | true
    }

  export interface WildAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WildArea'], meta: { name: 'WildArea' } }
    /**
     * Find zero or one WildArea that matches the filter.
     * @param {WildAreaFindUniqueArgs} args - Arguments to find a WildArea
     * @example
     * // Get one WildArea
     * const wildArea = await prisma.wildArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WildAreaFindUniqueArgs>(args: SelectSubset<T, WildAreaFindUniqueArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WildArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WildAreaFindUniqueOrThrowArgs} args - Arguments to find a WildArea
     * @example
     * // Get one WildArea
     * const wildArea = await prisma.wildArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WildAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, WildAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WildArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaFindFirstArgs} args - Arguments to find a WildArea
     * @example
     * // Get one WildArea
     * const wildArea = await prisma.wildArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WildAreaFindFirstArgs>(args?: SelectSubset<T, WildAreaFindFirstArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WildArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaFindFirstOrThrowArgs} args - Arguments to find a WildArea
     * @example
     * // Get one WildArea
     * const wildArea = await prisma.wildArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WildAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, WildAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WildAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WildAreas
     * const wildAreas = await prisma.wildArea.findMany()
     * 
     * // Get first 10 WildAreas
     * const wildAreas = await prisma.wildArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wildAreaWithIdOnly = await prisma.wildArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WildAreaFindManyArgs>(args?: SelectSubset<T, WildAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WildArea.
     * @param {WildAreaCreateArgs} args - Arguments to create a WildArea.
     * @example
     * // Create one WildArea
     * const WildArea = await prisma.wildArea.create({
     *   data: {
     *     // ... data to create a WildArea
     *   }
     * })
     * 
     */
    create<T extends WildAreaCreateArgs>(args: SelectSubset<T, WildAreaCreateArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WildAreas.
     * @param {WildAreaCreateManyArgs} args - Arguments to create many WildAreas.
     * @example
     * // Create many WildAreas
     * const wildArea = await prisma.wildArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WildAreaCreateManyArgs>(args?: SelectSubset<T, WildAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WildAreas and returns the data saved in the database.
     * @param {WildAreaCreateManyAndReturnArgs} args - Arguments to create many WildAreas.
     * @example
     * // Create many WildAreas
     * const wildArea = await prisma.wildArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WildAreas and only return the `id`
     * const wildAreaWithIdOnly = await prisma.wildArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WildAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, WildAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WildArea.
     * @param {WildAreaDeleteArgs} args - Arguments to delete one WildArea.
     * @example
     * // Delete one WildArea
     * const WildArea = await prisma.wildArea.delete({
     *   where: {
     *     // ... filter to delete one WildArea
     *   }
     * })
     * 
     */
    delete<T extends WildAreaDeleteArgs>(args: SelectSubset<T, WildAreaDeleteArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WildArea.
     * @param {WildAreaUpdateArgs} args - Arguments to update one WildArea.
     * @example
     * // Update one WildArea
     * const wildArea = await prisma.wildArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WildAreaUpdateArgs>(args: SelectSubset<T, WildAreaUpdateArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WildAreas.
     * @param {WildAreaDeleteManyArgs} args - Arguments to filter WildAreas to delete.
     * @example
     * // Delete a few WildAreas
     * const { count } = await prisma.wildArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WildAreaDeleteManyArgs>(args?: SelectSubset<T, WildAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WildAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WildAreas
     * const wildArea = await prisma.wildArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WildAreaUpdateManyArgs>(args: SelectSubset<T, WildAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WildAreas and returns the data updated in the database.
     * @param {WildAreaUpdateManyAndReturnArgs} args - Arguments to update many WildAreas.
     * @example
     * // Update many WildAreas
     * const wildArea = await prisma.wildArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WildAreas and only return the `id`
     * const wildAreaWithIdOnly = await prisma.wildArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WildAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, WildAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WildArea.
     * @param {WildAreaUpsertArgs} args - Arguments to update or create a WildArea.
     * @example
     * // Update or create a WildArea
     * const wildArea = await prisma.wildArea.upsert({
     *   create: {
     *     // ... data to create a WildArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WildArea we want to update
     *   }
     * })
     */
    upsert<T extends WildAreaUpsertArgs>(args: SelectSubset<T, WildAreaUpsertArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WildAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaCountArgs} args - Arguments to filter WildAreas to count.
     * @example
     * // Count the number of WildAreas
     * const count = await prisma.wildArea.count({
     *   where: {
     *     // ... the filter for the WildAreas we want to count
     *   }
     * })
    **/
    count<T extends WildAreaCountArgs>(
      args?: Subset<T, WildAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WildAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WildArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WildAreaAggregateArgs>(args: Subset<T, WildAreaAggregateArgs>): Prisma.PrismaPromise<GetWildAreaAggregateType<T>>

    /**
     * Group by WildArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WildAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WildAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WildAreaGroupByArgs['orderBy'] }
        : { orderBy?: WildAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WildAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWildAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WildArea model
   */
  readonly fields: WildAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WildArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WildAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    populations<T extends WildArea$populationsArgs<ExtArgs> = {}>(args?: Subset<T, WildArea$populationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    city<T extends WildArea$cityArgs<ExtArgs> = {}>(args?: Subset<T, WildArea$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WildArea model
   */
  interface WildAreaFieldRefs {
    readonly id: FieldRef<"WildArea", 'Int'>
    readonly name: FieldRef<"WildArea", 'String'>
    readonly type: FieldRef<"WildArea", 'String'>
    readonly dangerLevel: FieldRef<"WildArea", 'Int'>
    readonly countryId: FieldRef<"WildArea", 'Int'>
    readonly cityId: FieldRef<"WildArea", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WildArea findUnique
   */
  export type WildAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * Filter, which WildArea to fetch.
     */
    where: WildAreaWhereUniqueInput
  }

  /**
   * WildArea findUniqueOrThrow
   */
  export type WildAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * Filter, which WildArea to fetch.
     */
    where: WildAreaWhereUniqueInput
  }

  /**
   * WildArea findFirst
   */
  export type WildAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * Filter, which WildArea to fetch.
     */
    where?: WildAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WildAreas to fetch.
     */
    orderBy?: WildAreaOrderByWithRelationInput | WildAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WildAreas.
     */
    cursor?: WildAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WildAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WildAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WildAreas.
     */
    distinct?: WildAreaScalarFieldEnum | WildAreaScalarFieldEnum[]
  }

  /**
   * WildArea findFirstOrThrow
   */
  export type WildAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * Filter, which WildArea to fetch.
     */
    where?: WildAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WildAreas to fetch.
     */
    orderBy?: WildAreaOrderByWithRelationInput | WildAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WildAreas.
     */
    cursor?: WildAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WildAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WildAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WildAreas.
     */
    distinct?: WildAreaScalarFieldEnum | WildAreaScalarFieldEnum[]
  }

  /**
   * WildArea findMany
   */
  export type WildAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * Filter, which WildAreas to fetch.
     */
    where?: WildAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WildAreas to fetch.
     */
    orderBy?: WildAreaOrderByWithRelationInput | WildAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WildAreas.
     */
    cursor?: WildAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WildAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WildAreas.
     */
    skip?: number
    distinct?: WildAreaScalarFieldEnum | WildAreaScalarFieldEnum[]
  }

  /**
   * WildArea create
   */
  export type WildAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a WildArea.
     */
    data: XOR<WildAreaCreateInput, WildAreaUncheckedCreateInput>
  }

  /**
   * WildArea createMany
   */
  export type WildAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WildAreas.
     */
    data: WildAreaCreateManyInput | WildAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WildArea createManyAndReturn
   */
  export type WildAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * The data used to create many WildAreas.
     */
    data: WildAreaCreateManyInput | WildAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WildArea update
   */
  export type WildAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a WildArea.
     */
    data: XOR<WildAreaUpdateInput, WildAreaUncheckedUpdateInput>
    /**
     * Choose, which WildArea to update.
     */
    where: WildAreaWhereUniqueInput
  }

  /**
   * WildArea updateMany
   */
  export type WildAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WildAreas.
     */
    data: XOR<WildAreaUpdateManyMutationInput, WildAreaUncheckedUpdateManyInput>
    /**
     * Filter which WildAreas to update
     */
    where?: WildAreaWhereInput
    /**
     * Limit how many WildAreas to update.
     */
    limit?: number
  }

  /**
   * WildArea updateManyAndReturn
   */
  export type WildAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * The data used to update WildAreas.
     */
    data: XOR<WildAreaUpdateManyMutationInput, WildAreaUncheckedUpdateManyInput>
    /**
     * Filter which WildAreas to update
     */
    where?: WildAreaWhereInput
    /**
     * Limit how many WildAreas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WildArea upsert
   */
  export type WildAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the WildArea to update in case it exists.
     */
    where: WildAreaWhereUniqueInput
    /**
     * In case the WildArea found by the `where` argument doesn't exist, create a new WildArea with this data.
     */
    create: XOR<WildAreaCreateInput, WildAreaUncheckedCreateInput>
    /**
     * In case the WildArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WildAreaUpdateInput, WildAreaUncheckedUpdateInput>
  }

  /**
   * WildArea delete
   */
  export type WildAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
    /**
     * Filter which WildArea to delete.
     */
    where: WildAreaWhereUniqueInput
  }

  /**
   * WildArea deleteMany
   */
  export type WildAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WildAreas to delete
     */
    where?: WildAreaWhereInput
    /**
     * Limit how many WildAreas to delete.
     */
    limit?: number
  }

  /**
   * WildArea.populations
   */
  export type WildArea$populationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    where?: AnimalPopulationWhereInput
    orderBy?: AnimalPopulationOrderByWithRelationInput | AnimalPopulationOrderByWithRelationInput[]
    cursor?: AnimalPopulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimalPopulationScalarFieldEnum | AnimalPopulationScalarFieldEnum[]
  }

  /**
   * WildArea.city
   */
  export type WildArea$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * WildArea without action
   */
  export type WildAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WildArea
     */
    select?: WildAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WildArea
     */
    omit?: WildAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WildAreaInclude<ExtArgs> | null
  }


  /**
   * Model Dungeon
   */

  export type AggregateDungeon = {
    _count: DungeonCountAggregateOutputType | null
    _avg: DungeonAvgAggregateOutputType | null
    _sum: DungeonSumAggregateOutputType | null
    _min: DungeonMinAggregateOutputType | null
    _max: DungeonMaxAggregateOutputType | null
  }

  export type DungeonAvgAggregateOutputType = {
    id: number | null
    levelRequirement: number | null
    countryId: number | null
    cityId: number | null
  }

  export type DungeonSumAggregateOutputType = {
    id: number | null
    levelRequirement: number | null
    countryId: number | null
    cityId: number | null
  }

  export type DungeonMinAggregateOutputType = {
    id: number | null
    name: string | null
    levelRequirement: number | null
    isRaid: boolean | null
    countryId: number | null
    cityId: number | null
  }

  export type DungeonMaxAggregateOutputType = {
    id: number | null
    name: string | null
    levelRequirement: number | null
    isRaid: boolean | null
    countryId: number | null
    cityId: number | null
  }

  export type DungeonCountAggregateOutputType = {
    id: number
    name: number
    levelRequirement: number
    isRaid: number
    countryId: number
    cityId: number
    _all: number
  }


  export type DungeonAvgAggregateInputType = {
    id?: true
    levelRequirement?: true
    countryId?: true
    cityId?: true
  }

  export type DungeonSumAggregateInputType = {
    id?: true
    levelRequirement?: true
    countryId?: true
    cityId?: true
  }

  export type DungeonMinAggregateInputType = {
    id?: true
    name?: true
    levelRequirement?: true
    isRaid?: true
    countryId?: true
    cityId?: true
  }

  export type DungeonMaxAggregateInputType = {
    id?: true
    name?: true
    levelRequirement?: true
    isRaid?: true
    countryId?: true
    cityId?: true
  }

  export type DungeonCountAggregateInputType = {
    id?: true
    name?: true
    levelRequirement?: true
    isRaid?: true
    countryId?: true
    cityId?: true
    _all?: true
  }

  export type DungeonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dungeon to aggregate.
     */
    where?: DungeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dungeons to fetch.
     */
    orderBy?: DungeonOrderByWithRelationInput | DungeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DungeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dungeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dungeons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dungeons
    **/
    _count?: true | DungeonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DungeonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DungeonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DungeonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DungeonMaxAggregateInputType
  }

  export type GetDungeonAggregateType<T extends DungeonAggregateArgs> = {
        [P in keyof T & keyof AggregateDungeon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDungeon[P]>
      : GetScalarType<T[P], AggregateDungeon[P]>
  }




  export type DungeonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DungeonWhereInput
    orderBy?: DungeonOrderByWithAggregationInput | DungeonOrderByWithAggregationInput[]
    by: DungeonScalarFieldEnum[] | DungeonScalarFieldEnum
    having?: DungeonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DungeonCountAggregateInputType | true
    _avg?: DungeonAvgAggregateInputType
    _sum?: DungeonSumAggregateInputType
    _min?: DungeonMinAggregateInputType
    _max?: DungeonMaxAggregateInputType
  }

  export type DungeonGroupByOutputType = {
    id: number
    name: string
    levelRequirement: number
    isRaid: boolean
    countryId: number
    cityId: number | null
    _count: DungeonCountAggregateOutputType | null
    _avg: DungeonAvgAggregateOutputType | null
    _sum: DungeonSumAggregateOutputType | null
    _min: DungeonMinAggregateOutputType | null
    _max: DungeonMaxAggregateOutputType | null
  }

  type GetDungeonGroupByPayload<T extends DungeonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DungeonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DungeonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DungeonGroupByOutputType[P]>
            : GetScalarType<T[P], DungeonGroupByOutputType[P]>
        }
      >
    >


  export type DungeonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    levelRequirement?: boolean
    isRaid?: boolean
    countryId?: boolean
    cityId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | Dungeon$cityArgs<ExtArgs>
  }, ExtArgs["result"]["dungeon"]>

  export type DungeonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    levelRequirement?: boolean
    isRaid?: boolean
    countryId?: boolean
    cityId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | Dungeon$cityArgs<ExtArgs>
  }, ExtArgs["result"]["dungeon"]>

  export type DungeonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    levelRequirement?: boolean
    isRaid?: boolean
    countryId?: boolean
    cityId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | Dungeon$cityArgs<ExtArgs>
  }, ExtArgs["result"]["dungeon"]>

  export type DungeonSelectScalar = {
    id?: boolean
    name?: boolean
    levelRequirement?: boolean
    isRaid?: boolean
    countryId?: boolean
    cityId?: boolean
  }

  export type DungeonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "levelRequirement" | "isRaid" | "countryId" | "cityId", ExtArgs["result"]["dungeon"]>
  export type DungeonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | Dungeon$cityArgs<ExtArgs>
  }
  export type DungeonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | Dungeon$cityArgs<ExtArgs>
  }
  export type DungeonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | Dungeon$cityArgs<ExtArgs>
  }

  export type $DungeonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dungeon"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      levelRequirement: number
      isRaid: boolean
      countryId: number
      cityId: number | null
    }, ExtArgs["result"]["dungeon"]>
    composites: {}
  }

  type DungeonGetPayload<S extends boolean | null | undefined | DungeonDefaultArgs> = $Result.GetResult<Prisma.$DungeonPayload, S>

  type DungeonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DungeonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DungeonCountAggregateInputType | true
    }

  export interface DungeonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dungeon'], meta: { name: 'Dungeon' } }
    /**
     * Find zero or one Dungeon that matches the filter.
     * @param {DungeonFindUniqueArgs} args - Arguments to find a Dungeon
     * @example
     * // Get one Dungeon
     * const dungeon = await prisma.dungeon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DungeonFindUniqueArgs>(args: SelectSubset<T, DungeonFindUniqueArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dungeon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DungeonFindUniqueOrThrowArgs} args - Arguments to find a Dungeon
     * @example
     * // Get one Dungeon
     * const dungeon = await prisma.dungeon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DungeonFindUniqueOrThrowArgs>(args: SelectSubset<T, DungeonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dungeon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonFindFirstArgs} args - Arguments to find a Dungeon
     * @example
     * // Get one Dungeon
     * const dungeon = await prisma.dungeon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DungeonFindFirstArgs>(args?: SelectSubset<T, DungeonFindFirstArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dungeon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonFindFirstOrThrowArgs} args - Arguments to find a Dungeon
     * @example
     * // Get one Dungeon
     * const dungeon = await prisma.dungeon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DungeonFindFirstOrThrowArgs>(args?: SelectSubset<T, DungeonFindFirstOrThrowArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dungeons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dungeons
     * const dungeons = await prisma.dungeon.findMany()
     * 
     * // Get first 10 Dungeons
     * const dungeons = await prisma.dungeon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dungeonWithIdOnly = await prisma.dungeon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DungeonFindManyArgs>(args?: SelectSubset<T, DungeonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dungeon.
     * @param {DungeonCreateArgs} args - Arguments to create a Dungeon.
     * @example
     * // Create one Dungeon
     * const Dungeon = await prisma.dungeon.create({
     *   data: {
     *     // ... data to create a Dungeon
     *   }
     * })
     * 
     */
    create<T extends DungeonCreateArgs>(args: SelectSubset<T, DungeonCreateArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dungeons.
     * @param {DungeonCreateManyArgs} args - Arguments to create many Dungeons.
     * @example
     * // Create many Dungeons
     * const dungeon = await prisma.dungeon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DungeonCreateManyArgs>(args?: SelectSubset<T, DungeonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dungeons and returns the data saved in the database.
     * @param {DungeonCreateManyAndReturnArgs} args - Arguments to create many Dungeons.
     * @example
     * // Create many Dungeons
     * const dungeon = await prisma.dungeon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dungeons and only return the `id`
     * const dungeonWithIdOnly = await prisma.dungeon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DungeonCreateManyAndReturnArgs>(args?: SelectSubset<T, DungeonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dungeon.
     * @param {DungeonDeleteArgs} args - Arguments to delete one Dungeon.
     * @example
     * // Delete one Dungeon
     * const Dungeon = await prisma.dungeon.delete({
     *   where: {
     *     // ... filter to delete one Dungeon
     *   }
     * })
     * 
     */
    delete<T extends DungeonDeleteArgs>(args: SelectSubset<T, DungeonDeleteArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dungeon.
     * @param {DungeonUpdateArgs} args - Arguments to update one Dungeon.
     * @example
     * // Update one Dungeon
     * const dungeon = await prisma.dungeon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DungeonUpdateArgs>(args: SelectSubset<T, DungeonUpdateArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dungeons.
     * @param {DungeonDeleteManyArgs} args - Arguments to filter Dungeons to delete.
     * @example
     * // Delete a few Dungeons
     * const { count } = await prisma.dungeon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DungeonDeleteManyArgs>(args?: SelectSubset<T, DungeonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dungeons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dungeons
     * const dungeon = await prisma.dungeon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DungeonUpdateManyArgs>(args: SelectSubset<T, DungeonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dungeons and returns the data updated in the database.
     * @param {DungeonUpdateManyAndReturnArgs} args - Arguments to update many Dungeons.
     * @example
     * // Update many Dungeons
     * const dungeon = await prisma.dungeon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dungeons and only return the `id`
     * const dungeonWithIdOnly = await prisma.dungeon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DungeonUpdateManyAndReturnArgs>(args: SelectSubset<T, DungeonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dungeon.
     * @param {DungeonUpsertArgs} args - Arguments to update or create a Dungeon.
     * @example
     * // Update or create a Dungeon
     * const dungeon = await prisma.dungeon.upsert({
     *   create: {
     *     // ... data to create a Dungeon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dungeon we want to update
     *   }
     * })
     */
    upsert<T extends DungeonUpsertArgs>(args: SelectSubset<T, DungeonUpsertArgs<ExtArgs>>): Prisma__DungeonClient<$Result.GetResult<Prisma.$DungeonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dungeons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonCountArgs} args - Arguments to filter Dungeons to count.
     * @example
     * // Count the number of Dungeons
     * const count = await prisma.dungeon.count({
     *   where: {
     *     // ... the filter for the Dungeons we want to count
     *   }
     * })
    **/
    count<T extends DungeonCountArgs>(
      args?: Subset<T, DungeonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DungeonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dungeon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DungeonAggregateArgs>(args: Subset<T, DungeonAggregateArgs>): Prisma.PrismaPromise<GetDungeonAggregateType<T>>

    /**
     * Group by Dungeon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DungeonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DungeonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DungeonGroupByArgs['orderBy'] }
        : { orderBy?: DungeonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DungeonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDungeonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dungeon model
   */
  readonly fields: DungeonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dungeon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DungeonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends Dungeon$cityArgs<ExtArgs> = {}>(args?: Subset<T, Dungeon$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dungeon model
   */
  interface DungeonFieldRefs {
    readonly id: FieldRef<"Dungeon", 'Int'>
    readonly name: FieldRef<"Dungeon", 'String'>
    readonly levelRequirement: FieldRef<"Dungeon", 'Int'>
    readonly isRaid: FieldRef<"Dungeon", 'Boolean'>
    readonly countryId: FieldRef<"Dungeon", 'Int'>
    readonly cityId: FieldRef<"Dungeon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Dungeon findUnique
   */
  export type DungeonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * Filter, which Dungeon to fetch.
     */
    where: DungeonWhereUniqueInput
  }

  /**
   * Dungeon findUniqueOrThrow
   */
  export type DungeonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * Filter, which Dungeon to fetch.
     */
    where: DungeonWhereUniqueInput
  }

  /**
   * Dungeon findFirst
   */
  export type DungeonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * Filter, which Dungeon to fetch.
     */
    where?: DungeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dungeons to fetch.
     */
    orderBy?: DungeonOrderByWithRelationInput | DungeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dungeons.
     */
    cursor?: DungeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dungeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dungeons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dungeons.
     */
    distinct?: DungeonScalarFieldEnum | DungeonScalarFieldEnum[]
  }

  /**
   * Dungeon findFirstOrThrow
   */
  export type DungeonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * Filter, which Dungeon to fetch.
     */
    where?: DungeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dungeons to fetch.
     */
    orderBy?: DungeonOrderByWithRelationInput | DungeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dungeons.
     */
    cursor?: DungeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dungeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dungeons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dungeons.
     */
    distinct?: DungeonScalarFieldEnum | DungeonScalarFieldEnum[]
  }

  /**
   * Dungeon findMany
   */
  export type DungeonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * Filter, which Dungeons to fetch.
     */
    where?: DungeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dungeons to fetch.
     */
    orderBy?: DungeonOrderByWithRelationInput | DungeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dungeons.
     */
    cursor?: DungeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dungeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dungeons.
     */
    skip?: number
    distinct?: DungeonScalarFieldEnum | DungeonScalarFieldEnum[]
  }

  /**
   * Dungeon create
   */
  export type DungeonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * The data needed to create a Dungeon.
     */
    data: XOR<DungeonCreateInput, DungeonUncheckedCreateInput>
  }

  /**
   * Dungeon createMany
   */
  export type DungeonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dungeons.
     */
    data: DungeonCreateManyInput | DungeonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dungeon createManyAndReturn
   */
  export type DungeonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * The data used to create many Dungeons.
     */
    data: DungeonCreateManyInput | DungeonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dungeon update
   */
  export type DungeonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * The data needed to update a Dungeon.
     */
    data: XOR<DungeonUpdateInput, DungeonUncheckedUpdateInput>
    /**
     * Choose, which Dungeon to update.
     */
    where: DungeonWhereUniqueInput
  }

  /**
   * Dungeon updateMany
   */
  export type DungeonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dungeons.
     */
    data: XOR<DungeonUpdateManyMutationInput, DungeonUncheckedUpdateManyInput>
    /**
     * Filter which Dungeons to update
     */
    where?: DungeonWhereInput
    /**
     * Limit how many Dungeons to update.
     */
    limit?: number
  }

  /**
   * Dungeon updateManyAndReturn
   */
  export type DungeonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * The data used to update Dungeons.
     */
    data: XOR<DungeonUpdateManyMutationInput, DungeonUncheckedUpdateManyInput>
    /**
     * Filter which Dungeons to update
     */
    where?: DungeonWhereInput
    /**
     * Limit how many Dungeons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dungeon upsert
   */
  export type DungeonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * The filter to search for the Dungeon to update in case it exists.
     */
    where: DungeonWhereUniqueInput
    /**
     * In case the Dungeon found by the `where` argument doesn't exist, create a new Dungeon with this data.
     */
    create: XOR<DungeonCreateInput, DungeonUncheckedCreateInput>
    /**
     * In case the Dungeon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DungeonUpdateInput, DungeonUncheckedUpdateInput>
  }

  /**
   * Dungeon delete
   */
  export type DungeonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
    /**
     * Filter which Dungeon to delete.
     */
    where: DungeonWhereUniqueInput
  }

  /**
   * Dungeon deleteMany
   */
  export type DungeonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dungeons to delete
     */
    where?: DungeonWhereInput
    /**
     * Limit how many Dungeons to delete.
     */
    limit?: number
  }

  /**
   * Dungeon.city
   */
  export type Dungeon$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * Dungeon without action
   */
  export type DungeonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dungeon
     */
    select?: DungeonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dungeon
     */
    omit?: DungeonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DungeonInclude<ExtArgs> | null
  }


  /**
   * Model Quest
   */

  export type AggregateQuest = {
    _count: QuestCountAggregateOutputType | null
    _avg: QuestAvgAggregateOutputType | null
    _sum: QuestSumAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  export type QuestAvgAggregateOutputType = {
    id: number | null
    reputationRequired: number | null
    issuerId: number | null
    takerId: number | null
    bountyTargetId: number | null
  }

  export type QuestSumAggregateOutputType = {
    id: number | null
    reputationRequired: number | null
    issuerId: number | null
    takerId: number | null
    bountyTargetId: number | null
  }

  export type QuestMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isTaken: boolean | null
    takenAt: Date | null
    completedAt: Date | null
    reputationRequired: number | null
    notorietyTrigger: boolean | null
    issuerId: number | null
    takerId: number | null
    bountyTargetId: number | null
  }

  export type QuestMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isTaken: boolean | null
    takenAt: Date | null
    completedAt: Date | null
    reputationRequired: number | null
    notorietyTrigger: boolean | null
    issuerId: number | null
    takerId: number | null
    bountyTargetId: number | null
  }

  export type QuestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    isTaken: number
    takenAt: number
    completedAt: number
    reputationRequired: number
    notorietyTrigger: number
    issuerId: number
    takerId: number
    bountyTargetId: number
    metadata: number
    _all: number
  }


  export type QuestAvgAggregateInputType = {
    id?: true
    reputationRequired?: true
    issuerId?: true
    takerId?: true
    bountyTargetId?: true
  }

  export type QuestSumAggregateInputType = {
    id?: true
    reputationRequired?: true
    issuerId?: true
    takerId?: true
    bountyTargetId?: true
  }

  export type QuestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isTaken?: true
    takenAt?: true
    completedAt?: true
    reputationRequired?: true
    notorietyTrigger?: true
    issuerId?: true
    takerId?: true
    bountyTargetId?: true
  }

  export type QuestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isTaken?: true
    takenAt?: true
    completedAt?: true
    reputationRequired?: true
    notorietyTrigger?: true
    issuerId?: true
    takerId?: true
    bountyTargetId?: true
  }

  export type QuestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isTaken?: true
    takenAt?: true
    completedAt?: true
    reputationRequired?: true
    notorietyTrigger?: true
    issuerId?: true
    takerId?: true
    bountyTargetId?: true
    metadata?: true
    _all?: true
  }

  export type QuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quest to aggregate.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestMaxAggregateInputType
  }

  export type GetQuestAggregateType<T extends QuestAggregateArgs> = {
        [P in keyof T & keyof AggregateQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuest[P]>
      : GetScalarType<T[P], AggregateQuest[P]>
  }




  export type QuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithAggregationInput | QuestOrderByWithAggregationInput[]
    by: QuestScalarFieldEnum[] | QuestScalarFieldEnum
    having?: QuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestCountAggregateInputType | true
    _avg?: QuestAvgAggregateInputType
    _sum?: QuestSumAggregateInputType
    _min?: QuestMinAggregateInputType
    _max?: QuestMaxAggregateInputType
  }

  export type QuestGroupByOutputType = {
    id: number
    title: string
    description: string
    isTaken: boolean
    takenAt: Date | null
    completedAt: Date | null
    reputationRequired: number
    notorietyTrigger: boolean
    issuerId: number | null
    takerId: number | null
    bountyTargetId: number | null
    metadata: JsonValue | null
    _count: QuestCountAggregateOutputType | null
    _avg: QuestAvgAggregateOutputType | null
    _sum: QuestSumAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  type GetQuestGroupByPayload<T extends QuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestGroupByOutputType[P]>
            : GetScalarType<T[P], QuestGroupByOutputType[P]>
        }
      >
    >


  export type QuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isTaken?: boolean
    takenAt?: boolean
    completedAt?: boolean
    reputationRequired?: boolean
    notorietyTrigger?: boolean
    issuerId?: boolean
    takerId?: boolean
    bountyTargetId?: boolean
    metadata?: boolean
    issuer?: boolean | Quest$issuerArgs<ExtArgs>
    taker?: boolean | Quest$takerArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isTaken?: boolean
    takenAt?: boolean
    completedAt?: boolean
    reputationRequired?: boolean
    notorietyTrigger?: boolean
    issuerId?: boolean
    takerId?: boolean
    bountyTargetId?: boolean
    metadata?: boolean
    issuer?: boolean | Quest$issuerArgs<ExtArgs>
    taker?: boolean | Quest$takerArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isTaken?: boolean
    takenAt?: boolean
    completedAt?: boolean
    reputationRequired?: boolean
    notorietyTrigger?: boolean
    issuerId?: boolean
    takerId?: boolean
    bountyTargetId?: boolean
    metadata?: boolean
    issuer?: boolean | Quest$issuerArgs<ExtArgs>
    taker?: boolean | Quest$takerArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    isTaken?: boolean
    takenAt?: boolean
    completedAt?: boolean
    reputationRequired?: boolean
    notorietyTrigger?: boolean
    issuerId?: boolean
    takerId?: boolean
    bountyTargetId?: boolean
    metadata?: boolean
  }

  export type QuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "isTaken" | "takenAt" | "completedAt" | "reputationRequired" | "notorietyTrigger" | "issuerId" | "takerId" | "bountyTargetId" | "metadata", ExtArgs["result"]["quest"]>
  export type QuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | Quest$issuerArgs<ExtArgs>
    taker?: boolean | Quest$takerArgs<ExtArgs>
  }
  export type QuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | Quest$issuerArgs<ExtArgs>
    taker?: boolean | Quest$takerArgs<ExtArgs>
  }
  export type QuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | Quest$issuerArgs<ExtArgs>
    taker?: boolean | Quest$takerArgs<ExtArgs>
  }

  export type $QuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quest"
    objects: {
      issuer: Prisma.$NPCPayload<ExtArgs> | null
      taker: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      isTaken: boolean
      takenAt: Date | null
      completedAt: Date | null
      reputationRequired: number
      notorietyTrigger: boolean
      issuerId: number | null
      takerId: number | null
      bountyTargetId: number | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["quest"]>
    composites: {}
  }

  type QuestGetPayload<S extends boolean | null | undefined | QuestDefaultArgs> = $Result.GetResult<Prisma.$QuestPayload, S>

  type QuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestCountAggregateInputType | true
    }

  export interface QuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quest'], meta: { name: 'Quest' } }
    /**
     * Find zero or one Quest that matches the filter.
     * @param {QuestFindUniqueArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestFindUniqueArgs>(args: SelectSubset<T, QuestFindUniqueArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestFindUniqueOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestFindFirstArgs>(args?: SelectSubset<T, QuestFindFirstArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quest.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questWithIdOnly = await prisma.quest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestFindManyArgs>(args?: SelectSubset<T, QuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quest.
     * @param {QuestCreateArgs} args - Arguments to create a Quest.
     * @example
     * // Create one Quest
     * const Quest = await prisma.quest.create({
     *   data: {
     *     // ... data to create a Quest
     *   }
     * })
     * 
     */
    create<T extends QuestCreateArgs>(args: SelectSubset<T, QuestCreateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quests.
     * @param {QuestCreateManyArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestCreateManyArgs>(args?: SelectSubset<T, QuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quests and returns the data saved in the database.
     * @param {QuestCreateManyAndReturnArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quest.
     * @param {QuestDeleteArgs} args - Arguments to delete one Quest.
     * @example
     * // Delete one Quest
     * const Quest = await prisma.quest.delete({
     *   where: {
     *     // ... filter to delete one Quest
     *   }
     * })
     * 
     */
    delete<T extends QuestDeleteArgs>(args: SelectSubset<T, QuestDeleteArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quest.
     * @param {QuestUpdateArgs} args - Arguments to update one Quest.
     * @example
     * // Update one Quest
     * const quest = await prisma.quest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestUpdateArgs>(args: SelectSubset<T, QuestUpdateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quests.
     * @param {QuestDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestDeleteManyArgs>(args?: SelectSubset<T, QuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestUpdateManyArgs>(args: SelectSubset<T, QuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests and returns the data updated in the database.
     * @param {QuestUpdateManyAndReturnArgs} args - Arguments to update many Quests.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quest.
     * @param {QuestUpsertArgs} args - Arguments to update or create a Quest.
     * @example
     * // Update or create a Quest
     * const quest = await prisma.quest.upsert({
     *   create: {
     *     // ... data to create a Quest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quest we want to update
     *   }
     * })
     */
    upsert<T extends QuestUpsertArgs>(args: SelectSubset<T, QuestUpsertArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quest.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestCountArgs>(
      args?: Subset<T, QuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestAggregateArgs>(args: Subset<T, QuestAggregateArgs>): Prisma.PrismaPromise<GetQuestAggregateType<T>>

    /**
     * Group by Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestGroupByArgs['orderBy'] }
        : { orderBy?: QuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quest model
   */
  readonly fields: QuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issuer<T extends Quest$issuerArgs<ExtArgs> = {}>(args?: Subset<T, Quest$issuerArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    taker<T extends Quest$takerArgs<ExtArgs> = {}>(args?: Subset<T, Quest$takerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quest model
   */
  interface QuestFieldRefs {
    readonly id: FieldRef<"Quest", 'Int'>
    readonly title: FieldRef<"Quest", 'String'>
    readonly description: FieldRef<"Quest", 'String'>
    readonly isTaken: FieldRef<"Quest", 'Boolean'>
    readonly takenAt: FieldRef<"Quest", 'DateTime'>
    readonly completedAt: FieldRef<"Quest", 'DateTime'>
    readonly reputationRequired: FieldRef<"Quest", 'Int'>
    readonly notorietyTrigger: FieldRef<"Quest", 'Boolean'>
    readonly issuerId: FieldRef<"Quest", 'Int'>
    readonly takerId: FieldRef<"Quest", 'Int'>
    readonly bountyTargetId: FieldRef<"Quest", 'Int'>
    readonly metadata: FieldRef<"Quest", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Quest findUnique
   */
  export type QuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findUniqueOrThrow
   */
  export type QuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findFirst
   */
  export type QuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findFirstOrThrow
   */
  export type QuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findMany
   */
  export type QuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest create
   */
  export type QuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Quest.
     */
    data: XOR<QuestCreateInput, QuestUncheckedCreateInput>
  }

  /**
   * Quest createMany
   */
  export type QuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quest createManyAndReturn
   */
  export type QuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quest update
   */
  export type QuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Quest.
     */
    data: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
    /**
     * Choose, which Quest to update.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest updateMany
   */
  export type QuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to update.
     */
    limit?: number
  }

  /**
   * Quest updateManyAndReturn
   */
  export type QuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quest upsert
   */
  export type QuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Quest to update in case it exists.
     */
    where: QuestWhereUniqueInput
    /**
     * In case the Quest found by the `where` argument doesn't exist, create a new Quest with this data.
     */
    create: XOR<QuestCreateInput, QuestUncheckedCreateInput>
    /**
     * In case the Quest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
  }

  /**
   * Quest delete
   */
  export type QuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter which Quest to delete.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest deleteMany
   */
  export type QuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to delete.
     */
    limit?: number
  }

  /**
   * Quest.issuer
   */
  export type Quest$issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
  }

  /**
   * Quest.taker
   */
  export type Quest$takerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Quest without action
   */
  export type QuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
  }


  /**
   * Model PlayerProfession
   */

  export type AggregatePlayerProfession = {
    _count: PlayerProfessionCountAggregateOutputType | null
    _avg: PlayerProfessionAvgAggregateOutputType | null
    _sum: PlayerProfessionSumAggregateOutputType | null
    _min: PlayerProfessionMinAggregateOutputType | null
    _max: PlayerProfessionMaxAggregateOutputType | null
  }

  export type PlayerProfessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    skillLevel: number | null
    experience: number | null
  }

  export type PlayerProfessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    skillLevel: number | null
    experience: number | null
  }

  export type PlayerProfessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    skillLevel: number | null
    experience: number | null
  }

  export type PlayerProfessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    skillLevel: number | null
    experience: number | null
  }

  export type PlayerProfessionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    skillLevel: number
    experience: number
    _all: number
  }


  export type PlayerProfessionAvgAggregateInputType = {
    id?: true
    userId?: true
    skillLevel?: true
    experience?: true
  }

  export type PlayerProfessionSumAggregateInputType = {
    id?: true
    userId?: true
    skillLevel?: true
    experience?: true
  }

  export type PlayerProfessionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    skillLevel?: true
    experience?: true
  }

  export type PlayerProfessionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    skillLevel?: true
    experience?: true
  }

  export type PlayerProfessionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    skillLevel?: true
    experience?: true
    _all?: true
  }

  export type PlayerProfessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerProfession to aggregate.
     */
    where?: PlayerProfessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfessions to fetch.
     */
    orderBy?: PlayerProfessionOrderByWithRelationInput | PlayerProfessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerProfessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerProfessions
    **/
    _count?: true | PlayerProfessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerProfessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerProfessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerProfessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerProfessionMaxAggregateInputType
  }

  export type GetPlayerProfessionAggregateType<T extends PlayerProfessionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerProfession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerProfession[P]>
      : GetScalarType<T[P], AggregatePlayerProfession[P]>
  }




  export type PlayerProfessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerProfessionWhereInput
    orderBy?: PlayerProfessionOrderByWithAggregationInput | PlayerProfessionOrderByWithAggregationInput[]
    by: PlayerProfessionScalarFieldEnum[] | PlayerProfessionScalarFieldEnum
    having?: PlayerProfessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerProfessionCountAggregateInputType | true
    _avg?: PlayerProfessionAvgAggregateInputType
    _sum?: PlayerProfessionSumAggregateInputType
    _min?: PlayerProfessionMinAggregateInputType
    _max?: PlayerProfessionMaxAggregateInputType
  }

  export type PlayerProfessionGroupByOutputType = {
    id: number
    userId: number
    type: string
    skillLevel: number
    experience: number
    _count: PlayerProfessionCountAggregateOutputType | null
    _avg: PlayerProfessionAvgAggregateOutputType | null
    _sum: PlayerProfessionSumAggregateOutputType | null
    _min: PlayerProfessionMinAggregateOutputType | null
    _max: PlayerProfessionMaxAggregateOutputType | null
  }

  type GetPlayerProfessionGroupByPayload<T extends PlayerProfessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerProfessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerProfessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerProfessionGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerProfessionGroupByOutputType[P]>
        }
      >
    >


  export type PlayerProfessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    skillLevel?: boolean
    experience?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerProfession"]>

  export type PlayerProfessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    skillLevel?: boolean
    experience?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerProfession"]>

  export type PlayerProfessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    skillLevel?: boolean
    experience?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerProfession"]>

  export type PlayerProfessionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    skillLevel?: boolean
    experience?: boolean
  }

  export type PlayerProfessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "skillLevel" | "experience", ExtArgs["result"]["playerProfession"]>
  export type PlayerProfessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerProfessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerProfessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlayerProfessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerProfession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      skillLevel: number
      experience: number
    }, ExtArgs["result"]["playerProfession"]>
    composites: {}
  }

  type PlayerProfessionGetPayload<S extends boolean | null | undefined | PlayerProfessionDefaultArgs> = $Result.GetResult<Prisma.$PlayerProfessionPayload, S>

  type PlayerProfessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerProfessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerProfessionCountAggregateInputType | true
    }

  export interface PlayerProfessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerProfession'], meta: { name: 'PlayerProfession' } }
    /**
     * Find zero or one PlayerProfession that matches the filter.
     * @param {PlayerProfessionFindUniqueArgs} args - Arguments to find a PlayerProfession
     * @example
     * // Get one PlayerProfession
     * const playerProfession = await prisma.playerProfession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerProfessionFindUniqueArgs>(args: SelectSubset<T, PlayerProfessionFindUniqueArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerProfession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerProfessionFindUniqueOrThrowArgs} args - Arguments to find a PlayerProfession
     * @example
     * // Get one PlayerProfession
     * const playerProfession = await prisma.playerProfession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerProfessionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerProfessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerProfession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionFindFirstArgs} args - Arguments to find a PlayerProfession
     * @example
     * // Get one PlayerProfession
     * const playerProfession = await prisma.playerProfession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerProfessionFindFirstArgs>(args?: SelectSubset<T, PlayerProfessionFindFirstArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerProfession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionFindFirstOrThrowArgs} args - Arguments to find a PlayerProfession
     * @example
     * // Get one PlayerProfession
     * const playerProfession = await prisma.playerProfession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerProfessionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerProfessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerProfessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerProfessions
     * const playerProfessions = await prisma.playerProfession.findMany()
     * 
     * // Get first 10 PlayerProfessions
     * const playerProfessions = await prisma.playerProfession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerProfessionWithIdOnly = await prisma.playerProfession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerProfessionFindManyArgs>(args?: SelectSubset<T, PlayerProfessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerProfession.
     * @param {PlayerProfessionCreateArgs} args - Arguments to create a PlayerProfession.
     * @example
     * // Create one PlayerProfession
     * const PlayerProfession = await prisma.playerProfession.create({
     *   data: {
     *     // ... data to create a PlayerProfession
     *   }
     * })
     * 
     */
    create<T extends PlayerProfessionCreateArgs>(args: SelectSubset<T, PlayerProfessionCreateArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerProfessions.
     * @param {PlayerProfessionCreateManyArgs} args - Arguments to create many PlayerProfessions.
     * @example
     * // Create many PlayerProfessions
     * const playerProfession = await prisma.playerProfession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerProfessionCreateManyArgs>(args?: SelectSubset<T, PlayerProfessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerProfessions and returns the data saved in the database.
     * @param {PlayerProfessionCreateManyAndReturnArgs} args - Arguments to create many PlayerProfessions.
     * @example
     * // Create many PlayerProfessions
     * const playerProfession = await prisma.playerProfession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerProfessions and only return the `id`
     * const playerProfessionWithIdOnly = await prisma.playerProfession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerProfessionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerProfessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerProfession.
     * @param {PlayerProfessionDeleteArgs} args - Arguments to delete one PlayerProfession.
     * @example
     * // Delete one PlayerProfession
     * const PlayerProfession = await prisma.playerProfession.delete({
     *   where: {
     *     // ... filter to delete one PlayerProfession
     *   }
     * })
     * 
     */
    delete<T extends PlayerProfessionDeleteArgs>(args: SelectSubset<T, PlayerProfessionDeleteArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerProfession.
     * @param {PlayerProfessionUpdateArgs} args - Arguments to update one PlayerProfession.
     * @example
     * // Update one PlayerProfession
     * const playerProfession = await prisma.playerProfession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerProfessionUpdateArgs>(args: SelectSubset<T, PlayerProfessionUpdateArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerProfessions.
     * @param {PlayerProfessionDeleteManyArgs} args - Arguments to filter PlayerProfessions to delete.
     * @example
     * // Delete a few PlayerProfessions
     * const { count } = await prisma.playerProfession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerProfessionDeleteManyArgs>(args?: SelectSubset<T, PlayerProfessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerProfessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerProfessions
     * const playerProfession = await prisma.playerProfession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerProfessionUpdateManyArgs>(args: SelectSubset<T, PlayerProfessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerProfessions and returns the data updated in the database.
     * @param {PlayerProfessionUpdateManyAndReturnArgs} args - Arguments to update many PlayerProfessions.
     * @example
     * // Update many PlayerProfessions
     * const playerProfession = await prisma.playerProfession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerProfessions and only return the `id`
     * const playerProfessionWithIdOnly = await prisma.playerProfession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerProfessionUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerProfessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerProfession.
     * @param {PlayerProfessionUpsertArgs} args - Arguments to update or create a PlayerProfession.
     * @example
     * // Update or create a PlayerProfession
     * const playerProfession = await prisma.playerProfession.upsert({
     *   create: {
     *     // ... data to create a PlayerProfession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerProfession we want to update
     *   }
     * })
     */
    upsert<T extends PlayerProfessionUpsertArgs>(args: SelectSubset<T, PlayerProfessionUpsertArgs<ExtArgs>>): Prisma__PlayerProfessionClient<$Result.GetResult<Prisma.$PlayerProfessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerProfessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionCountArgs} args - Arguments to filter PlayerProfessions to count.
     * @example
     * // Count the number of PlayerProfessions
     * const count = await prisma.playerProfession.count({
     *   where: {
     *     // ... the filter for the PlayerProfessions we want to count
     *   }
     * })
    **/
    count<T extends PlayerProfessionCountArgs>(
      args?: Subset<T, PlayerProfessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerProfessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerProfession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerProfessionAggregateArgs>(args: Subset<T, PlayerProfessionAggregateArgs>): Prisma.PrismaPromise<GetPlayerProfessionAggregateType<T>>

    /**
     * Group by PlayerProfession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerProfessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerProfessionGroupByArgs['orderBy'] }
        : { orderBy?: PlayerProfessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerProfessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerProfessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerProfession model
   */
  readonly fields: PlayerProfessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerProfession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerProfessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerProfession model
   */
  interface PlayerProfessionFieldRefs {
    readonly id: FieldRef<"PlayerProfession", 'Int'>
    readonly userId: FieldRef<"PlayerProfession", 'Int'>
    readonly type: FieldRef<"PlayerProfession", 'String'>
    readonly skillLevel: FieldRef<"PlayerProfession", 'Int'>
    readonly experience: FieldRef<"PlayerProfession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlayerProfession findUnique
   */
  export type PlayerProfessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProfession to fetch.
     */
    where: PlayerProfessionWhereUniqueInput
  }

  /**
   * PlayerProfession findUniqueOrThrow
   */
  export type PlayerProfessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProfession to fetch.
     */
    where: PlayerProfessionWhereUniqueInput
  }

  /**
   * PlayerProfession findFirst
   */
  export type PlayerProfessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProfession to fetch.
     */
    where?: PlayerProfessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfessions to fetch.
     */
    orderBy?: PlayerProfessionOrderByWithRelationInput | PlayerProfessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerProfessions.
     */
    cursor?: PlayerProfessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerProfessions.
     */
    distinct?: PlayerProfessionScalarFieldEnum | PlayerProfessionScalarFieldEnum[]
  }

  /**
   * PlayerProfession findFirstOrThrow
   */
  export type PlayerProfessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProfession to fetch.
     */
    where?: PlayerProfessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfessions to fetch.
     */
    orderBy?: PlayerProfessionOrderByWithRelationInput | PlayerProfessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerProfessions.
     */
    cursor?: PlayerProfessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerProfessions.
     */
    distinct?: PlayerProfessionScalarFieldEnum | PlayerProfessionScalarFieldEnum[]
  }

  /**
   * PlayerProfession findMany
   */
  export type PlayerProfessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProfessions to fetch.
     */
    where?: PlayerProfessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfessions to fetch.
     */
    orderBy?: PlayerProfessionOrderByWithRelationInput | PlayerProfessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerProfessions.
     */
    cursor?: PlayerProfessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfessions.
     */
    skip?: number
    distinct?: PlayerProfessionScalarFieldEnum | PlayerProfessionScalarFieldEnum[]
  }

  /**
   * PlayerProfession create
   */
  export type PlayerProfessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerProfession.
     */
    data: XOR<PlayerProfessionCreateInput, PlayerProfessionUncheckedCreateInput>
  }

  /**
   * PlayerProfession createMany
   */
  export type PlayerProfessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerProfessions.
     */
    data: PlayerProfessionCreateManyInput | PlayerProfessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerProfession createManyAndReturn
   */
  export type PlayerProfessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerProfessions.
     */
    data: PlayerProfessionCreateManyInput | PlayerProfessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerProfession update
   */
  export type PlayerProfessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerProfession.
     */
    data: XOR<PlayerProfessionUpdateInput, PlayerProfessionUncheckedUpdateInput>
    /**
     * Choose, which PlayerProfession to update.
     */
    where: PlayerProfessionWhereUniqueInput
  }

  /**
   * PlayerProfession updateMany
   */
  export type PlayerProfessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerProfessions.
     */
    data: XOR<PlayerProfessionUpdateManyMutationInput, PlayerProfessionUncheckedUpdateManyInput>
    /**
     * Filter which PlayerProfessions to update
     */
    where?: PlayerProfessionWhereInput
    /**
     * Limit how many PlayerProfessions to update.
     */
    limit?: number
  }

  /**
   * PlayerProfession updateManyAndReturn
   */
  export type PlayerProfessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * The data used to update PlayerProfessions.
     */
    data: XOR<PlayerProfessionUpdateManyMutationInput, PlayerProfessionUncheckedUpdateManyInput>
    /**
     * Filter which PlayerProfessions to update
     */
    where?: PlayerProfessionWhereInput
    /**
     * Limit how many PlayerProfessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerProfession upsert
   */
  export type PlayerProfessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerProfession to update in case it exists.
     */
    where: PlayerProfessionWhereUniqueInput
    /**
     * In case the PlayerProfession found by the `where` argument doesn't exist, create a new PlayerProfession with this data.
     */
    create: XOR<PlayerProfessionCreateInput, PlayerProfessionUncheckedCreateInput>
    /**
     * In case the PlayerProfession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerProfessionUpdateInput, PlayerProfessionUncheckedUpdateInput>
  }

  /**
   * PlayerProfession delete
   */
  export type PlayerProfessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
    /**
     * Filter which PlayerProfession to delete.
     */
    where: PlayerProfessionWhereUniqueInput
  }

  /**
   * PlayerProfession deleteMany
   */
  export type PlayerProfessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerProfessions to delete
     */
    where?: PlayerProfessionWhereInput
    /**
     * Limit how many PlayerProfessions to delete.
     */
    limit?: number
  }

  /**
   * PlayerProfession without action
   */
  export type PlayerProfessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfession
     */
    select?: PlayerProfessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfession
     */
    omit?: PlayerProfessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProfessionInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    quality: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    quality: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    quality: number | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    quality: number | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    quality: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    quality?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    quality?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    quality?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    quality?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    quality?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    name: string
    quality: number
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quality?: boolean
    instances?: boolean | Item$instancesArgs<ExtArgs>
    recipesAsProduct?: boolean | Item$recipesAsProductArgs<ExtArgs>
    recipeMaterials?: boolean | Item$recipeMaterialsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quality?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quality?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    quality?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "quality", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | Item$instancesArgs<ExtArgs>
    recipesAsProduct?: boolean | Item$recipesAsProductArgs<ExtArgs>
    recipeMaterials?: boolean | Item$recipeMaterialsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      instances: Prisma.$ItemInstancePayload<ExtArgs>[]
      recipesAsProduct: Prisma.$RecipePayload<ExtArgs>[]
      recipeMaterials: Prisma.$RecipeMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      quality: number
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instances<T extends Item$instancesArgs<ExtArgs> = {}>(args?: Subset<T, Item$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recipesAsProduct<T extends Item$recipesAsProductArgs<ExtArgs> = {}>(args?: Subset<T, Item$recipesAsProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recipeMaterials<T extends Item$recipeMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, Item$recipeMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly name: FieldRef<"Item", 'String'>
    readonly quality: FieldRef<"Item", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.instances
   */
  export type Item$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    where?: ItemInstanceWhereInput
    orderBy?: ItemInstanceOrderByWithRelationInput | ItemInstanceOrderByWithRelationInput[]
    cursor?: ItemInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemInstanceScalarFieldEnum | ItemInstanceScalarFieldEnum[]
  }

  /**
   * Item.recipesAsProduct
   */
  export type Item$recipesAsProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Item.recipeMaterials
   */
  export type Item$recipeMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    where?: RecipeMaterialWhereInput
    orderBy?: RecipeMaterialOrderByWithRelationInput | RecipeMaterialOrderByWithRelationInput[]
    cursor?: RecipeMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeMaterialScalarFieldEnum | RecipeMaterialScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model ItemInstance
   */

  export type AggregateItemInstance = {
    _count: ItemInstanceCountAggregateOutputType | null
    _avg: ItemInstanceAvgAggregateOutputType | null
    _sum: ItemInstanceSumAggregateOutputType | null
    _min: ItemInstanceMinAggregateOutputType | null
    _max: ItemInstanceMaxAggregateOutputType | null
  }

  export type ItemInstanceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type ItemInstanceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type ItemInstanceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type ItemInstanceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type ItemInstanceCountAggregateOutputType = {
    id: number
    userId: number
    itemId: number
    quantity: number
    _all: number
  }


  export type ItemInstanceAvgAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
  }

  export type ItemInstanceSumAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
  }

  export type ItemInstanceMinAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
  }

  export type ItemInstanceMaxAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
  }

  export type ItemInstanceCountAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
    _all?: true
  }

  export type ItemInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemInstance to aggregate.
     */
    where?: ItemInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemInstances to fetch.
     */
    orderBy?: ItemInstanceOrderByWithRelationInput | ItemInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemInstances
    **/
    _count?: true | ItemInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemInstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemInstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemInstanceMaxAggregateInputType
  }

  export type GetItemInstanceAggregateType<T extends ItemInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateItemInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemInstance[P]>
      : GetScalarType<T[P], AggregateItemInstance[P]>
  }




  export type ItemInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemInstanceWhereInput
    orderBy?: ItemInstanceOrderByWithAggregationInput | ItemInstanceOrderByWithAggregationInput[]
    by: ItemInstanceScalarFieldEnum[] | ItemInstanceScalarFieldEnum
    having?: ItemInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemInstanceCountAggregateInputType | true
    _avg?: ItemInstanceAvgAggregateInputType
    _sum?: ItemInstanceSumAggregateInputType
    _min?: ItemInstanceMinAggregateInputType
    _max?: ItemInstanceMaxAggregateInputType
  }

  export type ItemInstanceGroupByOutputType = {
    id: number
    userId: number
    itemId: number
    quantity: number
    _count: ItemInstanceCountAggregateOutputType | null
    _avg: ItemInstanceAvgAggregateOutputType | null
    _sum: ItemInstanceSumAggregateOutputType | null
    _min: ItemInstanceMinAggregateOutputType | null
    _max: ItemInstanceMaxAggregateOutputType | null
  }

  type GetItemInstanceGroupByPayload<T extends ItemInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], ItemInstanceGroupByOutputType[P]>
        }
      >
    >


  export type ItemInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemInstance"]>

  export type ItemInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemInstance"]>

  export type ItemInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemInstance"]>

  export type ItemInstanceSelectScalar = {
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
  }

  export type ItemInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "itemId" | "quantity", ExtArgs["result"]["itemInstance"]>
  export type ItemInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemInstance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      itemId: number
      quantity: number
    }, ExtArgs["result"]["itemInstance"]>
    composites: {}
  }

  type ItemInstanceGetPayload<S extends boolean | null | undefined | ItemInstanceDefaultArgs> = $Result.GetResult<Prisma.$ItemInstancePayload, S>

  type ItemInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemInstanceCountAggregateInputType | true
    }

  export interface ItemInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemInstance'], meta: { name: 'ItemInstance' } }
    /**
     * Find zero or one ItemInstance that matches the filter.
     * @param {ItemInstanceFindUniqueArgs} args - Arguments to find a ItemInstance
     * @example
     * // Get one ItemInstance
     * const itemInstance = await prisma.itemInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemInstanceFindUniqueArgs>(args: SelectSubset<T, ItemInstanceFindUniqueArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemInstanceFindUniqueOrThrowArgs} args - Arguments to find a ItemInstance
     * @example
     * // Get one ItemInstance
     * const itemInstance = await prisma.itemInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceFindFirstArgs} args - Arguments to find a ItemInstance
     * @example
     * // Get one ItemInstance
     * const itemInstance = await prisma.itemInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemInstanceFindFirstArgs>(args?: SelectSubset<T, ItemInstanceFindFirstArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceFindFirstOrThrowArgs} args - Arguments to find a ItemInstance
     * @example
     * // Get one ItemInstance
     * const itemInstance = await prisma.itemInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemInstances
     * const itemInstances = await prisma.itemInstance.findMany()
     * 
     * // Get first 10 ItemInstances
     * const itemInstances = await prisma.itemInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemInstanceWithIdOnly = await prisma.itemInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemInstanceFindManyArgs>(args?: SelectSubset<T, ItemInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemInstance.
     * @param {ItemInstanceCreateArgs} args - Arguments to create a ItemInstance.
     * @example
     * // Create one ItemInstance
     * const ItemInstance = await prisma.itemInstance.create({
     *   data: {
     *     // ... data to create a ItemInstance
     *   }
     * })
     * 
     */
    create<T extends ItemInstanceCreateArgs>(args: SelectSubset<T, ItemInstanceCreateArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemInstances.
     * @param {ItemInstanceCreateManyArgs} args - Arguments to create many ItemInstances.
     * @example
     * // Create many ItemInstances
     * const itemInstance = await prisma.itemInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemInstanceCreateManyArgs>(args?: SelectSubset<T, ItemInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemInstances and returns the data saved in the database.
     * @param {ItemInstanceCreateManyAndReturnArgs} args - Arguments to create many ItemInstances.
     * @example
     * // Create many ItemInstances
     * const itemInstance = await prisma.itemInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemInstances and only return the `id`
     * const itemInstanceWithIdOnly = await prisma.itemInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemInstance.
     * @param {ItemInstanceDeleteArgs} args - Arguments to delete one ItemInstance.
     * @example
     * // Delete one ItemInstance
     * const ItemInstance = await prisma.itemInstance.delete({
     *   where: {
     *     // ... filter to delete one ItemInstance
     *   }
     * })
     * 
     */
    delete<T extends ItemInstanceDeleteArgs>(args: SelectSubset<T, ItemInstanceDeleteArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemInstance.
     * @param {ItemInstanceUpdateArgs} args - Arguments to update one ItemInstance.
     * @example
     * // Update one ItemInstance
     * const itemInstance = await prisma.itemInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemInstanceUpdateArgs>(args: SelectSubset<T, ItemInstanceUpdateArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemInstances.
     * @param {ItemInstanceDeleteManyArgs} args - Arguments to filter ItemInstances to delete.
     * @example
     * // Delete a few ItemInstances
     * const { count } = await prisma.itemInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemInstanceDeleteManyArgs>(args?: SelectSubset<T, ItemInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemInstances
     * const itemInstance = await prisma.itemInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemInstanceUpdateManyArgs>(args: SelectSubset<T, ItemInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemInstances and returns the data updated in the database.
     * @param {ItemInstanceUpdateManyAndReturnArgs} args - Arguments to update many ItemInstances.
     * @example
     * // Update many ItemInstances
     * const itemInstance = await prisma.itemInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemInstances and only return the `id`
     * const itemInstanceWithIdOnly = await prisma.itemInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemInstance.
     * @param {ItemInstanceUpsertArgs} args - Arguments to update or create a ItemInstance.
     * @example
     * // Update or create a ItemInstance
     * const itemInstance = await prisma.itemInstance.upsert({
     *   create: {
     *     // ... data to create a ItemInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemInstance we want to update
     *   }
     * })
     */
    upsert<T extends ItemInstanceUpsertArgs>(args: SelectSubset<T, ItemInstanceUpsertArgs<ExtArgs>>): Prisma__ItemInstanceClient<$Result.GetResult<Prisma.$ItemInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceCountArgs} args - Arguments to filter ItemInstances to count.
     * @example
     * // Count the number of ItemInstances
     * const count = await prisma.itemInstance.count({
     *   where: {
     *     // ... the filter for the ItemInstances we want to count
     *   }
     * })
    **/
    count<T extends ItemInstanceCountArgs>(
      args?: Subset<T, ItemInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemInstanceAggregateArgs>(args: Subset<T, ItemInstanceAggregateArgs>): Prisma.PrismaPromise<GetItemInstanceAggregateType<T>>

    /**
     * Group by ItemInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemInstanceGroupByArgs['orderBy'] }
        : { orderBy?: ItemInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemInstance model
   */
  readonly fields: ItemInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemInstance model
   */
  interface ItemInstanceFieldRefs {
    readonly id: FieldRef<"ItemInstance", 'Int'>
    readonly userId: FieldRef<"ItemInstance", 'Int'>
    readonly itemId: FieldRef<"ItemInstance", 'Int'>
    readonly quantity: FieldRef<"ItemInstance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ItemInstance findUnique
   */
  export type ItemInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ItemInstance to fetch.
     */
    where: ItemInstanceWhereUniqueInput
  }

  /**
   * ItemInstance findUniqueOrThrow
   */
  export type ItemInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ItemInstance to fetch.
     */
    where: ItemInstanceWhereUniqueInput
  }

  /**
   * ItemInstance findFirst
   */
  export type ItemInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ItemInstance to fetch.
     */
    where?: ItemInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemInstances to fetch.
     */
    orderBy?: ItemInstanceOrderByWithRelationInput | ItemInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemInstances.
     */
    cursor?: ItemInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemInstances.
     */
    distinct?: ItemInstanceScalarFieldEnum | ItemInstanceScalarFieldEnum[]
  }

  /**
   * ItemInstance findFirstOrThrow
   */
  export type ItemInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ItemInstance to fetch.
     */
    where?: ItemInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemInstances to fetch.
     */
    orderBy?: ItemInstanceOrderByWithRelationInput | ItemInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemInstances.
     */
    cursor?: ItemInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemInstances.
     */
    distinct?: ItemInstanceScalarFieldEnum | ItemInstanceScalarFieldEnum[]
  }

  /**
   * ItemInstance findMany
   */
  export type ItemInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ItemInstances to fetch.
     */
    where?: ItemInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemInstances to fetch.
     */
    orderBy?: ItemInstanceOrderByWithRelationInput | ItemInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemInstances.
     */
    cursor?: ItemInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemInstances.
     */
    skip?: number
    distinct?: ItemInstanceScalarFieldEnum | ItemInstanceScalarFieldEnum[]
  }

  /**
   * ItemInstance create
   */
  export type ItemInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemInstance.
     */
    data: XOR<ItemInstanceCreateInput, ItemInstanceUncheckedCreateInput>
  }

  /**
   * ItemInstance createMany
   */
  export type ItemInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemInstances.
     */
    data: ItemInstanceCreateManyInput | ItemInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemInstance createManyAndReturn
   */
  export type ItemInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many ItemInstances.
     */
    data: ItemInstanceCreateManyInput | ItemInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemInstance update
   */
  export type ItemInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemInstance.
     */
    data: XOR<ItemInstanceUpdateInput, ItemInstanceUncheckedUpdateInput>
    /**
     * Choose, which ItemInstance to update.
     */
    where: ItemInstanceWhereUniqueInput
  }

  /**
   * ItemInstance updateMany
   */
  export type ItemInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemInstances.
     */
    data: XOR<ItemInstanceUpdateManyMutationInput, ItemInstanceUncheckedUpdateManyInput>
    /**
     * Filter which ItemInstances to update
     */
    where?: ItemInstanceWhereInput
    /**
     * Limit how many ItemInstances to update.
     */
    limit?: number
  }

  /**
   * ItemInstance updateManyAndReturn
   */
  export type ItemInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * The data used to update ItemInstances.
     */
    data: XOR<ItemInstanceUpdateManyMutationInput, ItemInstanceUncheckedUpdateManyInput>
    /**
     * Filter which ItemInstances to update
     */
    where?: ItemInstanceWhereInput
    /**
     * Limit how many ItemInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemInstance upsert
   */
  export type ItemInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemInstance to update in case it exists.
     */
    where: ItemInstanceWhereUniqueInput
    /**
     * In case the ItemInstance found by the `where` argument doesn't exist, create a new ItemInstance with this data.
     */
    create: XOR<ItemInstanceCreateInput, ItemInstanceUncheckedCreateInput>
    /**
     * In case the ItemInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemInstanceUpdateInput, ItemInstanceUncheckedUpdateInput>
  }

  /**
   * ItemInstance delete
   */
  export type ItemInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
    /**
     * Filter which ItemInstance to delete.
     */
    where: ItemInstanceWhereUniqueInput
  }

  /**
   * ItemInstance deleteMany
   */
  export type ItemInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemInstances to delete
     */
    where?: ItemInstanceWhereInput
    /**
     * Limit how many ItemInstances to delete.
     */
    limit?: number
  }

  /**
   * ItemInstance without action
   */
  export type ItemInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemInstance
     */
    select?: ItemInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemInstance
     */
    omit?: ItemInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    id: number | null
    difficulty: number | null
    productId: number | null
  }

  export type RecipeSumAggregateOutputType = {
    id: number | null
    difficulty: number | null
    productId: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: number | null
    name: string | null
    profession: string | null
    difficulty: number | null
    productId: number | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    profession: string | null
    difficulty: number | null
    productId: number | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    profession: number
    difficulty: number
    productId: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    id?: true
    difficulty?: true
    productId?: true
  }

  export type RecipeSumAggregateInputType = {
    id?: true
    difficulty?: true
    productId?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    profession?: true
    difficulty?: true
    productId?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    profession?: true
    difficulty?: true
    productId?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    profession?: true
    difficulty?: true
    productId?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: number
    name: string
    profession: string
    difficulty: number
    productId: number
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    profession?: boolean
    difficulty?: boolean
    productId?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
    materials?: boolean | Recipe$materialsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    profession?: boolean
    difficulty?: boolean
    productId?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    profession?: boolean
    difficulty?: boolean
    productId?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    profession?: boolean
    difficulty?: boolean
    productId?: boolean
  }

  export type RecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "profession" | "difficulty" | "productId", ExtArgs["result"]["recipe"]>
  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
    materials?: boolean | Recipe$materialsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      product: Prisma.$ItemPayload<ExtArgs>
      materials: Prisma.$RecipeMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      profession: string
      difficulty: number
      productId: number
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes and returns the data updated in the database.
     * @param {RecipeUpdateManyAndReturnArgs} args - Arguments to update many Recipes.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materials<T extends Recipe$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'Int'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly profession: FieldRef<"Recipe", 'String'>
    readonly difficulty: FieldRef<"Recipe", 'Int'>
    readonly productId: FieldRef<"Recipe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
  }

  /**
   * Recipe updateManyAndReturn
   */
  export type RecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to delete.
     */
    limit?: number
  }

  /**
   * Recipe.materials
   */
  export type Recipe$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    where?: RecipeMaterialWhereInput
    orderBy?: RecipeMaterialOrderByWithRelationInput | RecipeMaterialOrderByWithRelationInput[]
    cursor?: RecipeMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeMaterialScalarFieldEnum | RecipeMaterialScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeMaterial
   */

  export type AggregateRecipeMaterial = {
    _count: RecipeMaterialCountAggregateOutputType | null
    _avg: RecipeMaterialAvgAggregateOutputType | null
    _sum: RecipeMaterialSumAggregateOutputType | null
    _min: RecipeMaterialMinAggregateOutputType | null
    _max: RecipeMaterialMaxAggregateOutputType | null
  }

  export type RecipeMaterialAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type RecipeMaterialSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type RecipeMaterialMinAggregateOutputType = {
    id: number | null
    recipeId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type RecipeMaterialMaxAggregateOutputType = {
    id: number | null
    recipeId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type RecipeMaterialCountAggregateOutputType = {
    id: number
    recipeId: number
    itemId: number
    quantity: number
    _all: number
  }


  export type RecipeMaterialAvgAggregateInputType = {
    id?: true
    recipeId?: true
    itemId?: true
    quantity?: true
  }

  export type RecipeMaterialSumAggregateInputType = {
    id?: true
    recipeId?: true
    itemId?: true
    quantity?: true
  }

  export type RecipeMaterialMinAggregateInputType = {
    id?: true
    recipeId?: true
    itemId?: true
    quantity?: true
  }

  export type RecipeMaterialMaxAggregateInputType = {
    id?: true
    recipeId?: true
    itemId?: true
    quantity?: true
  }

  export type RecipeMaterialCountAggregateInputType = {
    id?: true
    recipeId?: true
    itemId?: true
    quantity?: true
    _all?: true
  }

  export type RecipeMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeMaterial to aggregate.
     */
    where?: RecipeMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMaterials to fetch.
     */
    orderBy?: RecipeMaterialOrderByWithRelationInput | RecipeMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeMaterials
    **/
    _count?: true | RecipeMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaterialMaxAggregateInputType
  }

  export type GetRecipeMaterialAggregateType<T extends RecipeMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeMaterial[P]>
      : GetScalarType<T[P], AggregateRecipeMaterial[P]>
  }




  export type RecipeMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeMaterialWhereInput
    orderBy?: RecipeMaterialOrderByWithAggregationInput | RecipeMaterialOrderByWithAggregationInput[]
    by: RecipeMaterialScalarFieldEnum[] | RecipeMaterialScalarFieldEnum
    having?: RecipeMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeMaterialCountAggregateInputType | true
    _avg?: RecipeMaterialAvgAggregateInputType
    _sum?: RecipeMaterialSumAggregateInputType
    _min?: RecipeMaterialMinAggregateInputType
    _max?: RecipeMaterialMaxAggregateInputType
  }

  export type RecipeMaterialGroupByOutputType = {
    id: number
    recipeId: number
    itemId: number
    quantity: number
    _count: RecipeMaterialCountAggregateOutputType | null
    _avg: RecipeMaterialAvgAggregateOutputType | null
    _sum: RecipeMaterialSumAggregateOutputType | null
    _min: RecipeMaterialMinAggregateOutputType | null
    _max: RecipeMaterialMaxAggregateOutputType | null
  }

  type GetRecipeMaterialGroupByPayload<T extends RecipeMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeMaterialGroupByOutputType[P]>
        }
      >
    >


  export type RecipeMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    itemId?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeMaterial"]>

  export type RecipeMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    itemId?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeMaterial"]>

  export type RecipeMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    itemId?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeMaterial"]>

  export type RecipeMaterialSelectScalar = {
    id?: boolean
    recipeId?: boolean
    itemId?: boolean
    quantity?: boolean
  }

  export type RecipeMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "itemId" | "quantity", ExtArgs["result"]["recipeMaterial"]>
  export type RecipeMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type RecipeMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type RecipeMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $RecipeMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeMaterial"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recipeId: number
      itemId: number
      quantity: number
    }, ExtArgs["result"]["recipeMaterial"]>
    composites: {}
  }

  type RecipeMaterialGetPayload<S extends boolean | null | undefined | RecipeMaterialDefaultArgs> = $Result.GetResult<Prisma.$RecipeMaterialPayload, S>

  type RecipeMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeMaterialCountAggregateInputType | true
    }

  export interface RecipeMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeMaterial'], meta: { name: 'RecipeMaterial' } }
    /**
     * Find zero or one RecipeMaterial that matches the filter.
     * @param {RecipeMaterialFindUniqueArgs} args - Arguments to find a RecipeMaterial
     * @example
     * // Get one RecipeMaterial
     * const recipeMaterial = await prisma.recipeMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeMaterialFindUniqueArgs>(args: SelectSubset<T, RecipeMaterialFindUniqueArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeMaterialFindUniqueOrThrowArgs} args - Arguments to find a RecipeMaterial
     * @example
     * // Get one RecipeMaterial
     * const recipeMaterial = await prisma.recipeMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialFindFirstArgs} args - Arguments to find a RecipeMaterial
     * @example
     * // Get one RecipeMaterial
     * const recipeMaterial = await prisma.recipeMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeMaterialFindFirstArgs>(args?: SelectSubset<T, RecipeMaterialFindFirstArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialFindFirstOrThrowArgs} args - Arguments to find a RecipeMaterial
     * @example
     * // Get one RecipeMaterial
     * const recipeMaterial = await prisma.recipeMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeMaterials
     * const recipeMaterials = await prisma.recipeMaterial.findMany()
     * 
     * // Get first 10 RecipeMaterials
     * const recipeMaterials = await prisma.recipeMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeMaterialWithIdOnly = await prisma.recipeMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeMaterialFindManyArgs>(args?: SelectSubset<T, RecipeMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeMaterial.
     * @param {RecipeMaterialCreateArgs} args - Arguments to create a RecipeMaterial.
     * @example
     * // Create one RecipeMaterial
     * const RecipeMaterial = await prisma.recipeMaterial.create({
     *   data: {
     *     // ... data to create a RecipeMaterial
     *   }
     * })
     * 
     */
    create<T extends RecipeMaterialCreateArgs>(args: SelectSubset<T, RecipeMaterialCreateArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeMaterials.
     * @param {RecipeMaterialCreateManyArgs} args - Arguments to create many RecipeMaterials.
     * @example
     * // Create many RecipeMaterials
     * const recipeMaterial = await prisma.recipeMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeMaterialCreateManyArgs>(args?: SelectSubset<T, RecipeMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeMaterials and returns the data saved in the database.
     * @param {RecipeMaterialCreateManyAndReturnArgs} args - Arguments to create many RecipeMaterials.
     * @example
     * // Create many RecipeMaterials
     * const recipeMaterial = await prisma.recipeMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeMaterials and only return the `id`
     * const recipeMaterialWithIdOnly = await prisma.recipeMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeMaterial.
     * @param {RecipeMaterialDeleteArgs} args - Arguments to delete one RecipeMaterial.
     * @example
     * // Delete one RecipeMaterial
     * const RecipeMaterial = await prisma.recipeMaterial.delete({
     *   where: {
     *     // ... filter to delete one RecipeMaterial
     *   }
     * })
     * 
     */
    delete<T extends RecipeMaterialDeleteArgs>(args: SelectSubset<T, RecipeMaterialDeleteArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeMaterial.
     * @param {RecipeMaterialUpdateArgs} args - Arguments to update one RecipeMaterial.
     * @example
     * // Update one RecipeMaterial
     * const recipeMaterial = await prisma.recipeMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeMaterialUpdateArgs>(args: SelectSubset<T, RecipeMaterialUpdateArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeMaterials.
     * @param {RecipeMaterialDeleteManyArgs} args - Arguments to filter RecipeMaterials to delete.
     * @example
     * // Delete a few RecipeMaterials
     * const { count } = await prisma.recipeMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeMaterialDeleteManyArgs>(args?: SelectSubset<T, RecipeMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeMaterials
     * const recipeMaterial = await prisma.recipeMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeMaterialUpdateManyArgs>(args: SelectSubset<T, RecipeMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeMaterials and returns the data updated in the database.
     * @param {RecipeMaterialUpdateManyAndReturnArgs} args - Arguments to update many RecipeMaterials.
     * @example
     * // Update many RecipeMaterials
     * const recipeMaterial = await prisma.recipeMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeMaterials and only return the `id`
     * const recipeMaterialWithIdOnly = await prisma.recipeMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeMaterial.
     * @param {RecipeMaterialUpsertArgs} args - Arguments to update or create a RecipeMaterial.
     * @example
     * // Update or create a RecipeMaterial
     * const recipeMaterial = await prisma.recipeMaterial.upsert({
     *   create: {
     *     // ... data to create a RecipeMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeMaterial we want to update
     *   }
     * })
     */
    upsert<T extends RecipeMaterialUpsertArgs>(args: SelectSubset<T, RecipeMaterialUpsertArgs<ExtArgs>>): Prisma__RecipeMaterialClient<$Result.GetResult<Prisma.$RecipeMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialCountArgs} args - Arguments to filter RecipeMaterials to count.
     * @example
     * // Count the number of RecipeMaterials
     * const count = await prisma.recipeMaterial.count({
     *   where: {
     *     // ... the filter for the RecipeMaterials we want to count
     *   }
     * })
    **/
    count<T extends RecipeMaterialCountArgs>(
      args?: Subset<T, RecipeMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeMaterialAggregateArgs>(args: Subset<T, RecipeMaterialAggregateArgs>): Prisma.PrismaPromise<GetRecipeMaterialAggregateType<T>>

    /**
     * Group by RecipeMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeMaterialGroupByArgs['orderBy'] }
        : { orderBy?: RecipeMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeMaterial model
   */
  readonly fields: RecipeMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeMaterial model
   */
  interface RecipeMaterialFieldRefs {
    readonly id: FieldRef<"RecipeMaterial", 'Int'>
    readonly recipeId: FieldRef<"RecipeMaterial", 'Int'>
    readonly itemId: FieldRef<"RecipeMaterial", 'Int'>
    readonly quantity: FieldRef<"RecipeMaterial", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecipeMaterial findUnique
   */
  export type RecipeMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMaterial to fetch.
     */
    where: RecipeMaterialWhereUniqueInput
  }

  /**
   * RecipeMaterial findUniqueOrThrow
   */
  export type RecipeMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMaterial to fetch.
     */
    where: RecipeMaterialWhereUniqueInput
  }

  /**
   * RecipeMaterial findFirst
   */
  export type RecipeMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMaterial to fetch.
     */
    where?: RecipeMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMaterials to fetch.
     */
    orderBy?: RecipeMaterialOrderByWithRelationInput | RecipeMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeMaterials.
     */
    cursor?: RecipeMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeMaterials.
     */
    distinct?: RecipeMaterialScalarFieldEnum | RecipeMaterialScalarFieldEnum[]
  }

  /**
   * RecipeMaterial findFirstOrThrow
   */
  export type RecipeMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMaterial to fetch.
     */
    where?: RecipeMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMaterials to fetch.
     */
    orderBy?: RecipeMaterialOrderByWithRelationInput | RecipeMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeMaterials.
     */
    cursor?: RecipeMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeMaterials.
     */
    distinct?: RecipeMaterialScalarFieldEnum | RecipeMaterialScalarFieldEnum[]
  }

  /**
   * RecipeMaterial findMany
   */
  export type RecipeMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMaterials to fetch.
     */
    where?: RecipeMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMaterials to fetch.
     */
    orderBy?: RecipeMaterialOrderByWithRelationInput | RecipeMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeMaterials.
     */
    cursor?: RecipeMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMaterials.
     */
    skip?: number
    distinct?: RecipeMaterialScalarFieldEnum | RecipeMaterialScalarFieldEnum[]
  }

  /**
   * RecipeMaterial create
   */
  export type RecipeMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeMaterial.
     */
    data: XOR<RecipeMaterialCreateInput, RecipeMaterialUncheckedCreateInput>
  }

  /**
   * RecipeMaterial createMany
   */
  export type RecipeMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeMaterials.
     */
    data: RecipeMaterialCreateManyInput | RecipeMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecipeMaterial createManyAndReturn
   */
  export type RecipeMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeMaterials.
     */
    data: RecipeMaterialCreateManyInput | RecipeMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeMaterial update
   */
  export type RecipeMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeMaterial.
     */
    data: XOR<RecipeMaterialUpdateInput, RecipeMaterialUncheckedUpdateInput>
    /**
     * Choose, which RecipeMaterial to update.
     */
    where: RecipeMaterialWhereUniqueInput
  }

  /**
   * RecipeMaterial updateMany
   */
  export type RecipeMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeMaterials.
     */
    data: XOR<RecipeMaterialUpdateManyMutationInput, RecipeMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RecipeMaterials to update
     */
    where?: RecipeMaterialWhereInput
    /**
     * Limit how many RecipeMaterials to update.
     */
    limit?: number
  }

  /**
   * RecipeMaterial updateManyAndReturn
   */
  export type RecipeMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * The data used to update RecipeMaterials.
     */
    data: XOR<RecipeMaterialUpdateManyMutationInput, RecipeMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RecipeMaterials to update
     */
    where?: RecipeMaterialWhereInput
    /**
     * Limit how many RecipeMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeMaterial upsert
   */
  export type RecipeMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeMaterial to update in case it exists.
     */
    where: RecipeMaterialWhereUniqueInput
    /**
     * In case the RecipeMaterial found by the `where` argument doesn't exist, create a new RecipeMaterial with this data.
     */
    create: XOR<RecipeMaterialCreateInput, RecipeMaterialUncheckedCreateInput>
    /**
     * In case the RecipeMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeMaterialUpdateInput, RecipeMaterialUncheckedUpdateInput>
  }

  /**
   * RecipeMaterial delete
   */
  export type RecipeMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
    /**
     * Filter which RecipeMaterial to delete.
     */
    where: RecipeMaterialWhereUniqueInput
  }

  /**
   * RecipeMaterial deleteMany
   */
  export type RecipeMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeMaterials to delete
     */
    where?: RecipeMaterialWhereInput
    /**
     * Limit how many RecipeMaterials to delete.
     */
    limit?: number
  }

  /**
   * RecipeMaterial without action
   */
  export type RecipeMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMaterial
     */
    select?: RecipeMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMaterial
     */
    omit?: RecipeMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Corpse
   */

  export type AggregateCorpse = {
    _count: CorpseCountAggregateOutputType | null
    _avg: CorpseAvgAggregateOutputType | null
    _sum: CorpseSumAggregateOutputType | null
    _min: CorpseMinAggregateOutputType | null
    _max: CorpseMaxAggregateOutputType | null
  }

  export type CorpseAvgAggregateOutputType = {
    id: number | null
    npcId: number | null
    userId: number | null
  }

  export type CorpseSumAggregateOutputType = {
    id: number | null
    npcId: number | null
    userId: number | null
  }

  export type CorpseMinAggregateOutputType = {
    id: number | null
    npcId: number | null
    userId: number | null
    type: string | null
    decayStage: string | null
    location: string | null
    causeOfDeath: string | null
    isWaterlogged: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorpseMaxAggregateOutputType = {
    id: number | null
    npcId: number | null
    userId: number | null
    type: string | null
    decayStage: string | null
    location: string | null
    causeOfDeath: string | null
    isWaterlogged: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorpseCountAggregateOutputType = {
    id: number
    npcId: number
    userId: number
    type: number
    decayStage: number
    location: number
    causeOfDeath: number
    isWaterlogged: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorpseAvgAggregateInputType = {
    id?: true
    npcId?: true
    userId?: true
  }

  export type CorpseSumAggregateInputType = {
    id?: true
    npcId?: true
    userId?: true
  }

  export type CorpseMinAggregateInputType = {
    id?: true
    npcId?: true
    userId?: true
    type?: true
    decayStage?: true
    location?: true
    causeOfDeath?: true
    isWaterlogged?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorpseMaxAggregateInputType = {
    id?: true
    npcId?: true
    userId?: true
    type?: true
    decayStage?: true
    location?: true
    causeOfDeath?: true
    isWaterlogged?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorpseCountAggregateInputType = {
    id?: true
    npcId?: true
    userId?: true
    type?: true
    decayStage?: true
    location?: true
    causeOfDeath?: true
    isWaterlogged?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorpseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Corpse to aggregate.
     */
    where?: CorpseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corpses to fetch.
     */
    orderBy?: CorpseOrderByWithRelationInput | CorpseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorpseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corpses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corpses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Corpses
    **/
    _count?: true | CorpseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorpseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorpseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorpseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorpseMaxAggregateInputType
  }

  export type GetCorpseAggregateType<T extends CorpseAggregateArgs> = {
        [P in keyof T & keyof AggregateCorpse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorpse[P]>
      : GetScalarType<T[P], AggregateCorpse[P]>
  }




  export type CorpseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorpseWhereInput
    orderBy?: CorpseOrderByWithAggregationInput | CorpseOrderByWithAggregationInput[]
    by: CorpseScalarFieldEnum[] | CorpseScalarFieldEnum
    having?: CorpseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorpseCountAggregateInputType | true
    _avg?: CorpseAvgAggregateInputType
    _sum?: CorpseSumAggregateInputType
    _min?: CorpseMinAggregateInputType
    _max?: CorpseMaxAggregateInputType
  }

  export type CorpseGroupByOutputType = {
    id: number
    npcId: number | null
    userId: number | null
    type: string
    decayStage: string
    location: string
    causeOfDeath: string | null
    isWaterlogged: boolean
    createdAt: Date
    updatedAt: Date
    _count: CorpseCountAggregateOutputType | null
    _avg: CorpseAvgAggregateOutputType | null
    _sum: CorpseSumAggregateOutputType | null
    _min: CorpseMinAggregateOutputType | null
    _max: CorpseMaxAggregateOutputType | null
  }

  type GetCorpseGroupByPayload<T extends CorpseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorpseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorpseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorpseGroupByOutputType[P]>
            : GetScalarType<T[P], CorpseGroupByOutputType[P]>
        }
      >
    >


  export type CorpseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    userId?: boolean
    type?: boolean
    decayStage?: boolean
    location?: boolean
    causeOfDeath?: boolean
    isWaterlogged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corpse"]>

  export type CorpseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    userId?: boolean
    type?: boolean
    decayStage?: boolean
    location?: boolean
    causeOfDeath?: boolean
    isWaterlogged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corpse"]>

  export type CorpseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    userId?: boolean
    type?: boolean
    decayStage?: boolean
    location?: boolean
    causeOfDeath?: boolean
    isWaterlogged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["corpse"]>

  export type CorpseSelectScalar = {
    id?: boolean
    npcId?: boolean
    userId?: boolean
    type?: boolean
    decayStage?: boolean
    location?: boolean
    causeOfDeath?: boolean
    isWaterlogged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorpseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "npcId" | "userId" | "type" | "decayStage" | "location" | "causeOfDeath" | "isWaterlogged" | "createdAt" | "updatedAt", ExtArgs["result"]["corpse"]>

  export type $CorpsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Corpse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      npcId: number | null
      userId: number | null
      type: string
      decayStage: string
      location: string
      causeOfDeath: string | null
      isWaterlogged: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corpse"]>
    composites: {}
  }

  type CorpseGetPayload<S extends boolean | null | undefined | CorpseDefaultArgs> = $Result.GetResult<Prisma.$CorpsePayload, S>

  type CorpseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CorpseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorpseCountAggregateInputType | true
    }

  export interface CorpseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Corpse'], meta: { name: 'Corpse' } }
    /**
     * Find zero or one Corpse that matches the filter.
     * @param {CorpseFindUniqueArgs} args - Arguments to find a Corpse
     * @example
     * // Get one Corpse
     * const corpse = await prisma.corpse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorpseFindUniqueArgs>(args: SelectSubset<T, CorpseFindUniqueArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Corpse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CorpseFindUniqueOrThrowArgs} args - Arguments to find a Corpse
     * @example
     * // Get one Corpse
     * const corpse = await prisma.corpse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorpseFindUniqueOrThrowArgs>(args: SelectSubset<T, CorpseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Corpse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseFindFirstArgs} args - Arguments to find a Corpse
     * @example
     * // Get one Corpse
     * const corpse = await prisma.corpse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorpseFindFirstArgs>(args?: SelectSubset<T, CorpseFindFirstArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Corpse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseFindFirstOrThrowArgs} args - Arguments to find a Corpse
     * @example
     * // Get one Corpse
     * const corpse = await prisma.corpse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorpseFindFirstOrThrowArgs>(args?: SelectSubset<T, CorpseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Corpses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Corpses
     * const corpses = await prisma.corpse.findMany()
     * 
     * // Get first 10 Corpses
     * const corpses = await prisma.corpse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corpseWithIdOnly = await prisma.corpse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorpseFindManyArgs>(args?: SelectSubset<T, CorpseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Corpse.
     * @param {CorpseCreateArgs} args - Arguments to create a Corpse.
     * @example
     * // Create one Corpse
     * const Corpse = await prisma.corpse.create({
     *   data: {
     *     // ... data to create a Corpse
     *   }
     * })
     * 
     */
    create<T extends CorpseCreateArgs>(args: SelectSubset<T, CorpseCreateArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Corpses.
     * @param {CorpseCreateManyArgs} args - Arguments to create many Corpses.
     * @example
     * // Create many Corpses
     * const corpse = await prisma.corpse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorpseCreateManyArgs>(args?: SelectSubset<T, CorpseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Corpses and returns the data saved in the database.
     * @param {CorpseCreateManyAndReturnArgs} args - Arguments to create many Corpses.
     * @example
     * // Create many Corpses
     * const corpse = await prisma.corpse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Corpses and only return the `id`
     * const corpseWithIdOnly = await prisma.corpse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorpseCreateManyAndReturnArgs>(args?: SelectSubset<T, CorpseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Corpse.
     * @param {CorpseDeleteArgs} args - Arguments to delete one Corpse.
     * @example
     * // Delete one Corpse
     * const Corpse = await prisma.corpse.delete({
     *   where: {
     *     // ... filter to delete one Corpse
     *   }
     * })
     * 
     */
    delete<T extends CorpseDeleteArgs>(args: SelectSubset<T, CorpseDeleteArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Corpse.
     * @param {CorpseUpdateArgs} args - Arguments to update one Corpse.
     * @example
     * // Update one Corpse
     * const corpse = await prisma.corpse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorpseUpdateArgs>(args: SelectSubset<T, CorpseUpdateArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Corpses.
     * @param {CorpseDeleteManyArgs} args - Arguments to filter Corpses to delete.
     * @example
     * // Delete a few Corpses
     * const { count } = await prisma.corpse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorpseDeleteManyArgs>(args?: SelectSubset<T, CorpseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corpses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Corpses
     * const corpse = await prisma.corpse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorpseUpdateManyArgs>(args: SelectSubset<T, CorpseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corpses and returns the data updated in the database.
     * @param {CorpseUpdateManyAndReturnArgs} args - Arguments to update many Corpses.
     * @example
     * // Update many Corpses
     * const corpse = await prisma.corpse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Corpses and only return the `id`
     * const corpseWithIdOnly = await prisma.corpse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CorpseUpdateManyAndReturnArgs>(args: SelectSubset<T, CorpseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Corpse.
     * @param {CorpseUpsertArgs} args - Arguments to update or create a Corpse.
     * @example
     * // Update or create a Corpse
     * const corpse = await prisma.corpse.upsert({
     *   create: {
     *     // ... data to create a Corpse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Corpse we want to update
     *   }
     * })
     */
    upsert<T extends CorpseUpsertArgs>(args: SelectSubset<T, CorpseUpsertArgs<ExtArgs>>): Prisma__CorpseClient<$Result.GetResult<Prisma.$CorpsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Corpses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseCountArgs} args - Arguments to filter Corpses to count.
     * @example
     * // Count the number of Corpses
     * const count = await prisma.corpse.count({
     *   where: {
     *     // ... the filter for the Corpses we want to count
     *   }
     * })
    **/
    count<T extends CorpseCountArgs>(
      args?: Subset<T, CorpseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorpseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Corpse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorpseAggregateArgs>(args: Subset<T, CorpseAggregateArgs>): Prisma.PrismaPromise<GetCorpseAggregateType<T>>

    /**
     * Group by Corpse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorpseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorpseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorpseGroupByArgs['orderBy'] }
        : { orderBy?: CorpseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorpseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorpseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Corpse model
   */
  readonly fields: CorpseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Corpse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorpseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Corpse model
   */
  interface CorpseFieldRefs {
    readonly id: FieldRef<"Corpse", 'Int'>
    readonly npcId: FieldRef<"Corpse", 'Int'>
    readonly userId: FieldRef<"Corpse", 'Int'>
    readonly type: FieldRef<"Corpse", 'String'>
    readonly decayStage: FieldRef<"Corpse", 'String'>
    readonly location: FieldRef<"Corpse", 'String'>
    readonly causeOfDeath: FieldRef<"Corpse", 'String'>
    readonly isWaterlogged: FieldRef<"Corpse", 'Boolean'>
    readonly createdAt: FieldRef<"Corpse", 'DateTime'>
    readonly updatedAt: FieldRef<"Corpse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Corpse findUnique
   */
  export type CorpseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * Filter, which Corpse to fetch.
     */
    where: CorpseWhereUniqueInput
  }

  /**
   * Corpse findUniqueOrThrow
   */
  export type CorpseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * Filter, which Corpse to fetch.
     */
    where: CorpseWhereUniqueInput
  }

  /**
   * Corpse findFirst
   */
  export type CorpseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * Filter, which Corpse to fetch.
     */
    where?: CorpseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corpses to fetch.
     */
    orderBy?: CorpseOrderByWithRelationInput | CorpseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Corpses.
     */
    cursor?: CorpseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corpses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corpses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Corpses.
     */
    distinct?: CorpseScalarFieldEnum | CorpseScalarFieldEnum[]
  }

  /**
   * Corpse findFirstOrThrow
   */
  export type CorpseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * Filter, which Corpse to fetch.
     */
    where?: CorpseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corpses to fetch.
     */
    orderBy?: CorpseOrderByWithRelationInput | CorpseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Corpses.
     */
    cursor?: CorpseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corpses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corpses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Corpses.
     */
    distinct?: CorpseScalarFieldEnum | CorpseScalarFieldEnum[]
  }

  /**
   * Corpse findMany
   */
  export type CorpseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * Filter, which Corpses to fetch.
     */
    where?: CorpseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corpses to fetch.
     */
    orderBy?: CorpseOrderByWithRelationInput | CorpseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Corpses.
     */
    cursor?: CorpseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corpses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corpses.
     */
    skip?: number
    distinct?: CorpseScalarFieldEnum | CorpseScalarFieldEnum[]
  }

  /**
   * Corpse create
   */
  export type CorpseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * The data needed to create a Corpse.
     */
    data: XOR<CorpseCreateInput, CorpseUncheckedCreateInput>
  }

  /**
   * Corpse createMany
   */
  export type CorpseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Corpses.
     */
    data: CorpseCreateManyInput | CorpseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Corpse createManyAndReturn
   */
  export type CorpseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * The data used to create many Corpses.
     */
    data: CorpseCreateManyInput | CorpseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Corpse update
   */
  export type CorpseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * The data needed to update a Corpse.
     */
    data: XOR<CorpseUpdateInput, CorpseUncheckedUpdateInput>
    /**
     * Choose, which Corpse to update.
     */
    where: CorpseWhereUniqueInput
  }

  /**
   * Corpse updateMany
   */
  export type CorpseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Corpses.
     */
    data: XOR<CorpseUpdateManyMutationInput, CorpseUncheckedUpdateManyInput>
    /**
     * Filter which Corpses to update
     */
    where?: CorpseWhereInput
    /**
     * Limit how many Corpses to update.
     */
    limit?: number
  }

  /**
   * Corpse updateManyAndReturn
   */
  export type CorpseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * The data used to update Corpses.
     */
    data: XOR<CorpseUpdateManyMutationInput, CorpseUncheckedUpdateManyInput>
    /**
     * Filter which Corpses to update
     */
    where?: CorpseWhereInput
    /**
     * Limit how many Corpses to update.
     */
    limit?: number
  }

  /**
   * Corpse upsert
   */
  export type CorpseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * The filter to search for the Corpse to update in case it exists.
     */
    where: CorpseWhereUniqueInput
    /**
     * In case the Corpse found by the `where` argument doesn't exist, create a new Corpse with this data.
     */
    create: XOR<CorpseCreateInput, CorpseUncheckedCreateInput>
    /**
     * In case the Corpse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorpseUpdateInput, CorpseUncheckedUpdateInput>
  }

  /**
   * Corpse delete
   */
  export type CorpseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
    /**
     * Filter which Corpse to delete.
     */
    where: CorpseWhereUniqueInput
  }

  /**
   * Corpse deleteMany
   */
  export type CorpseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Corpses to delete
     */
    where?: CorpseWhereInput
    /**
     * Limit how many Corpses to delete.
     */
    limit?: number
  }

  /**
   * Corpse without action
   */
  export type CorpseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Corpse
     */
    select?: CorpseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Corpse
     */
    omit?: CorpseOmit<ExtArgs> | null
  }


  /**
   * Model AnimalPopulation
   */

  export type AggregateAnimalPopulation = {
    _count: AnimalPopulationCountAggregateOutputType | null
    _avg: AnimalPopulationAvgAggregateOutputType | null
    _sum: AnimalPopulationSumAggregateOutputType | null
    _min: AnimalPopulationMinAggregateOutputType | null
    _max: AnimalPopulationMaxAggregateOutputType | null
  }

  export type AnimalPopulationAvgAggregateOutputType = {
    id: number | null
    population: number | null
    areaId: number | null
  }

  export type AnimalPopulationSumAggregateOutputType = {
    id: number | null
    population: number | null
    areaId: number | null
  }

  export type AnimalPopulationMinAggregateOutputType = {
    id: number | null
    species: string | null
    type: string | null
    population: number | null
    areaId: number | null
  }

  export type AnimalPopulationMaxAggregateOutputType = {
    id: number | null
    species: string | null
    type: string | null
    population: number | null
    areaId: number | null
  }

  export type AnimalPopulationCountAggregateOutputType = {
    id: number
    species: number
    type: number
    population: number
    areaId: number
    _all: number
  }


  export type AnimalPopulationAvgAggregateInputType = {
    id?: true
    population?: true
    areaId?: true
  }

  export type AnimalPopulationSumAggregateInputType = {
    id?: true
    population?: true
    areaId?: true
  }

  export type AnimalPopulationMinAggregateInputType = {
    id?: true
    species?: true
    type?: true
    population?: true
    areaId?: true
  }

  export type AnimalPopulationMaxAggregateInputType = {
    id?: true
    species?: true
    type?: true
    population?: true
    areaId?: true
  }

  export type AnimalPopulationCountAggregateInputType = {
    id?: true
    species?: true
    type?: true
    population?: true
    areaId?: true
    _all?: true
  }

  export type AnimalPopulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnimalPopulation to aggregate.
     */
    where?: AnimalPopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalPopulations to fetch.
     */
    orderBy?: AnimalPopulationOrderByWithRelationInput | AnimalPopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimalPopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalPopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalPopulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnimalPopulations
    **/
    _count?: true | AnimalPopulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimalPopulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimalPopulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimalPopulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimalPopulationMaxAggregateInputType
  }

  export type GetAnimalPopulationAggregateType<T extends AnimalPopulationAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimalPopulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimalPopulation[P]>
      : GetScalarType<T[P], AggregateAnimalPopulation[P]>
  }




  export type AnimalPopulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalPopulationWhereInput
    orderBy?: AnimalPopulationOrderByWithAggregationInput | AnimalPopulationOrderByWithAggregationInput[]
    by: AnimalPopulationScalarFieldEnum[] | AnimalPopulationScalarFieldEnum
    having?: AnimalPopulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimalPopulationCountAggregateInputType | true
    _avg?: AnimalPopulationAvgAggregateInputType
    _sum?: AnimalPopulationSumAggregateInputType
    _min?: AnimalPopulationMinAggregateInputType
    _max?: AnimalPopulationMaxAggregateInputType
  }

  export type AnimalPopulationGroupByOutputType = {
    id: number
    species: string
    type: string
    population: number
    areaId: number
    _count: AnimalPopulationCountAggregateOutputType | null
    _avg: AnimalPopulationAvgAggregateOutputType | null
    _sum: AnimalPopulationSumAggregateOutputType | null
    _min: AnimalPopulationMinAggregateOutputType | null
    _max: AnimalPopulationMaxAggregateOutputType | null
  }

  type GetAnimalPopulationGroupByPayload<T extends AnimalPopulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimalPopulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimalPopulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimalPopulationGroupByOutputType[P]>
            : GetScalarType<T[P], AnimalPopulationGroupByOutputType[P]>
        }
      >
    >


  export type AnimalPopulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    species?: boolean
    type?: boolean
    population?: boolean
    areaId?: boolean
    area?: boolean | WildAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animalPopulation"]>

  export type AnimalPopulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    species?: boolean
    type?: boolean
    population?: boolean
    areaId?: boolean
    area?: boolean | WildAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animalPopulation"]>

  export type AnimalPopulationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    species?: boolean
    type?: boolean
    population?: boolean
    areaId?: boolean
    area?: boolean | WildAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animalPopulation"]>

  export type AnimalPopulationSelectScalar = {
    id?: boolean
    species?: boolean
    type?: boolean
    population?: boolean
    areaId?: boolean
  }

  export type AnimalPopulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "species" | "type" | "population" | "areaId", ExtArgs["result"]["animalPopulation"]>
  export type AnimalPopulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | WildAreaDefaultArgs<ExtArgs>
  }
  export type AnimalPopulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | WildAreaDefaultArgs<ExtArgs>
  }
  export type AnimalPopulationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | WildAreaDefaultArgs<ExtArgs>
  }

  export type $AnimalPopulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnimalPopulation"
    objects: {
      area: Prisma.$WildAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      species: string
      type: string
      population: number
      areaId: number
    }, ExtArgs["result"]["animalPopulation"]>
    composites: {}
  }

  type AnimalPopulationGetPayload<S extends boolean | null | undefined | AnimalPopulationDefaultArgs> = $Result.GetResult<Prisma.$AnimalPopulationPayload, S>

  type AnimalPopulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnimalPopulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnimalPopulationCountAggregateInputType | true
    }

  export interface AnimalPopulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnimalPopulation'], meta: { name: 'AnimalPopulation' } }
    /**
     * Find zero or one AnimalPopulation that matches the filter.
     * @param {AnimalPopulationFindUniqueArgs} args - Arguments to find a AnimalPopulation
     * @example
     * // Get one AnimalPopulation
     * const animalPopulation = await prisma.animalPopulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimalPopulationFindUniqueArgs>(args: SelectSubset<T, AnimalPopulationFindUniqueArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnimalPopulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnimalPopulationFindUniqueOrThrowArgs} args - Arguments to find a AnimalPopulation
     * @example
     * // Get one AnimalPopulation
     * const animalPopulation = await prisma.animalPopulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimalPopulationFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimalPopulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnimalPopulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationFindFirstArgs} args - Arguments to find a AnimalPopulation
     * @example
     * // Get one AnimalPopulation
     * const animalPopulation = await prisma.animalPopulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimalPopulationFindFirstArgs>(args?: SelectSubset<T, AnimalPopulationFindFirstArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnimalPopulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationFindFirstOrThrowArgs} args - Arguments to find a AnimalPopulation
     * @example
     * // Get one AnimalPopulation
     * const animalPopulation = await prisma.animalPopulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimalPopulationFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimalPopulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnimalPopulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnimalPopulations
     * const animalPopulations = await prisma.animalPopulation.findMany()
     * 
     * // Get first 10 AnimalPopulations
     * const animalPopulations = await prisma.animalPopulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animalPopulationWithIdOnly = await prisma.animalPopulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnimalPopulationFindManyArgs>(args?: SelectSubset<T, AnimalPopulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnimalPopulation.
     * @param {AnimalPopulationCreateArgs} args - Arguments to create a AnimalPopulation.
     * @example
     * // Create one AnimalPopulation
     * const AnimalPopulation = await prisma.animalPopulation.create({
     *   data: {
     *     // ... data to create a AnimalPopulation
     *   }
     * })
     * 
     */
    create<T extends AnimalPopulationCreateArgs>(args: SelectSubset<T, AnimalPopulationCreateArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnimalPopulations.
     * @param {AnimalPopulationCreateManyArgs} args - Arguments to create many AnimalPopulations.
     * @example
     * // Create many AnimalPopulations
     * const animalPopulation = await prisma.animalPopulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimalPopulationCreateManyArgs>(args?: SelectSubset<T, AnimalPopulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnimalPopulations and returns the data saved in the database.
     * @param {AnimalPopulationCreateManyAndReturnArgs} args - Arguments to create many AnimalPopulations.
     * @example
     * // Create many AnimalPopulations
     * const animalPopulation = await prisma.animalPopulation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnimalPopulations and only return the `id`
     * const animalPopulationWithIdOnly = await prisma.animalPopulation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimalPopulationCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimalPopulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnimalPopulation.
     * @param {AnimalPopulationDeleteArgs} args - Arguments to delete one AnimalPopulation.
     * @example
     * // Delete one AnimalPopulation
     * const AnimalPopulation = await prisma.animalPopulation.delete({
     *   where: {
     *     // ... filter to delete one AnimalPopulation
     *   }
     * })
     * 
     */
    delete<T extends AnimalPopulationDeleteArgs>(args: SelectSubset<T, AnimalPopulationDeleteArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnimalPopulation.
     * @param {AnimalPopulationUpdateArgs} args - Arguments to update one AnimalPopulation.
     * @example
     * // Update one AnimalPopulation
     * const animalPopulation = await prisma.animalPopulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimalPopulationUpdateArgs>(args: SelectSubset<T, AnimalPopulationUpdateArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnimalPopulations.
     * @param {AnimalPopulationDeleteManyArgs} args - Arguments to filter AnimalPopulations to delete.
     * @example
     * // Delete a few AnimalPopulations
     * const { count } = await prisma.animalPopulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimalPopulationDeleteManyArgs>(args?: SelectSubset<T, AnimalPopulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnimalPopulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnimalPopulations
     * const animalPopulation = await prisma.animalPopulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimalPopulationUpdateManyArgs>(args: SelectSubset<T, AnimalPopulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnimalPopulations and returns the data updated in the database.
     * @param {AnimalPopulationUpdateManyAndReturnArgs} args - Arguments to update many AnimalPopulations.
     * @example
     * // Update many AnimalPopulations
     * const animalPopulation = await prisma.animalPopulation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnimalPopulations and only return the `id`
     * const animalPopulationWithIdOnly = await prisma.animalPopulation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnimalPopulationUpdateManyAndReturnArgs>(args: SelectSubset<T, AnimalPopulationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnimalPopulation.
     * @param {AnimalPopulationUpsertArgs} args - Arguments to update or create a AnimalPopulation.
     * @example
     * // Update or create a AnimalPopulation
     * const animalPopulation = await prisma.animalPopulation.upsert({
     *   create: {
     *     // ... data to create a AnimalPopulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnimalPopulation we want to update
     *   }
     * })
     */
    upsert<T extends AnimalPopulationUpsertArgs>(args: SelectSubset<T, AnimalPopulationUpsertArgs<ExtArgs>>): Prisma__AnimalPopulationClient<$Result.GetResult<Prisma.$AnimalPopulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnimalPopulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationCountArgs} args - Arguments to filter AnimalPopulations to count.
     * @example
     * // Count the number of AnimalPopulations
     * const count = await prisma.animalPopulation.count({
     *   where: {
     *     // ... the filter for the AnimalPopulations we want to count
     *   }
     * })
    **/
    count<T extends AnimalPopulationCountArgs>(
      args?: Subset<T, AnimalPopulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimalPopulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnimalPopulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimalPopulationAggregateArgs>(args: Subset<T, AnimalPopulationAggregateArgs>): Prisma.PrismaPromise<GetAnimalPopulationAggregateType<T>>

    /**
     * Group by AnimalPopulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalPopulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimalPopulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimalPopulationGroupByArgs['orderBy'] }
        : { orderBy?: AnimalPopulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimalPopulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimalPopulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnimalPopulation model
   */
  readonly fields: AnimalPopulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnimalPopulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimalPopulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends WildAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WildAreaDefaultArgs<ExtArgs>>): Prisma__WildAreaClient<$Result.GetResult<Prisma.$WildAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnimalPopulation model
   */
  interface AnimalPopulationFieldRefs {
    readonly id: FieldRef<"AnimalPopulation", 'Int'>
    readonly species: FieldRef<"AnimalPopulation", 'String'>
    readonly type: FieldRef<"AnimalPopulation", 'String'>
    readonly population: FieldRef<"AnimalPopulation", 'Int'>
    readonly areaId: FieldRef<"AnimalPopulation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AnimalPopulation findUnique
   */
  export type AnimalPopulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * Filter, which AnimalPopulation to fetch.
     */
    where: AnimalPopulationWhereUniqueInput
  }

  /**
   * AnimalPopulation findUniqueOrThrow
   */
  export type AnimalPopulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * Filter, which AnimalPopulation to fetch.
     */
    where: AnimalPopulationWhereUniqueInput
  }

  /**
   * AnimalPopulation findFirst
   */
  export type AnimalPopulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * Filter, which AnimalPopulation to fetch.
     */
    where?: AnimalPopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalPopulations to fetch.
     */
    orderBy?: AnimalPopulationOrderByWithRelationInput | AnimalPopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnimalPopulations.
     */
    cursor?: AnimalPopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalPopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalPopulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnimalPopulations.
     */
    distinct?: AnimalPopulationScalarFieldEnum | AnimalPopulationScalarFieldEnum[]
  }

  /**
   * AnimalPopulation findFirstOrThrow
   */
  export type AnimalPopulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * Filter, which AnimalPopulation to fetch.
     */
    where?: AnimalPopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalPopulations to fetch.
     */
    orderBy?: AnimalPopulationOrderByWithRelationInput | AnimalPopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnimalPopulations.
     */
    cursor?: AnimalPopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalPopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalPopulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnimalPopulations.
     */
    distinct?: AnimalPopulationScalarFieldEnum | AnimalPopulationScalarFieldEnum[]
  }

  /**
   * AnimalPopulation findMany
   */
  export type AnimalPopulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * Filter, which AnimalPopulations to fetch.
     */
    where?: AnimalPopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalPopulations to fetch.
     */
    orderBy?: AnimalPopulationOrderByWithRelationInput | AnimalPopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnimalPopulations.
     */
    cursor?: AnimalPopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalPopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalPopulations.
     */
    skip?: number
    distinct?: AnimalPopulationScalarFieldEnum | AnimalPopulationScalarFieldEnum[]
  }

  /**
   * AnimalPopulation create
   */
  export type AnimalPopulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * The data needed to create a AnimalPopulation.
     */
    data: XOR<AnimalPopulationCreateInput, AnimalPopulationUncheckedCreateInput>
  }

  /**
   * AnimalPopulation createMany
   */
  export type AnimalPopulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnimalPopulations.
     */
    data: AnimalPopulationCreateManyInput | AnimalPopulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnimalPopulation createManyAndReturn
   */
  export type AnimalPopulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * The data used to create many AnimalPopulations.
     */
    data: AnimalPopulationCreateManyInput | AnimalPopulationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnimalPopulation update
   */
  export type AnimalPopulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * The data needed to update a AnimalPopulation.
     */
    data: XOR<AnimalPopulationUpdateInput, AnimalPopulationUncheckedUpdateInput>
    /**
     * Choose, which AnimalPopulation to update.
     */
    where: AnimalPopulationWhereUniqueInput
  }

  /**
   * AnimalPopulation updateMany
   */
  export type AnimalPopulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnimalPopulations.
     */
    data: XOR<AnimalPopulationUpdateManyMutationInput, AnimalPopulationUncheckedUpdateManyInput>
    /**
     * Filter which AnimalPopulations to update
     */
    where?: AnimalPopulationWhereInput
    /**
     * Limit how many AnimalPopulations to update.
     */
    limit?: number
  }

  /**
   * AnimalPopulation updateManyAndReturn
   */
  export type AnimalPopulationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * The data used to update AnimalPopulations.
     */
    data: XOR<AnimalPopulationUpdateManyMutationInput, AnimalPopulationUncheckedUpdateManyInput>
    /**
     * Filter which AnimalPopulations to update
     */
    where?: AnimalPopulationWhereInput
    /**
     * Limit how many AnimalPopulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnimalPopulation upsert
   */
  export type AnimalPopulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * The filter to search for the AnimalPopulation to update in case it exists.
     */
    where: AnimalPopulationWhereUniqueInput
    /**
     * In case the AnimalPopulation found by the `where` argument doesn't exist, create a new AnimalPopulation with this data.
     */
    create: XOR<AnimalPopulationCreateInput, AnimalPopulationUncheckedCreateInput>
    /**
     * In case the AnimalPopulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimalPopulationUpdateInput, AnimalPopulationUncheckedUpdateInput>
  }

  /**
   * AnimalPopulation delete
   */
  export type AnimalPopulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
    /**
     * Filter which AnimalPopulation to delete.
     */
    where: AnimalPopulationWhereUniqueInput
  }

  /**
   * AnimalPopulation deleteMany
   */
  export type AnimalPopulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnimalPopulations to delete
     */
    where?: AnimalPopulationWhereInput
    /**
     * Limit how many AnimalPopulations to delete.
     */
    limit?: number
  }

  /**
   * AnimalPopulation without action
   */
  export type AnimalPopulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalPopulation
     */
    select?: AnimalPopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalPopulation
     */
    omit?: AnimalPopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalPopulationInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    name: string | null
    isAncient: boolean | null
    region: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isAncient: boolean | null
    region: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    isAncient: number
    region: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
    isAncient?: true
    region?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
    isAncient?: true
    region?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    isAncient?: true
    region?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: number
    name: string
    isAncient: boolean
    region: string | null
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isAncient?: boolean
    region?: boolean
    speakers?: boolean | Language$speakersArgs<ExtArgs>
    userLanguages?: boolean | Language$userLanguagesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isAncient?: boolean
    region?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isAncient?: boolean
    region?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
    isAncient?: boolean
    region?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isAncient" | "region", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speakers?: boolean | Language$speakersArgs<ExtArgs>
    userLanguages?: boolean | Language$userLanguagesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      speakers: Prisma.$NPCPayload<ExtArgs>[]
      userLanguages: Prisma.$UserLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isAncient: boolean
      region: string | null
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    speakers<T extends Language$speakersArgs<ExtArgs> = {}>(args?: Subset<T, Language$speakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLanguages<T extends Language$userLanguagesArgs<ExtArgs> = {}>(args?: Subset<T, Language$userLanguagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'Int'>
    readonly name: FieldRef<"Language", 'String'>
    readonly isAncient: FieldRef<"Language", 'Boolean'>
    readonly region: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.speakers
   */
  export type Language$speakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    cursor?: NPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * Language.userLanguages
   */
  export type Language$userLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    where?: UserLanguageWhereInput
    orderBy?: UserLanguageOrderByWithRelationInput | UserLanguageOrderByWithRelationInput[]
    cursor?: UserLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLanguageScalarFieldEnum | UserLanguageScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model UserLanguage
   */

  export type AggregateUserLanguage = {
    _count: UserLanguageCountAggregateOutputType | null
    _avg: UserLanguageAvgAggregateOutputType | null
    _sum: UserLanguageSumAggregateOutputType | null
    _min: UserLanguageMinAggregateOutputType | null
    _max: UserLanguageMaxAggregateOutputType | null
  }

  export type UserLanguageAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    languageId: number | null
    fluency: number | null
  }

  export type UserLanguageSumAggregateOutputType = {
    id: number | null
    userId: number | null
    languageId: number | null
    fluency: number | null
  }

  export type UserLanguageMinAggregateOutputType = {
    id: number | null
    userId: number | null
    languageId: number | null
    fluency: number | null
  }

  export type UserLanguageMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    languageId: number | null
    fluency: number | null
  }

  export type UserLanguageCountAggregateOutputType = {
    id: number
    userId: number
    languageId: number
    fluency: number
    _all: number
  }


  export type UserLanguageAvgAggregateInputType = {
    id?: true
    userId?: true
    languageId?: true
    fluency?: true
  }

  export type UserLanguageSumAggregateInputType = {
    id?: true
    userId?: true
    languageId?: true
    fluency?: true
  }

  export type UserLanguageMinAggregateInputType = {
    id?: true
    userId?: true
    languageId?: true
    fluency?: true
  }

  export type UserLanguageMaxAggregateInputType = {
    id?: true
    userId?: true
    languageId?: true
    fluency?: true
  }

  export type UserLanguageCountAggregateInputType = {
    id?: true
    userId?: true
    languageId?: true
    fluency?: true
    _all?: true
  }

  export type UserLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLanguage to aggregate.
     */
    where?: UserLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLanguages to fetch.
     */
    orderBy?: UserLanguageOrderByWithRelationInput | UserLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLanguages
    **/
    _count?: true | UserLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLanguageMaxAggregateInputType
  }

  export type GetUserLanguageAggregateType<T extends UserLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLanguage[P]>
      : GetScalarType<T[P], AggregateUserLanguage[P]>
  }




  export type UserLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLanguageWhereInput
    orderBy?: UserLanguageOrderByWithAggregationInput | UserLanguageOrderByWithAggregationInput[]
    by: UserLanguageScalarFieldEnum[] | UserLanguageScalarFieldEnum
    having?: UserLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLanguageCountAggregateInputType | true
    _avg?: UserLanguageAvgAggregateInputType
    _sum?: UserLanguageSumAggregateInputType
    _min?: UserLanguageMinAggregateInputType
    _max?: UserLanguageMaxAggregateInputType
  }

  export type UserLanguageGroupByOutputType = {
    id: number
    userId: number
    languageId: number
    fluency: number
    _count: UserLanguageCountAggregateOutputType | null
    _avg: UserLanguageAvgAggregateOutputType | null
    _sum: UserLanguageSumAggregateOutputType | null
    _min: UserLanguageMinAggregateOutputType | null
    _max: UserLanguageMaxAggregateOutputType | null
  }

  type GetUserLanguageGroupByPayload<T extends UserLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], UserLanguageGroupByOutputType[P]>
        }
      >
    >


  export type UserLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    languageId?: boolean
    fluency?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLanguage"]>

  export type UserLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    languageId?: boolean
    fluency?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLanguage"]>

  export type UserLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    languageId?: boolean
    fluency?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLanguage"]>

  export type UserLanguageSelectScalar = {
    id?: boolean
    userId?: boolean
    languageId?: boolean
    fluency?: boolean
  }

  export type UserLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "languageId" | "fluency", ExtArgs["result"]["userLanguage"]>
  export type UserLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type UserLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type UserLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $UserLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLanguage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      languageId: number
      fluency: number
    }, ExtArgs["result"]["userLanguage"]>
    composites: {}
  }

  type UserLanguageGetPayload<S extends boolean | null | undefined | UserLanguageDefaultArgs> = $Result.GetResult<Prisma.$UserLanguagePayload, S>

  type UserLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLanguageCountAggregateInputType | true
    }

  export interface UserLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLanguage'], meta: { name: 'UserLanguage' } }
    /**
     * Find zero or one UserLanguage that matches the filter.
     * @param {UserLanguageFindUniqueArgs} args - Arguments to find a UserLanguage
     * @example
     * // Get one UserLanguage
     * const userLanguage = await prisma.userLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLanguageFindUniqueArgs>(args: SelectSubset<T, UserLanguageFindUniqueArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLanguageFindUniqueOrThrowArgs} args - Arguments to find a UserLanguage
     * @example
     * // Get one UserLanguage
     * const userLanguage = await prisma.userLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageFindFirstArgs} args - Arguments to find a UserLanguage
     * @example
     * // Get one UserLanguage
     * const userLanguage = await prisma.userLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLanguageFindFirstArgs>(args?: SelectSubset<T, UserLanguageFindFirstArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageFindFirstOrThrowArgs} args - Arguments to find a UserLanguage
     * @example
     * // Get one UserLanguage
     * const userLanguage = await prisma.userLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLanguages
     * const userLanguages = await prisma.userLanguage.findMany()
     * 
     * // Get first 10 UserLanguages
     * const userLanguages = await prisma.userLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLanguageWithIdOnly = await prisma.userLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLanguageFindManyArgs>(args?: SelectSubset<T, UserLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLanguage.
     * @param {UserLanguageCreateArgs} args - Arguments to create a UserLanguage.
     * @example
     * // Create one UserLanguage
     * const UserLanguage = await prisma.userLanguage.create({
     *   data: {
     *     // ... data to create a UserLanguage
     *   }
     * })
     * 
     */
    create<T extends UserLanguageCreateArgs>(args: SelectSubset<T, UserLanguageCreateArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLanguages.
     * @param {UserLanguageCreateManyArgs} args - Arguments to create many UserLanguages.
     * @example
     * // Create many UserLanguages
     * const userLanguage = await prisma.userLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLanguageCreateManyArgs>(args?: SelectSubset<T, UserLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLanguages and returns the data saved in the database.
     * @param {UserLanguageCreateManyAndReturnArgs} args - Arguments to create many UserLanguages.
     * @example
     * // Create many UserLanguages
     * const userLanguage = await prisma.userLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLanguages and only return the `id`
     * const userLanguageWithIdOnly = await prisma.userLanguage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLanguage.
     * @param {UserLanguageDeleteArgs} args - Arguments to delete one UserLanguage.
     * @example
     * // Delete one UserLanguage
     * const UserLanguage = await prisma.userLanguage.delete({
     *   where: {
     *     // ... filter to delete one UserLanguage
     *   }
     * })
     * 
     */
    delete<T extends UserLanguageDeleteArgs>(args: SelectSubset<T, UserLanguageDeleteArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLanguage.
     * @param {UserLanguageUpdateArgs} args - Arguments to update one UserLanguage.
     * @example
     * // Update one UserLanguage
     * const userLanguage = await prisma.userLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLanguageUpdateArgs>(args: SelectSubset<T, UserLanguageUpdateArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLanguages.
     * @param {UserLanguageDeleteManyArgs} args - Arguments to filter UserLanguages to delete.
     * @example
     * // Delete a few UserLanguages
     * const { count } = await prisma.userLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLanguageDeleteManyArgs>(args?: SelectSubset<T, UserLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLanguages
     * const userLanguage = await prisma.userLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLanguageUpdateManyArgs>(args: SelectSubset<T, UserLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLanguages and returns the data updated in the database.
     * @param {UserLanguageUpdateManyAndReturnArgs} args - Arguments to update many UserLanguages.
     * @example
     * // Update many UserLanguages
     * const userLanguage = await prisma.userLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLanguages and only return the `id`
     * const userLanguageWithIdOnly = await prisma.userLanguage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLanguage.
     * @param {UserLanguageUpsertArgs} args - Arguments to update or create a UserLanguage.
     * @example
     * // Update or create a UserLanguage
     * const userLanguage = await prisma.userLanguage.upsert({
     *   create: {
     *     // ... data to create a UserLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLanguage we want to update
     *   }
     * })
     */
    upsert<T extends UserLanguageUpsertArgs>(args: SelectSubset<T, UserLanguageUpsertArgs<ExtArgs>>): Prisma__UserLanguageClient<$Result.GetResult<Prisma.$UserLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageCountArgs} args - Arguments to filter UserLanguages to count.
     * @example
     * // Count the number of UserLanguages
     * const count = await prisma.userLanguage.count({
     *   where: {
     *     // ... the filter for the UserLanguages we want to count
     *   }
     * })
    **/
    count<T extends UserLanguageCountArgs>(
      args?: Subset<T, UserLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLanguageAggregateArgs>(args: Subset<T, UserLanguageAggregateArgs>): Prisma.PrismaPromise<GetUserLanguageAggregateType<T>>

    /**
     * Group by UserLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLanguageGroupByArgs['orderBy'] }
        : { orderBy?: UserLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLanguage model
   */
  readonly fields: UserLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLanguage model
   */
  interface UserLanguageFieldRefs {
    readonly id: FieldRef<"UserLanguage", 'Int'>
    readonly userId: FieldRef<"UserLanguage", 'Int'>
    readonly languageId: FieldRef<"UserLanguage", 'Int'>
    readonly fluency: FieldRef<"UserLanguage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserLanguage findUnique
   */
  export type UserLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * Filter, which UserLanguage to fetch.
     */
    where: UserLanguageWhereUniqueInput
  }

  /**
   * UserLanguage findUniqueOrThrow
   */
  export type UserLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * Filter, which UserLanguage to fetch.
     */
    where: UserLanguageWhereUniqueInput
  }

  /**
   * UserLanguage findFirst
   */
  export type UserLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * Filter, which UserLanguage to fetch.
     */
    where?: UserLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLanguages to fetch.
     */
    orderBy?: UserLanguageOrderByWithRelationInput | UserLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLanguages.
     */
    cursor?: UserLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLanguages.
     */
    distinct?: UserLanguageScalarFieldEnum | UserLanguageScalarFieldEnum[]
  }

  /**
   * UserLanguage findFirstOrThrow
   */
  export type UserLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * Filter, which UserLanguage to fetch.
     */
    where?: UserLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLanguages to fetch.
     */
    orderBy?: UserLanguageOrderByWithRelationInput | UserLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLanguages.
     */
    cursor?: UserLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLanguages.
     */
    distinct?: UserLanguageScalarFieldEnum | UserLanguageScalarFieldEnum[]
  }

  /**
   * UserLanguage findMany
   */
  export type UserLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * Filter, which UserLanguages to fetch.
     */
    where?: UserLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLanguages to fetch.
     */
    orderBy?: UserLanguageOrderByWithRelationInput | UserLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLanguages.
     */
    cursor?: UserLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLanguages.
     */
    skip?: number
    distinct?: UserLanguageScalarFieldEnum | UserLanguageScalarFieldEnum[]
  }

  /**
   * UserLanguage create
   */
  export type UserLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLanguage.
     */
    data: XOR<UserLanguageCreateInput, UserLanguageUncheckedCreateInput>
  }

  /**
   * UserLanguage createMany
   */
  export type UserLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLanguages.
     */
    data: UserLanguageCreateManyInput | UserLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLanguage createManyAndReturn
   */
  export type UserLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many UserLanguages.
     */
    data: UserLanguageCreateManyInput | UserLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLanguage update
   */
  export type UserLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLanguage.
     */
    data: XOR<UserLanguageUpdateInput, UserLanguageUncheckedUpdateInput>
    /**
     * Choose, which UserLanguage to update.
     */
    where: UserLanguageWhereUniqueInput
  }

  /**
   * UserLanguage updateMany
   */
  export type UserLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLanguages.
     */
    data: XOR<UserLanguageUpdateManyMutationInput, UserLanguageUncheckedUpdateManyInput>
    /**
     * Filter which UserLanguages to update
     */
    where?: UserLanguageWhereInput
    /**
     * Limit how many UserLanguages to update.
     */
    limit?: number
  }

  /**
   * UserLanguage updateManyAndReturn
   */
  export type UserLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * The data used to update UserLanguages.
     */
    data: XOR<UserLanguageUpdateManyMutationInput, UserLanguageUncheckedUpdateManyInput>
    /**
     * Filter which UserLanguages to update
     */
    where?: UserLanguageWhereInput
    /**
     * Limit how many UserLanguages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLanguage upsert
   */
  export type UserLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLanguage to update in case it exists.
     */
    where: UserLanguageWhereUniqueInput
    /**
     * In case the UserLanguage found by the `where` argument doesn't exist, create a new UserLanguage with this data.
     */
    create: XOR<UserLanguageCreateInput, UserLanguageUncheckedCreateInput>
    /**
     * In case the UserLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLanguageUpdateInput, UserLanguageUncheckedUpdateInput>
  }

  /**
   * UserLanguage delete
   */
  export type UserLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
    /**
     * Filter which UserLanguage to delete.
     */
    where: UserLanguageWhereUniqueInput
  }

  /**
   * UserLanguage deleteMany
   */
  export type UserLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLanguages to delete
     */
    where?: UserLanguageWhereInput
    /**
     * Limit how many UserLanguages to delete.
     */
    limit?: number
  }

  /**
   * UserLanguage without action
   */
  export type UserLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLanguage
     */
    select?: UserLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLanguage
     */
    omit?: UserLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLanguageInclude<ExtArgs> | null
  }


  /**
   * Model Religion
   */

  export type AggregateReligion = {
    _count: ReligionCountAggregateOutputType | null
    _avg: ReligionAvgAggregateOutputType | null
    _sum: ReligionSumAggregateOutputType | null
    _min: ReligionMinAggregateOutputType | null
    _max: ReligionMaxAggregateOutputType | null
  }

  export type ReligionAvgAggregateOutputType = {
    id: number | null
    influenceLevel: number | null
    estimatedFollowers: number | null
  }

  export type ReligionSumAggregateOutputType = {
    id: number | null
    influenceLevel: number | null
    estimatedFollowers: number | null
  }

  export type ReligionMinAggregateOutputType = {
    id: number | null
    name: string | null
    originRegion: string | null
    description: string | null
    doctrine: string | null
    influenceLevel: number | null
    estimatedFollowers: number | null
  }

  export type ReligionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    originRegion: string | null
    description: string | null
    doctrine: string | null
    influenceLevel: number | null
    estimatedFollowers: number | null
  }

  export type ReligionCountAggregateOutputType = {
    id: number
    name: number
    originRegion: number
    description: number
    doctrine: number
    influenceLevel: number
    estimatedFollowers: number
    _all: number
  }


  export type ReligionAvgAggregateInputType = {
    id?: true
    influenceLevel?: true
    estimatedFollowers?: true
  }

  export type ReligionSumAggregateInputType = {
    id?: true
    influenceLevel?: true
    estimatedFollowers?: true
  }

  export type ReligionMinAggregateInputType = {
    id?: true
    name?: true
    originRegion?: true
    description?: true
    doctrine?: true
    influenceLevel?: true
    estimatedFollowers?: true
  }

  export type ReligionMaxAggregateInputType = {
    id?: true
    name?: true
    originRegion?: true
    description?: true
    doctrine?: true
    influenceLevel?: true
    estimatedFollowers?: true
  }

  export type ReligionCountAggregateInputType = {
    id?: true
    name?: true
    originRegion?: true
    description?: true
    doctrine?: true
    influenceLevel?: true
    estimatedFollowers?: true
    _all?: true
  }

  export type ReligionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Religion to aggregate.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Religions
    **/
    _count?: true | ReligionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReligionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReligionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReligionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReligionMaxAggregateInputType
  }

  export type GetReligionAggregateType<T extends ReligionAggregateArgs> = {
        [P in keyof T & keyof AggregateReligion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReligion[P]>
      : GetScalarType<T[P], AggregateReligion[P]>
  }




  export type ReligionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReligionWhereInput
    orderBy?: ReligionOrderByWithAggregationInput | ReligionOrderByWithAggregationInput[]
    by: ReligionScalarFieldEnum[] | ReligionScalarFieldEnum
    having?: ReligionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReligionCountAggregateInputType | true
    _avg?: ReligionAvgAggregateInputType
    _sum?: ReligionSumAggregateInputType
    _min?: ReligionMinAggregateInputType
    _max?: ReligionMaxAggregateInputType
  }

  export type ReligionGroupByOutputType = {
    id: number
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    _count: ReligionCountAggregateOutputType | null
    _avg: ReligionAvgAggregateOutputType | null
    _sum: ReligionSumAggregateOutputType | null
    _min: ReligionMinAggregateOutputType | null
    _max: ReligionMaxAggregateOutputType | null
  }

  type GetReligionGroupByPayload<T extends ReligionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReligionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReligionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReligionGroupByOutputType[P]>
            : GetScalarType<T[P], ReligionGroupByOutputType[P]>
        }
      >
    >


  export type ReligionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originRegion?: boolean
    description?: boolean
    doctrine?: boolean
    influenceLevel?: boolean
    estimatedFollowers?: boolean
    artifacts?: boolean | Religion$artifactsArgs<ExtArgs>
    followers?: boolean | Religion$followersArgs<ExtArgs>
    _count?: boolean | ReligionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["religion"]>

  export type ReligionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originRegion?: boolean
    description?: boolean
    doctrine?: boolean
    influenceLevel?: boolean
    estimatedFollowers?: boolean
  }, ExtArgs["result"]["religion"]>

  export type ReligionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originRegion?: boolean
    description?: boolean
    doctrine?: boolean
    influenceLevel?: boolean
    estimatedFollowers?: boolean
  }, ExtArgs["result"]["religion"]>

  export type ReligionSelectScalar = {
    id?: boolean
    name?: boolean
    originRegion?: boolean
    description?: boolean
    doctrine?: boolean
    influenceLevel?: boolean
    estimatedFollowers?: boolean
  }

  export type ReligionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "originRegion" | "description" | "doctrine" | "influenceLevel" | "estimatedFollowers", ExtArgs["result"]["religion"]>
  export type ReligionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | Religion$artifactsArgs<ExtArgs>
    followers?: boolean | Religion$followersArgs<ExtArgs>
    _count?: boolean | ReligionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReligionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ReligionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReligionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Religion"
    objects: {
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      followers: Prisma.$NPCPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      originRegion: string
      description: string
      doctrine: string
      influenceLevel: number
      estimatedFollowers: number
    }, ExtArgs["result"]["religion"]>
    composites: {}
  }

  type ReligionGetPayload<S extends boolean | null | undefined | ReligionDefaultArgs> = $Result.GetResult<Prisma.$ReligionPayload, S>

  type ReligionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReligionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReligionCountAggregateInputType | true
    }

  export interface ReligionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Religion'], meta: { name: 'Religion' } }
    /**
     * Find zero or one Religion that matches the filter.
     * @param {ReligionFindUniqueArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReligionFindUniqueArgs>(args: SelectSubset<T, ReligionFindUniqueArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Religion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReligionFindUniqueOrThrowArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReligionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReligionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Religion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindFirstArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReligionFindFirstArgs>(args?: SelectSubset<T, ReligionFindFirstArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Religion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindFirstOrThrowArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReligionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReligionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Religions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Religions
     * const religions = await prisma.religion.findMany()
     * 
     * // Get first 10 Religions
     * const religions = await prisma.religion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const religionWithIdOnly = await prisma.religion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReligionFindManyArgs>(args?: SelectSubset<T, ReligionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Religion.
     * @param {ReligionCreateArgs} args - Arguments to create a Religion.
     * @example
     * // Create one Religion
     * const Religion = await prisma.religion.create({
     *   data: {
     *     // ... data to create a Religion
     *   }
     * })
     * 
     */
    create<T extends ReligionCreateArgs>(args: SelectSubset<T, ReligionCreateArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Religions.
     * @param {ReligionCreateManyArgs} args - Arguments to create many Religions.
     * @example
     * // Create many Religions
     * const religion = await prisma.religion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReligionCreateManyArgs>(args?: SelectSubset<T, ReligionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Religions and returns the data saved in the database.
     * @param {ReligionCreateManyAndReturnArgs} args - Arguments to create many Religions.
     * @example
     * // Create many Religions
     * const religion = await prisma.religion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Religions and only return the `id`
     * const religionWithIdOnly = await prisma.religion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReligionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReligionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Religion.
     * @param {ReligionDeleteArgs} args - Arguments to delete one Religion.
     * @example
     * // Delete one Religion
     * const Religion = await prisma.religion.delete({
     *   where: {
     *     // ... filter to delete one Religion
     *   }
     * })
     * 
     */
    delete<T extends ReligionDeleteArgs>(args: SelectSubset<T, ReligionDeleteArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Religion.
     * @param {ReligionUpdateArgs} args - Arguments to update one Religion.
     * @example
     * // Update one Religion
     * const religion = await prisma.religion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReligionUpdateArgs>(args: SelectSubset<T, ReligionUpdateArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Religions.
     * @param {ReligionDeleteManyArgs} args - Arguments to filter Religions to delete.
     * @example
     * // Delete a few Religions
     * const { count } = await prisma.religion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReligionDeleteManyArgs>(args?: SelectSubset<T, ReligionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Religions
     * const religion = await prisma.religion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReligionUpdateManyArgs>(args: SelectSubset<T, ReligionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Religions and returns the data updated in the database.
     * @param {ReligionUpdateManyAndReturnArgs} args - Arguments to update many Religions.
     * @example
     * // Update many Religions
     * const religion = await prisma.religion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Religions and only return the `id`
     * const religionWithIdOnly = await prisma.religion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReligionUpdateManyAndReturnArgs>(args: SelectSubset<T, ReligionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Religion.
     * @param {ReligionUpsertArgs} args - Arguments to update or create a Religion.
     * @example
     * // Update or create a Religion
     * const religion = await prisma.religion.upsert({
     *   create: {
     *     // ... data to create a Religion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Religion we want to update
     *   }
     * })
     */
    upsert<T extends ReligionUpsertArgs>(args: SelectSubset<T, ReligionUpsertArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionCountArgs} args - Arguments to filter Religions to count.
     * @example
     * // Count the number of Religions
     * const count = await prisma.religion.count({
     *   where: {
     *     // ... the filter for the Religions we want to count
     *   }
     * })
    **/
    count<T extends ReligionCountArgs>(
      args?: Subset<T, ReligionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReligionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Religion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReligionAggregateArgs>(args: Subset<T, ReligionAggregateArgs>): Prisma.PrismaPromise<GetReligionAggregateType<T>>

    /**
     * Group by Religion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReligionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReligionGroupByArgs['orderBy'] }
        : { orderBy?: ReligionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReligionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReligionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Religion model
   */
  readonly fields: ReligionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Religion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReligionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifacts<T extends Religion$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Religion$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends Religion$followersArgs<ExtArgs> = {}>(args?: Subset<T, Religion$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Religion model
   */
  interface ReligionFieldRefs {
    readonly id: FieldRef<"Religion", 'Int'>
    readonly name: FieldRef<"Religion", 'String'>
    readonly originRegion: FieldRef<"Religion", 'String'>
    readonly description: FieldRef<"Religion", 'String'>
    readonly doctrine: FieldRef<"Religion", 'String'>
    readonly influenceLevel: FieldRef<"Religion", 'Int'>
    readonly estimatedFollowers: FieldRef<"Religion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Religion findUnique
   */
  export type ReligionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion findUniqueOrThrow
   */
  export type ReligionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion findFirst
   */
  export type ReligionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Religions.
     */
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion findFirstOrThrow
   */
  export type ReligionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Religions.
     */
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion findMany
   */
  export type ReligionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religions to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion create
   */
  export type ReligionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The data needed to create a Religion.
     */
    data: XOR<ReligionCreateInput, ReligionUncheckedCreateInput>
  }

  /**
   * Religion createMany
   */
  export type ReligionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Religions.
     */
    data: ReligionCreateManyInput | ReligionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Religion createManyAndReturn
   */
  export type ReligionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * The data used to create many Religions.
     */
    data: ReligionCreateManyInput | ReligionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Religion update
   */
  export type ReligionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The data needed to update a Religion.
     */
    data: XOR<ReligionUpdateInput, ReligionUncheckedUpdateInput>
    /**
     * Choose, which Religion to update.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion updateMany
   */
  export type ReligionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Religions.
     */
    data: XOR<ReligionUpdateManyMutationInput, ReligionUncheckedUpdateManyInput>
    /**
     * Filter which Religions to update
     */
    where?: ReligionWhereInput
    /**
     * Limit how many Religions to update.
     */
    limit?: number
  }

  /**
   * Religion updateManyAndReturn
   */
  export type ReligionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * The data used to update Religions.
     */
    data: XOR<ReligionUpdateManyMutationInput, ReligionUncheckedUpdateManyInput>
    /**
     * Filter which Religions to update
     */
    where?: ReligionWhereInput
    /**
     * Limit how many Religions to update.
     */
    limit?: number
  }

  /**
   * Religion upsert
   */
  export type ReligionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The filter to search for the Religion to update in case it exists.
     */
    where: ReligionWhereUniqueInput
    /**
     * In case the Religion found by the `where` argument doesn't exist, create a new Religion with this data.
     */
    create: XOR<ReligionCreateInput, ReligionUncheckedCreateInput>
    /**
     * In case the Religion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReligionUpdateInput, ReligionUncheckedUpdateInput>
  }

  /**
   * Religion delete
   */
  export type ReligionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter which Religion to delete.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion deleteMany
   */
  export type ReligionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Religions to delete
     */
    where?: ReligionWhereInput
    /**
     * Limit how many Religions to delete.
     */
    limit?: number
  }

  /**
   * Religion.artifacts
   */
  export type Religion$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Religion.followers
   */
  export type Religion$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    cursor?: NPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * Religion without action
   */
  export type ReligionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Religion
     */
    omit?: ReligionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
  }


  /**
   * Model Artifact
   */

  export type AggregateArtifact = {
    _count: ArtifactCountAggregateOutputType | null
    _avg: ArtifactAvgAggregateOutputType | null
    _sum: ArtifactSumAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  export type ArtifactAvgAggregateOutputType = {
    id: number | null
    religionId: number | null
  }

  export type ArtifactSumAggregateOutputType = {
    id: number | null
    religionId: number | null
  }

  export type ArtifactMinAggregateOutputType = {
    id: number | null
    name: string | null
    lore: string | null
    powerHint: string | null
    religionId: number | null
  }

  export type ArtifactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lore: string | null
    powerHint: string | null
    religionId: number | null
  }

  export type ArtifactCountAggregateOutputType = {
    id: number
    name: number
    lore: number
    powerHint: number
    religionId: number
    _all: number
  }


  export type ArtifactAvgAggregateInputType = {
    id?: true
    religionId?: true
  }

  export type ArtifactSumAggregateInputType = {
    id?: true
    religionId?: true
  }

  export type ArtifactMinAggregateInputType = {
    id?: true
    name?: true
    lore?: true
    powerHint?: true
    religionId?: true
  }

  export type ArtifactMaxAggregateInputType = {
    id?: true
    name?: true
    lore?: true
    powerHint?: true
    religionId?: true
  }

  export type ArtifactCountAggregateInputType = {
    id?: true
    name?: true
    lore?: true
    powerHint?: true
    religionId?: true
    _all?: true
  }

  export type ArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifact to aggregate.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artifacts
    **/
    _count?: true | ArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactMaxAggregateInputType
  }

  export type GetArtifactAggregateType<T extends ArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifact[P]>
      : GetScalarType<T[P], AggregateArtifact[P]>
  }




  export type ArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithAggregationInput | ArtifactOrderByWithAggregationInput[]
    by: ArtifactScalarFieldEnum[] | ArtifactScalarFieldEnum
    having?: ArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactCountAggregateInputType | true
    _avg?: ArtifactAvgAggregateInputType
    _sum?: ArtifactSumAggregateInputType
    _min?: ArtifactMinAggregateInputType
    _max?: ArtifactMaxAggregateInputType
  }

  export type ArtifactGroupByOutputType = {
    id: number
    name: string
    lore: string
    powerHint: string
    religionId: number
    _count: ArtifactCountAggregateOutputType | null
    _avg: ArtifactAvgAggregateOutputType | null
    _sum: ArtifactSumAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  type GetArtifactGroupByPayload<T extends ArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lore?: boolean
    powerHint?: boolean
    religionId?: boolean
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lore?: boolean
    powerHint?: boolean
    religionId?: boolean
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lore?: boolean
    powerHint?: boolean
    religionId?: boolean
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectScalar = {
    id?: boolean
    name?: boolean
    lore?: boolean
    powerHint?: boolean
    religionId?: boolean
  }

  export type ArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "lore" | "powerHint" | "religionId", ExtArgs["result"]["artifact"]>
  export type ArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }
  export type ArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }
  export type ArtifactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }

  export type $ArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artifact"
    objects: {
      religion: Prisma.$ReligionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      lore: string
      powerHint: string
      religionId: number
    }, ExtArgs["result"]["artifact"]>
    composites: {}
  }

  type ArtifactGetPayload<S extends boolean | null | undefined | ArtifactDefaultArgs> = $Result.GetResult<Prisma.$ArtifactPayload, S>

  type ArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtifactCountAggregateInputType | true
    }

  export interface ArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artifact'], meta: { name: 'Artifact' } }
    /**
     * Find zero or one Artifact that matches the filter.
     * @param {ArtifactFindUniqueArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactFindUniqueArgs>(args: SelectSubset<T, ArtifactFindUniqueArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtifactFindUniqueOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactFindFirstArgs>(args?: SelectSubset<T, ArtifactFindFirstArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artifacts
     * const artifacts = await prisma.artifact.findMany()
     * 
     * // Get first 10 Artifacts
     * const artifacts = await prisma.artifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artifactWithIdOnly = await prisma.artifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtifactFindManyArgs>(args?: SelectSubset<T, ArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artifact.
     * @param {ArtifactCreateArgs} args - Arguments to create a Artifact.
     * @example
     * // Create one Artifact
     * const Artifact = await prisma.artifact.create({
     *   data: {
     *     // ... data to create a Artifact
     *   }
     * })
     * 
     */
    create<T extends ArtifactCreateArgs>(args: SelectSubset<T, ArtifactCreateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artifacts.
     * @param {ArtifactCreateManyArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactCreateManyArgs>(args?: SelectSubset<T, ArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artifacts and returns the data saved in the database.
     * @param {ArtifactCreateManyAndReturnArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artifact.
     * @param {ArtifactDeleteArgs} args - Arguments to delete one Artifact.
     * @example
     * // Delete one Artifact
     * const Artifact = await prisma.artifact.delete({
     *   where: {
     *     // ... filter to delete one Artifact
     *   }
     * })
     * 
     */
    delete<T extends ArtifactDeleteArgs>(args: SelectSubset<T, ArtifactDeleteArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artifact.
     * @param {ArtifactUpdateArgs} args - Arguments to update one Artifact.
     * @example
     * // Update one Artifact
     * const artifact = await prisma.artifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactUpdateArgs>(args: SelectSubset<T, ArtifactUpdateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artifacts.
     * @param {ArtifactDeleteManyArgs} args - Arguments to filter Artifacts to delete.
     * @example
     * // Delete a few Artifacts
     * const { count } = await prisma.artifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactDeleteManyArgs>(args?: SelectSubset<T, ArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactUpdateManyArgs>(args: SelectSubset<T, ArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts and returns the data updated in the database.
     * @param {ArtifactUpdateManyAndReturnArgs} args - Arguments to update many Artifacts.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artifact.
     * @param {ArtifactUpsertArgs} args - Arguments to update or create a Artifact.
     * @example
     * // Update or create a Artifact
     * const artifact = await prisma.artifact.upsert({
     *   create: {
     *     // ... data to create a Artifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artifact we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactUpsertArgs>(args: SelectSubset<T, ArtifactUpsertArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCountArgs} args - Arguments to filter Artifacts to count.
     * @example
     * // Count the number of Artifacts
     * const count = await prisma.artifact.count({
     *   where: {
     *     // ... the filter for the Artifacts we want to count
     *   }
     * })
    **/
    count<T extends ArtifactCountArgs>(
      args?: Subset<T, ArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactAggregateArgs>(args: Subset<T, ArtifactAggregateArgs>): Prisma.PrismaPromise<GetArtifactAggregateType<T>>

    /**
     * Group by Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artifact model
   */
  readonly fields: ArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    religion<T extends ReligionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReligionDefaultArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artifact model
   */
  interface ArtifactFieldRefs {
    readonly id: FieldRef<"Artifact", 'Int'>
    readonly name: FieldRef<"Artifact", 'String'>
    readonly lore: FieldRef<"Artifact", 'String'>
    readonly powerHint: FieldRef<"Artifact", 'String'>
    readonly religionId: FieldRef<"Artifact", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Artifact findUnique
   */
  export type ArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findUniqueOrThrow
   */
  export type ArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findFirst
   */
  export type ArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findFirstOrThrow
   */
  export type ArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findMany
   */
  export type ArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifacts to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact create
   */
  export type ArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a Artifact.
     */
    data: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
  }

  /**
   * Artifact createMany
   */
  export type ArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artifact createManyAndReturn
   */
  export type ArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact update
   */
  export type ArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a Artifact.
     */
    data: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
    /**
     * Choose, which Artifact to update.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact updateMany
   */
  export type ArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to update.
     */
    limit?: number
  }

  /**
   * Artifact updateManyAndReturn
   */
  export type ArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact upsert
   */
  export type ArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the Artifact to update in case it exists.
     */
    where: ArtifactWhereUniqueInput
    /**
     * In case the Artifact found by the `where` argument doesn't exist, create a new Artifact with this data.
     */
    create: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
    /**
     * In case the Artifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
  }

  /**
   * Artifact delete
   */
  export type ArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter which Artifact to delete.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact deleteMany
   */
  export type ArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifacts to delete
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to delete.
     */
    limit?: number
  }

  /**
   * Artifact without action
   */
  export type ArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
  }


  /**
   * Model GlobalEvent
   */

  export type AggregateGlobalEvent = {
    _count: GlobalEventCountAggregateOutputType | null
    _avg: GlobalEventAvgAggregateOutputType | null
    _sum: GlobalEventSumAggregateOutputType | null
    _min: GlobalEventMinAggregateOutputType | null
    _max: GlobalEventMaxAggregateOutputType | null
  }

  export type GlobalEventAvgAggregateOutputType = {
    id: number | null
    durationDays: number | null
  }

  export type GlobalEventSumAggregateOutputType = {
    id: number | null
    durationDays: number | null
  }

  export type GlobalEventMinAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    affectedRegion: string | null
    description: string | null
    durationDays: number | null
    impact: string | null
    isActive: boolean | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type GlobalEventMaxAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    affectedRegion: string | null
    description: string | null
    durationDays: number | null
    impact: string | null
    isActive: boolean | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type GlobalEventCountAggregateOutputType = {
    id: number
    title: number
    type: number
    affectedRegion: number
    description: number
    durationDays: number
    impact: number
    isActive: number
    startedAt: number
    endedAt: number
    _all: number
  }


  export type GlobalEventAvgAggregateInputType = {
    id?: true
    durationDays?: true
  }

  export type GlobalEventSumAggregateInputType = {
    id?: true
    durationDays?: true
  }

  export type GlobalEventMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    affectedRegion?: true
    description?: true
    durationDays?: true
    impact?: true
    isActive?: true
    startedAt?: true
    endedAt?: true
  }

  export type GlobalEventMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    affectedRegion?: true
    description?: true
    durationDays?: true
    impact?: true
    isActive?: true
    startedAt?: true
    endedAt?: true
  }

  export type GlobalEventCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    affectedRegion?: true
    description?: true
    durationDays?: true
    impact?: true
    isActive?: true
    startedAt?: true
    endedAt?: true
    _all?: true
  }

  export type GlobalEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalEvent to aggregate.
     */
    where?: GlobalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalEvents to fetch.
     */
    orderBy?: GlobalEventOrderByWithRelationInput | GlobalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalEvents
    **/
    _count?: true | GlobalEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GlobalEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GlobalEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalEventMaxAggregateInputType
  }

  export type GetGlobalEventAggregateType<T extends GlobalEventAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalEvent[P]>
      : GetScalarType<T[P], AggregateGlobalEvent[P]>
  }




  export type GlobalEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalEventWhereInput
    orderBy?: GlobalEventOrderByWithAggregationInput | GlobalEventOrderByWithAggregationInput[]
    by: GlobalEventScalarFieldEnum[] | GlobalEventScalarFieldEnum
    having?: GlobalEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalEventCountAggregateInputType | true
    _avg?: GlobalEventAvgAggregateInputType
    _sum?: GlobalEventSumAggregateInputType
    _min?: GlobalEventMinAggregateInputType
    _max?: GlobalEventMaxAggregateInputType
  }

  export type GlobalEventGroupByOutputType = {
    id: number
    title: string
    type: string
    affectedRegion: string
    description: string
    durationDays: number
    impact: string
    isActive: boolean
    startedAt: Date
    endedAt: Date | null
    _count: GlobalEventCountAggregateOutputType | null
    _avg: GlobalEventAvgAggregateOutputType | null
    _sum: GlobalEventSumAggregateOutputType | null
    _min: GlobalEventMinAggregateOutputType | null
    _max: GlobalEventMaxAggregateOutputType | null
  }

  type GetGlobalEventGroupByPayload<T extends GlobalEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalEventGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalEventGroupByOutputType[P]>
        }
      >
    >


  export type GlobalEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    affectedRegion?: boolean
    description?: boolean
    durationDays?: boolean
    impact?: boolean
    isActive?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }, ExtArgs["result"]["globalEvent"]>

  export type GlobalEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    affectedRegion?: boolean
    description?: boolean
    durationDays?: boolean
    impact?: boolean
    isActive?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }, ExtArgs["result"]["globalEvent"]>

  export type GlobalEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    affectedRegion?: boolean
    description?: boolean
    durationDays?: boolean
    impact?: boolean
    isActive?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }, ExtArgs["result"]["globalEvent"]>

  export type GlobalEventSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    affectedRegion?: boolean
    description?: boolean
    durationDays?: boolean
    impact?: boolean
    isActive?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }

  export type GlobalEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "affectedRegion" | "description" | "durationDays" | "impact" | "isActive" | "startedAt" | "endedAt", ExtArgs["result"]["globalEvent"]>

  export type $GlobalEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      type: string
      affectedRegion: string
      description: string
      durationDays: number
      impact: string
      isActive: boolean
      startedAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["globalEvent"]>
    composites: {}
  }

  type GlobalEventGetPayload<S extends boolean | null | undefined | GlobalEventDefaultArgs> = $Result.GetResult<Prisma.$GlobalEventPayload, S>

  type GlobalEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlobalEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlobalEventCountAggregateInputType | true
    }

  export interface GlobalEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalEvent'], meta: { name: 'GlobalEvent' } }
    /**
     * Find zero or one GlobalEvent that matches the filter.
     * @param {GlobalEventFindUniqueArgs} args - Arguments to find a GlobalEvent
     * @example
     * // Get one GlobalEvent
     * const globalEvent = await prisma.globalEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalEventFindUniqueArgs>(args: SelectSubset<T, GlobalEventFindUniqueArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GlobalEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlobalEventFindUniqueOrThrowArgs} args - Arguments to find a GlobalEvent
     * @example
     * // Get one GlobalEvent
     * const globalEvent = await prisma.globalEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalEventFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventFindFirstArgs} args - Arguments to find a GlobalEvent
     * @example
     * // Get one GlobalEvent
     * const globalEvent = await prisma.globalEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalEventFindFirstArgs>(args?: SelectSubset<T, GlobalEventFindFirstArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventFindFirstOrThrowArgs} args - Arguments to find a GlobalEvent
     * @example
     * // Get one GlobalEvent
     * const globalEvent = await prisma.globalEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalEventFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GlobalEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalEvents
     * const globalEvents = await prisma.globalEvent.findMany()
     * 
     * // Get first 10 GlobalEvents
     * const globalEvents = await prisma.globalEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalEventWithIdOnly = await prisma.globalEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalEventFindManyArgs>(args?: SelectSubset<T, GlobalEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GlobalEvent.
     * @param {GlobalEventCreateArgs} args - Arguments to create a GlobalEvent.
     * @example
     * // Create one GlobalEvent
     * const GlobalEvent = await prisma.globalEvent.create({
     *   data: {
     *     // ... data to create a GlobalEvent
     *   }
     * })
     * 
     */
    create<T extends GlobalEventCreateArgs>(args: SelectSubset<T, GlobalEventCreateArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GlobalEvents.
     * @param {GlobalEventCreateManyArgs} args - Arguments to create many GlobalEvents.
     * @example
     * // Create many GlobalEvents
     * const globalEvent = await prisma.globalEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalEventCreateManyArgs>(args?: SelectSubset<T, GlobalEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalEvents and returns the data saved in the database.
     * @param {GlobalEventCreateManyAndReturnArgs} args - Arguments to create many GlobalEvents.
     * @example
     * // Create many GlobalEvents
     * const globalEvent = await prisma.globalEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalEvents and only return the `id`
     * const globalEventWithIdOnly = await prisma.globalEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalEventCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GlobalEvent.
     * @param {GlobalEventDeleteArgs} args - Arguments to delete one GlobalEvent.
     * @example
     * // Delete one GlobalEvent
     * const GlobalEvent = await prisma.globalEvent.delete({
     *   where: {
     *     // ... filter to delete one GlobalEvent
     *   }
     * })
     * 
     */
    delete<T extends GlobalEventDeleteArgs>(args: SelectSubset<T, GlobalEventDeleteArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GlobalEvent.
     * @param {GlobalEventUpdateArgs} args - Arguments to update one GlobalEvent.
     * @example
     * // Update one GlobalEvent
     * const globalEvent = await prisma.globalEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalEventUpdateArgs>(args: SelectSubset<T, GlobalEventUpdateArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GlobalEvents.
     * @param {GlobalEventDeleteManyArgs} args - Arguments to filter GlobalEvents to delete.
     * @example
     * // Delete a few GlobalEvents
     * const { count } = await prisma.globalEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalEventDeleteManyArgs>(args?: SelectSubset<T, GlobalEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalEvents
     * const globalEvent = await prisma.globalEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalEventUpdateManyArgs>(args: SelectSubset<T, GlobalEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalEvents and returns the data updated in the database.
     * @param {GlobalEventUpdateManyAndReturnArgs} args - Arguments to update many GlobalEvents.
     * @example
     * // Update many GlobalEvents
     * const globalEvent = await prisma.globalEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GlobalEvents and only return the `id`
     * const globalEventWithIdOnly = await prisma.globalEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlobalEventUpdateManyAndReturnArgs>(args: SelectSubset<T, GlobalEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GlobalEvent.
     * @param {GlobalEventUpsertArgs} args - Arguments to update or create a GlobalEvent.
     * @example
     * // Update or create a GlobalEvent
     * const globalEvent = await prisma.globalEvent.upsert({
     *   create: {
     *     // ... data to create a GlobalEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalEvent we want to update
     *   }
     * })
     */
    upsert<T extends GlobalEventUpsertArgs>(args: SelectSubset<T, GlobalEventUpsertArgs<ExtArgs>>): Prisma__GlobalEventClient<$Result.GetResult<Prisma.$GlobalEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GlobalEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventCountArgs} args - Arguments to filter GlobalEvents to count.
     * @example
     * // Count the number of GlobalEvents
     * const count = await prisma.globalEvent.count({
     *   where: {
     *     // ... the filter for the GlobalEvents we want to count
     *   }
     * })
    **/
    count<T extends GlobalEventCountArgs>(
      args?: Subset<T, GlobalEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalEventAggregateArgs>(args: Subset<T, GlobalEventAggregateArgs>): Prisma.PrismaPromise<GetGlobalEventAggregateType<T>>

    /**
     * Group by GlobalEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalEventGroupByArgs['orderBy'] }
        : { orderBy?: GlobalEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalEvent model
   */
  readonly fields: GlobalEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalEvent model
   */
  interface GlobalEventFieldRefs {
    readonly id: FieldRef<"GlobalEvent", 'Int'>
    readonly title: FieldRef<"GlobalEvent", 'String'>
    readonly type: FieldRef<"GlobalEvent", 'String'>
    readonly affectedRegion: FieldRef<"GlobalEvent", 'String'>
    readonly description: FieldRef<"GlobalEvent", 'String'>
    readonly durationDays: FieldRef<"GlobalEvent", 'Int'>
    readonly impact: FieldRef<"GlobalEvent", 'String'>
    readonly isActive: FieldRef<"GlobalEvent", 'Boolean'>
    readonly startedAt: FieldRef<"GlobalEvent", 'DateTime'>
    readonly endedAt: FieldRef<"GlobalEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalEvent findUnique
   */
  export type GlobalEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * Filter, which GlobalEvent to fetch.
     */
    where: GlobalEventWhereUniqueInput
  }

  /**
   * GlobalEvent findUniqueOrThrow
   */
  export type GlobalEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * Filter, which GlobalEvent to fetch.
     */
    where: GlobalEventWhereUniqueInput
  }

  /**
   * GlobalEvent findFirst
   */
  export type GlobalEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * Filter, which GlobalEvent to fetch.
     */
    where?: GlobalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalEvents to fetch.
     */
    orderBy?: GlobalEventOrderByWithRelationInput | GlobalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalEvents.
     */
    cursor?: GlobalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalEvents.
     */
    distinct?: GlobalEventScalarFieldEnum | GlobalEventScalarFieldEnum[]
  }

  /**
   * GlobalEvent findFirstOrThrow
   */
  export type GlobalEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * Filter, which GlobalEvent to fetch.
     */
    where?: GlobalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalEvents to fetch.
     */
    orderBy?: GlobalEventOrderByWithRelationInput | GlobalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalEvents.
     */
    cursor?: GlobalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalEvents.
     */
    distinct?: GlobalEventScalarFieldEnum | GlobalEventScalarFieldEnum[]
  }

  /**
   * GlobalEvent findMany
   */
  export type GlobalEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * Filter, which GlobalEvents to fetch.
     */
    where?: GlobalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalEvents to fetch.
     */
    orderBy?: GlobalEventOrderByWithRelationInput | GlobalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalEvents.
     */
    cursor?: GlobalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalEvents.
     */
    skip?: number
    distinct?: GlobalEventScalarFieldEnum | GlobalEventScalarFieldEnum[]
  }

  /**
   * GlobalEvent create
   */
  export type GlobalEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * The data needed to create a GlobalEvent.
     */
    data: XOR<GlobalEventCreateInput, GlobalEventUncheckedCreateInput>
  }

  /**
   * GlobalEvent createMany
   */
  export type GlobalEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalEvents.
     */
    data: GlobalEventCreateManyInput | GlobalEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalEvent createManyAndReturn
   */
  export type GlobalEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * The data used to create many GlobalEvents.
     */
    data: GlobalEventCreateManyInput | GlobalEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalEvent update
   */
  export type GlobalEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * The data needed to update a GlobalEvent.
     */
    data: XOR<GlobalEventUpdateInput, GlobalEventUncheckedUpdateInput>
    /**
     * Choose, which GlobalEvent to update.
     */
    where: GlobalEventWhereUniqueInput
  }

  /**
   * GlobalEvent updateMany
   */
  export type GlobalEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalEvents.
     */
    data: XOR<GlobalEventUpdateManyMutationInput, GlobalEventUncheckedUpdateManyInput>
    /**
     * Filter which GlobalEvents to update
     */
    where?: GlobalEventWhereInput
    /**
     * Limit how many GlobalEvents to update.
     */
    limit?: number
  }

  /**
   * GlobalEvent updateManyAndReturn
   */
  export type GlobalEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * The data used to update GlobalEvents.
     */
    data: XOR<GlobalEventUpdateManyMutationInput, GlobalEventUncheckedUpdateManyInput>
    /**
     * Filter which GlobalEvents to update
     */
    where?: GlobalEventWhereInput
    /**
     * Limit how many GlobalEvents to update.
     */
    limit?: number
  }

  /**
   * GlobalEvent upsert
   */
  export type GlobalEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * The filter to search for the GlobalEvent to update in case it exists.
     */
    where: GlobalEventWhereUniqueInput
    /**
     * In case the GlobalEvent found by the `where` argument doesn't exist, create a new GlobalEvent with this data.
     */
    create: XOR<GlobalEventCreateInput, GlobalEventUncheckedCreateInput>
    /**
     * In case the GlobalEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalEventUpdateInput, GlobalEventUncheckedUpdateInput>
  }

  /**
   * GlobalEvent delete
   */
  export type GlobalEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
    /**
     * Filter which GlobalEvent to delete.
     */
    where: GlobalEventWhereUniqueInput
  }

  /**
   * GlobalEvent deleteMany
   */
  export type GlobalEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalEvents to delete
     */
    where?: GlobalEventWhereInput
    /**
     * Limit how many GlobalEvents to delete.
     */
    limit?: number
  }

  /**
   * GlobalEvent without action
   */
  export type GlobalEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalEvent
     */
    select?: GlobalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalEvent
     */
    omit?: GlobalEventOmit<ExtArgs> | null
  }


  /**
   * Model Weather
   */

  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherAvgAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type WeatherSumAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type WeatherMinAggregateOutputType = {
    id: number | null
    cityId: number | null
    condition: string | null
    updatedAt: Date | null
  }

  export type WeatherMaxAggregateOutputType = {
    id: number | null
    cityId: number | null
    condition: string | null
    updatedAt: Date | null
  }

  export type WeatherCountAggregateOutputType = {
    id: number
    cityId: number
    condition: number
    updatedAt: number
    _all: number
  }


  export type WeatherAvgAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type WeatherSumAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type WeatherMinAggregateInputType = {
    id?: true
    cityId?: true
    condition?: true
    updatedAt?: true
  }

  export type WeatherMaxAggregateInputType = {
    id?: true
    cityId?: true
    condition?: true
    updatedAt?: true
  }

  export type WeatherCountAggregateInputType = {
    id?: true
    cityId?: true
    condition?: true
    updatedAt?: true
    _all?: true
  }

  export type WeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weather to aggregate.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }




  export type WeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithAggregationInput | WeatherOrderByWithAggregationInput[]
    by: WeatherScalarFieldEnum[] | WeatherScalarFieldEnum
    having?: WeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _avg?: WeatherAvgAggregateInputType
    _sum?: WeatherSumAggregateInputType
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }

  export type WeatherGroupByOutputType = {
    id: number
    cityId: number
    condition: string
    updatedAt: Date
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      >
    >


  export type WeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    condition?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    condition?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    condition?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectScalar = {
    id?: boolean
    cityId?: boolean
    condition?: boolean
    updatedAt?: boolean
  }

  export type WeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "condition" | "updatedAt", ExtArgs["result"]["weather"]>
  export type WeatherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type WeatherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type WeatherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $WeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weather"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cityId: number
      condition: string
      updatedAt: Date
    }, ExtArgs["result"]["weather"]>
    composites: {}
  }

  type WeatherGetPayload<S extends boolean | null | undefined | WeatherDefaultArgs> = $Result.GetResult<Prisma.$WeatherPayload, S>

  type WeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherCountAggregateInputType | true
    }

  export interface WeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weather'], meta: { name: 'Weather' } }
    /**
     * Find zero or one Weather that matches the filter.
     * @param {WeatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherFindUniqueArgs>(args: SelectSubset<T, WeatherFindUniqueArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherFindUniqueOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherFindFirstArgs>(args?: SelectSubset<T, WeatherFindFirstArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherFindManyArgs>(args?: SelectSubset<T, WeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weather.
     * @param {WeatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
     */
    create<T extends WeatherCreateArgs>(args: SelectSubset<T, WeatherCreateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weathers.
     * @param {WeatherCreateManyArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherCreateManyArgs>(args?: SelectSubset<T, WeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weathers and returns the data saved in the database.
     * @param {WeatherCreateManyAndReturnArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weather.
     * @param {WeatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
     */
    delete<T extends WeatherDeleteArgs>(args: SelectSubset<T, WeatherDeleteArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weather.
     * @param {WeatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherUpdateArgs>(args: SelectSubset<T, WeatherUpdateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weathers.
     * @param {WeatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherDeleteManyArgs>(args?: SelectSubset<T, WeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherUpdateManyArgs>(args: SelectSubset<T, WeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers and returns the data updated in the database.
     * @param {WeatherUpdateManyAndReturnArgs} args - Arguments to update many Weathers.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weather.
     * @param {WeatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
     */
    upsert<T extends WeatherUpsertArgs>(args: SelectSubset<T, WeatherUpsertArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends WeatherCountArgs>(
      args?: Subset<T, WeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): Prisma.PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weather model
   */
  readonly fields: WeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weather model
   */
  interface WeatherFieldRefs {
    readonly id: FieldRef<"Weather", 'Int'>
    readonly cityId: FieldRef<"Weather", 'Int'>
    readonly condition: FieldRef<"Weather", 'String'>
    readonly updatedAt: FieldRef<"Weather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Weather findUnique
   */
  export type WeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findUniqueOrThrow
   */
  export type WeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findFirst
   */
  export type WeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findFirstOrThrow
   */
  export type WeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findMany
   */
  export type WeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weathers to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather create
   */
  export type WeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The data needed to create a Weather.
     */
    data: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
  }

  /**
   * Weather createMany
   */
  export type WeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weather createManyAndReturn
   */
  export type WeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weather update
   */
  export type WeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The data needed to update a Weather.
     */
    data: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
    /**
     * Choose, which Weather to update.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather updateMany
   */
  export type WeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather updateManyAndReturn
   */
  export type WeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weather upsert
   */
  export type WeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The filter to search for the Weather to update in case it exists.
     */
    where: WeatherWhereUniqueInput
    /**
     * In case the Weather found by the `where` argument doesn't exist, create a new Weather with this data.
     */
    create: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
    /**
     * In case the Weather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
  }

  /**
   * Weather delete
   */
  export type WeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter which Weather to delete.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather deleteMany
   */
  export type WeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weathers to delete
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to delete.
     */
    limit?: number
  }

  /**
   * Weather without action
   */
  export type WeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
  }


  /**
   * Model NPCStory
   */

  export type AggregateNPCStory = {
    _count: NPCStoryCountAggregateOutputType | null
    _avg: NPCStoryAvgAggregateOutputType | null
    _sum: NPCStorySumAggregateOutputType | null
    _min: NPCStoryMinAggregateOutputType | null
    _max: NPCStoryMaxAggregateOutputType | null
  }

  export type NPCStoryAvgAggregateOutputType = {
    id: number | null
    npcId: number | null
  }

  export type NPCStorySumAggregateOutputType = {
    id: number | null
    npcId: number | null
  }

  export type NPCStoryMinAggregateOutputType = {
    id: number | null
    npcId: number | null
    title: string | null
    summary: string | null
    createdAt: Date | null
  }

  export type NPCStoryMaxAggregateOutputType = {
    id: number | null
    npcId: number | null
    title: string | null
    summary: string | null
    createdAt: Date | null
  }

  export type NPCStoryCountAggregateOutputType = {
    id: number
    npcId: number
    title: number
    summary: number
    createdAt: number
    _all: number
  }


  export type NPCStoryAvgAggregateInputType = {
    id?: true
    npcId?: true
  }

  export type NPCStorySumAggregateInputType = {
    id?: true
    npcId?: true
  }

  export type NPCStoryMinAggregateInputType = {
    id?: true
    npcId?: true
    title?: true
    summary?: true
    createdAt?: true
  }

  export type NPCStoryMaxAggregateInputType = {
    id?: true
    npcId?: true
    title?: true
    summary?: true
    createdAt?: true
  }

  export type NPCStoryCountAggregateInputType = {
    id?: true
    npcId?: true
    title?: true
    summary?: true
    createdAt?: true
    _all?: true
  }

  export type NPCStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCStory to aggregate.
     */
    where?: NPCStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCStories to fetch.
     */
    orderBy?: NPCStoryOrderByWithRelationInput | NPCStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPCStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPCStories
    **/
    _count?: true | NPCStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NPCStoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NPCStorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPCStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPCStoryMaxAggregateInputType
  }

  export type GetNPCStoryAggregateType<T extends NPCStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateNPCStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPCStory[P]>
      : GetScalarType<T[P], AggregateNPCStory[P]>
  }




  export type NPCStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCStoryWhereInput
    orderBy?: NPCStoryOrderByWithAggregationInput | NPCStoryOrderByWithAggregationInput[]
    by: NPCStoryScalarFieldEnum[] | NPCStoryScalarFieldEnum
    having?: NPCStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPCStoryCountAggregateInputType | true
    _avg?: NPCStoryAvgAggregateInputType
    _sum?: NPCStorySumAggregateInputType
    _min?: NPCStoryMinAggregateInputType
    _max?: NPCStoryMaxAggregateInputType
  }

  export type NPCStoryGroupByOutputType = {
    id: number
    npcId: number
    title: string
    summary: string
    createdAt: Date
    _count: NPCStoryCountAggregateOutputType | null
    _avg: NPCStoryAvgAggregateOutputType | null
    _sum: NPCStorySumAggregateOutputType | null
    _min: NPCStoryMinAggregateOutputType | null
    _max: NPCStoryMaxAggregateOutputType | null
  }

  type GetNPCStoryGroupByPayload<T extends NPCStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPCStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPCStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPCStoryGroupByOutputType[P]>
            : GetScalarType<T[P], NPCStoryGroupByOutputType[P]>
        }
      >
    >


  export type NPCStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    title?: boolean
    summary?: boolean
    createdAt?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPCStory"]>

  export type NPCStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    title?: boolean
    summary?: boolean
    createdAt?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPCStory"]>

  export type NPCStorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    title?: boolean
    summary?: boolean
    createdAt?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPCStory"]>

  export type NPCStorySelectScalar = {
    id?: boolean
    npcId?: boolean
    title?: boolean
    summary?: boolean
    createdAt?: boolean
  }

  export type NPCStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "npcId" | "title" | "summary" | "createdAt", ExtArgs["result"]["nPCStory"]>
  export type NPCStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type NPCStoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type NPCStoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }

  export type $NPCStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPCStory"
    objects: {
      npc: Prisma.$NPCPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      npcId: number
      title: string
      summary: string
      createdAt: Date
    }, ExtArgs["result"]["nPCStory"]>
    composites: {}
  }

  type NPCStoryGetPayload<S extends boolean | null | undefined | NPCStoryDefaultArgs> = $Result.GetResult<Prisma.$NPCStoryPayload, S>

  type NPCStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NPCStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NPCStoryCountAggregateInputType | true
    }

  export interface NPCStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPCStory'], meta: { name: 'NPCStory' } }
    /**
     * Find zero or one NPCStory that matches the filter.
     * @param {NPCStoryFindUniqueArgs} args - Arguments to find a NPCStory
     * @example
     * // Get one NPCStory
     * const nPCStory = await prisma.nPCStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPCStoryFindUniqueArgs>(args: SelectSubset<T, NPCStoryFindUniqueArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NPCStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NPCStoryFindUniqueOrThrowArgs} args - Arguments to find a NPCStory
     * @example
     * // Get one NPCStory
     * const nPCStory = await prisma.nPCStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPCStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, NPCStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPCStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryFindFirstArgs} args - Arguments to find a NPCStory
     * @example
     * // Get one NPCStory
     * const nPCStory = await prisma.nPCStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPCStoryFindFirstArgs>(args?: SelectSubset<T, NPCStoryFindFirstArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPCStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryFindFirstOrThrowArgs} args - Arguments to find a NPCStory
     * @example
     * // Get one NPCStory
     * const nPCStory = await prisma.nPCStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPCStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, NPCStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NPCStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPCStories
     * const nPCStories = await prisma.nPCStory.findMany()
     * 
     * // Get first 10 NPCStories
     * const nPCStories = await prisma.nPCStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nPCStoryWithIdOnly = await prisma.nPCStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NPCStoryFindManyArgs>(args?: SelectSubset<T, NPCStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NPCStory.
     * @param {NPCStoryCreateArgs} args - Arguments to create a NPCStory.
     * @example
     * // Create one NPCStory
     * const NPCStory = await prisma.nPCStory.create({
     *   data: {
     *     // ... data to create a NPCStory
     *   }
     * })
     * 
     */
    create<T extends NPCStoryCreateArgs>(args: SelectSubset<T, NPCStoryCreateArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NPCStories.
     * @param {NPCStoryCreateManyArgs} args - Arguments to create many NPCStories.
     * @example
     * // Create many NPCStories
     * const nPCStory = await prisma.nPCStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPCStoryCreateManyArgs>(args?: SelectSubset<T, NPCStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPCStories and returns the data saved in the database.
     * @param {NPCStoryCreateManyAndReturnArgs} args - Arguments to create many NPCStories.
     * @example
     * // Create many NPCStories
     * const nPCStory = await prisma.nPCStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPCStories and only return the `id`
     * const nPCStoryWithIdOnly = await prisma.nPCStory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPCStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, NPCStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NPCStory.
     * @param {NPCStoryDeleteArgs} args - Arguments to delete one NPCStory.
     * @example
     * // Delete one NPCStory
     * const NPCStory = await prisma.nPCStory.delete({
     *   where: {
     *     // ... filter to delete one NPCStory
     *   }
     * })
     * 
     */
    delete<T extends NPCStoryDeleteArgs>(args: SelectSubset<T, NPCStoryDeleteArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NPCStory.
     * @param {NPCStoryUpdateArgs} args - Arguments to update one NPCStory.
     * @example
     * // Update one NPCStory
     * const nPCStory = await prisma.nPCStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPCStoryUpdateArgs>(args: SelectSubset<T, NPCStoryUpdateArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NPCStories.
     * @param {NPCStoryDeleteManyArgs} args - Arguments to filter NPCStories to delete.
     * @example
     * // Delete a few NPCStories
     * const { count } = await prisma.nPCStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPCStoryDeleteManyArgs>(args?: SelectSubset<T, NPCStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPCStories
     * const nPCStory = await prisma.nPCStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPCStoryUpdateManyArgs>(args: SelectSubset<T, NPCStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCStories and returns the data updated in the database.
     * @param {NPCStoryUpdateManyAndReturnArgs} args - Arguments to update many NPCStories.
     * @example
     * // Update many NPCStories
     * const nPCStory = await prisma.nPCStory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NPCStories and only return the `id`
     * const nPCStoryWithIdOnly = await prisma.nPCStory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NPCStoryUpdateManyAndReturnArgs>(args: SelectSubset<T, NPCStoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NPCStory.
     * @param {NPCStoryUpsertArgs} args - Arguments to update or create a NPCStory.
     * @example
     * // Update or create a NPCStory
     * const nPCStory = await prisma.nPCStory.upsert({
     *   create: {
     *     // ... data to create a NPCStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPCStory we want to update
     *   }
     * })
     */
    upsert<T extends NPCStoryUpsertArgs>(args: SelectSubset<T, NPCStoryUpsertArgs<ExtArgs>>): Prisma__NPCStoryClient<$Result.GetResult<Prisma.$NPCStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NPCStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryCountArgs} args - Arguments to filter NPCStories to count.
     * @example
     * // Count the number of NPCStories
     * const count = await prisma.nPCStory.count({
     *   where: {
     *     // ... the filter for the NPCStories we want to count
     *   }
     * })
    **/
    count<T extends NPCStoryCountArgs>(
      args?: Subset<T, NPCStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPCStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPCStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPCStoryAggregateArgs>(args: Subset<T, NPCStoryAggregateArgs>): Prisma.PrismaPromise<GetNPCStoryAggregateType<T>>

    /**
     * Group by NPCStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPCStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPCStoryGroupByArgs['orderBy'] }
        : { orderBy?: NPCStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPCStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPCStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPCStory model
   */
  readonly fields: NPCStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPCStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPCStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPCStory model
   */
  interface NPCStoryFieldRefs {
    readonly id: FieldRef<"NPCStory", 'Int'>
    readonly npcId: FieldRef<"NPCStory", 'Int'>
    readonly title: FieldRef<"NPCStory", 'String'>
    readonly summary: FieldRef<"NPCStory", 'String'>
    readonly createdAt: FieldRef<"NPCStory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NPCStory findUnique
   */
  export type NPCStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * Filter, which NPCStory to fetch.
     */
    where: NPCStoryWhereUniqueInput
  }

  /**
   * NPCStory findUniqueOrThrow
   */
  export type NPCStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * Filter, which NPCStory to fetch.
     */
    where: NPCStoryWhereUniqueInput
  }

  /**
   * NPCStory findFirst
   */
  export type NPCStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * Filter, which NPCStory to fetch.
     */
    where?: NPCStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCStories to fetch.
     */
    orderBy?: NPCStoryOrderByWithRelationInput | NPCStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCStories.
     */
    cursor?: NPCStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCStories.
     */
    distinct?: NPCStoryScalarFieldEnum | NPCStoryScalarFieldEnum[]
  }

  /**
   * NPCStory findFirstOrThrow
   */
  export type NPCStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * Filter, which NPCStory to fetch.
     */
    where?: NPCStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCStories to fetch.
     */
    orderBy?: NPCStoryOrderByWithRelationInput | NPCStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCStories.
     */
    cursor?: NPCStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCStories.
     */
    distinct?: NPCStoryScalarFieldEnum | NPCStoryScalarFieldEnum[]
  }

  /**
   * NPCStory findMany
   */
  export type NPCStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * Filter, which NPCStories to fetch.
     */
    where?: NPCStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCStories to fetch.
     */
    orderBy?: NPCStoryOrderByWithRelationInput | NPCStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPCStories.
     */
    cursor?: NPCStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCStories.
     */
    skip?: number
    distinct?: NPCStoryScalarFieldEnum | NPCStoryScalarFieldEnum[]
  }

  /**
   * NPCStory create
   */
  export type NPCStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a NPCStory.
     */
    data: XOR<NPCStoryCreateInput, NPCStoryUncheckedCreateInput>
  }

  /**
   * NPCStory createMany
   */
  export type NPCStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPCStories.
     */
    data: NPCStoryCreateManyInput | NPCStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NPCStory createManyAndReturn
   */
  export type NPCStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * The data used to create many NPCStories.
     */
    data: NPCStoryCreateManyInput | NPCStoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPCStory update
   */
  export type NPCStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a NPCStory.
     */
    data: XOR<NPCStoryUpdateInput, NPCStoryUncheckedUpdateInput>
    /**
     * Choose, which NPCStory to update.
     */
    where: NPCStoryWhereUniqueInput
  }

  /**
   * NPCStory updateMany
   */
  export type NPCStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPCStories.
     */
    data: XOR<NPCStoryUpdateManyMutationInput, NPCStoryUncheckedUpdateManyInput>
    /**
     * Filter which NPCStories to update
     */
    where?: NPCStoryWhereInput
    /**
     * Limit how many NPCStories to update.
     */
    limit?: number
  }

  /**
   * NPCStory updateManyAndReturn
   */
  export type NPCStoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * The data used to update NPCStories.
     */
    data: XOR<NPCStoryUpdateManyMutationInput, NPCStoryUncheckedUpdateManyInput>
    /**
     * Filter which NPCStories to update
     */
    where?: NPCStoryWhereInput
    /**
     * Limit how many NPCStories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPCStory upsert
   */
  export type NPCStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the NPCStory to update in case it exists.
     */
    where: NPCStoryWhereUniqueInput
    /**
     * In case the NPCStory found by the `where` argument doesn't exist, create a new NPCStory with this data.
     */
    create: XOR<NPCStoryCreateInput, NPCStoryUncheckedCreateInput>
    /**
     * In case the NPCStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPCStoryUpdateInput, NPCStoryUncheckedUpdateInput>
  }

  /**
   * NPCStory delete
   */
  export type NPCStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
    /**
     * Filter which NPCStory to delete.
     */
    where: NPCStoryWhereUniqueInput
  }

  /**
   * NPCStory deleteMany
   */
  export type NPCStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCStories to delete
     */
    where?: NPCStoryWhereInput
    /**
     * Limit how many NPCStories to delete.
     */
    limit?: number
  }

  /**
   * NPCStory without action
   */
  export type NPCStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCStory
     */
    select?: NPCStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCStory
     */
    omit?: NPCStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCStoryInclude<ExtArgs> | null
  }


  /**
   * Model PlayerTitle
   */

  export type AggregatePlayerTitle = {
    _count: PlayerTitleCountAggregateOutputType | null
    _avg: PlayerTitleAvgAggregateOutputType | null
    _sum: PlayerTitleSumAggregateOutputType | null
    _min: PlayerTitleMinAggregateOutputType | null
    _max: PlayerTitleMaxAggregateOutputType | null
  }

  export type PlayerTitleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    authority: number | null
  }

  export type PlayerTitleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    authority: number | null
  }

  export type PlayerTitleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    region: string | null
    grantedAt: Date | null
    authority: number | null
  }

  export type PlayerTitleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    region: string | null
    grantedAt: Date | null
    authority: number | null
  }

  export type PlayerTitleCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    region: number
    grantedAt: number
    authority: number
    _all: number
  }


  export type PlayerTitleAvgAggregateInputType = {
    id?: true
    userId?: true
    authority?: true
  }

  export type PlayerTitleSumAggregateInputType = {
    id?: true
    userId?: true
    authority?: true
  }

  export type PlayerTitleMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    region?: true
    grantedAt?: true
    authority?: true
  }

  export type PlayerTitleMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    region?: true
    grantedAt?: true
    authority?: true
  }

  export type PlayerTitleCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    region?: true
    grantedAt?: true
    authority?: true
    _all?: true
  }

  export type PlayerTitleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerTitle to aggregate.
     */
    where?: PlayerTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTitles to fetch.
     */
    orderBy?: PlayerTitleOrderByWithRelationInput | PlayerTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerTitles
    **/
    _count?: true | PlayerTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerTitleMaxAggregateInputType
  }

  export type GetPlayerTitleAggregateType<T extends PlayerTitleAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerTitle[P]>
      : GetScalarType<T[P], AggregatePlayerTitle[P]>
  }




  export type PlayerTitleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerTitleWhereInput
    orderBy?: PlayerTitleOrderByWithAggregationInput | PlayerTitleOrderByWithAggregationInput[]
    by: PlayerTitleScalarFieldEnum[] | PlayerTitleScalarFieldEnum
    having?: PlayerTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerTitleCountAggregateInputType | true
    _avg?: PlayerTitleAvgAggregateInputType
    _sum?: PlayerTitleSumAggregateInputType
    _min?: PlayerTitleMinAggregateInputType
    _max?: PlayerTitleMaxAggregateInputType
  }

  export type PlayerTitleGroupByOutputType = {
    id: number
    userId: number
    type: string
    region: string
    grantedAt: Date
    authority: number
    _count: PlayerTitleCountAggregateOutputType | null
    _avg: PlayerTitleAvgAggregateOutputType | null
    _sum: PlayerTitleSumAggregateOutputType | null
    _min: PlayerTitleMinAggregateOutputType | null
    _max: PlayerTitleMaxAggregateOutputType | null
  }

  type GetPlayerTitleGroupByPayload<T extends PlayerTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerTitleGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerTitleGroupByOutputType[P]>
        }
      >
    >


  export type PlayerTitleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    region?: boolean
    grantedAt?: boolean
    authority?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerTitle"]>

  export type PlayerTitleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    region?: boolean
    grantedAt?: boolean
    authority?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerTitle"]>

  export type PlayerTitleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    region?: boolean
    grantedAt?: boolean
    authority?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerTitle"]>

  export type PlayerTitleSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    region?: boolean
    grantedAt?: boolean
    authority?: boolean
  }

  export type PlayerTitleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "region" | "grantedAt" | "authority", ExtArgs["result"]["playerTitle"]>
  export type PlayerTitleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerTitleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerTitleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlayerTitlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerTitle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      region: string
      grantedAt: Date
      authority: number
    }, ExtArgs["result"]["playerTitle"]>
    composites: {}
  }

  type PlayerTitleGetPayload<S extends boolean | null | undefined | PlayerTitleDefaultArgs> = $Result.GetResult<Prisma.$PlayerTitlePayload, S>

  type PlayerTitleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerTitleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerTitleCountAggregateInputType | true
    }

  export interface PlayerTitleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerTitle'], meta: { name: 'PlayerTitle' } }
    /**
     * Find zero or one PlayerTitle that matches the filter.
     * @param {PlayerTitleFindUniqueArgs} args - Arguments to find a PlayerTitle
     * @example
     * // Get one PlayerTitle
     * const playerTitle = await prisma.playerTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerTitleFindUniqueArgs>(args: SelectSubset<T, PlayerTitleFindUniqueArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerTitle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerTitleFindUniqueOrThrowArgs} args - Arguments to find a PlayerTitle
     * @example
     * // Get one PlayerTitle
     * const playerTitle = await prisma.playerTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerTitleFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerTitleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleFindFirstArgs} args - Arguments to find a PlayerTitle
     * @example
     * // Get one PlayerTitle
     * const playerTitle = await prisma.playerTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerTitleFindFirstArgs>(args?: SelectSubset<T, PlayerTitleFindFirstArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerTitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleFindFirstOrThrowArgs} args - Arguments to find a PlayerTitle
     * @example
     * // Get one PlayerTitle
     * const playerTitle = await prisma.playerTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerTitleFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerTitleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerTitles
     * const playerTitles = await prisma.playerTitle.findMany()
     * 
     * // Get first 10 PlayerTitles
     * const playerTitles = await prisma.playerTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerTitleWithIdOnly = await prisma.playerTitle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerTitleFindManyArgs>(args?: SelectSubset<T, PlayerTitleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerTitle.
     * @param {PlayerTitleCreateArgs} args - Arguments to create a PlayerTitle.
     * @example
     * // Create one PlayerTitle
     * const PlayerTitle = await prisma.playerTitle.create({
     *   data: {
     *     // ... data to create a PlayerTitle
     *   }
     * })
     * 
     */
    create<T extends PlayerTitleCreateArgs>(args: SelectSubset<T, PlayerTitleCreateArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerTitles.
     * @param {PlayerTitleCreateManyArgs} args - Arguments to create many PlayerTitles.
     * @example
     * // Create many PlayerTitles
     * const playerTitle = await prisma.playerTitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerTitleCreateManyArgs>(args?: SelectSubset<T, PlayerTitleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerTitles and returns the data saved in the database.
     * @param {PlayerTitleCreateManyAndReturnArgs} args - Arguments to create many PlayerTitles.
     * @example
     * // Create many PlayerTitles
     * const playerTitle = await prisma.playerTitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerTitles and only return the `id`
     * const playerTitleWithIdOnly = await prisma.playerTitle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerTitleCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerTitleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerTitle.
     * @param {PlayerTitleDeleteArgs} args - Arguments to delete one PlayerTitle.
     * @example
     * // Delete one PlayerTitle
     * const PlayerTitle = await prisma.playerTitle.delete({
     *   where: {
     *     // ... filter to delete one PlayerTitle
     *   }
     * })
     * 
     */
    delete<T extends PlayerTitleDeleteArgs>(args: SelectSubset<T, PlayerTitleDeleteArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerTitle.
     * @param {PlayerTitleUpdateArgs} args - Arguments to update one PlayerTitle.
     * @example
     * // Update one PlayerTitle
     * const playerTitle = await prisma.playerTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerTitleUpdateArgs>(args: SelectSubset<T, PlayerTitleUpdateArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerTitles.
     * @param {PlayerTitleDeleteManyArgs} args - Arguments to filter PlayerTitles to delete.
     * @example
     * // Delete a few PlayerTitles
     * const { count } = await prisma.playerTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerTitleDeleteManyArgs>(args?: SelectSubset<T, PlayerTitleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerTitles
     * const playerTitle = await prisma.playerTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerTitleUpdateManyArgs>(args: SelectSubset<T, PlayerTitleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerTitles and returns the data updated in the database.
     * @param {PlayerTitleUpdateManyAndReturnArgs} args - Arguments to update many PlayerTitles.
     * @example
     * // Update many PlayerTitles
     * const playerTitle = await prisma.playerTitle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerTitles and only return the `id`
     * const playerTitleWithIdOnly = await prisma.playerTitle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerTitleUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerTitleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerTitle.
     * @param {PlayerTitleUpsertArgs} args - Arguments to update or create a PlayerTitle.
     * @example
     * // Update or create a PlayerTitle
     * const playerTitle = await prisma.playerTitle.upsert({
     *   create: {
     *     // ... data to create a PlayerTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerTitle we want to update
     *   }
     * })
     */
    upsert<T extends PlayerTitleUpsertArgs>(args: SelectSubset<T, PlayerTitleUpsertArgs<ExtArgs>>): Prisma__PlayerTitleClient<$Result.GetResult<Prisma.$PlayerTitlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleCountArgs} args - Arguments to filter PlayerTitles to count.
     * @example
     * // Count the number of PlayerTitles
     * const count = await prisma.playerTitle.count({
     *   where: {
     *     // ... the filter for the PlayerTitles we want to count
     *   }
     * })
    **/
    count<T extends PlayerTitleCountArgs>(
      args?: Subset<T, PlayerTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerTitleAggregateArgs>(args: Subset<T, PlayerTitleAggregateArgs>): Prisma.PrismaPromise<GetPlayerTitleAggregateType<T>>

    /**
     * Group by PlayerTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerTitleGroupByArgs['orderBy'] }
        : { orderBy?: PlayerTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerTitle model
   */
  readonly fields: PlayerTitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerTitleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerTitle model
   */
  interface PlayerTitleFieldRefs {
    readonly id: FieldRef<"PlayerTitle", 'Int'>
    readonly userId: FieldRef<"PlayerTitle", 'Int'>
    readonly type: FieldRef<"PlayerTitle", 'String'>
    readonly region: FieldRef<"PlayerTitle", 'String'>
    readonly grantedAt: FieldRef<"PlayerTitle", 'DateTime'>
    readonly authority: FieldRef<"PlayerTitle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlayerTitle findUnique
   */
  export type PlayerTitleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTitle to fetch.
     */
    where: PlayerTitleWhereUniqueInput
  }

  /**
   * PlayerTitle findUniqueOrThrow
   */
  export type PlayerTitleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTitle to fetch.
     */
    where: PlayerTitleWhereUniqueInput
  }

  /**
   * PlayerTitle findFirst
   */
  export type PlayerTitleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTitle to fetch.
     */
    where?: PlayerTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTitles to fetch.
     */
    orderBy?: PlayerTitleOrderByWithRelationInput | PlayerTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerTitles.
     */
    cursor?: PlayerTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerTitles.
     */
    distinct?: PlayerTitleScalarFieldEnum | PlayerTitleScalarFieldEnum[]
  }

  /**
   * PlayerTitle findFirstOrThrow
   */
  export type PlayerTitleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTitle to fetch.
     */
    where?: PlayerTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTitles to fetch.
     */
    orderBy?: PlayerTitleOrderByWithRelationInput | PlayerTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerTitles.
     */
    cursor?: PlayerTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerTitles.
     */
    distinct?: PlayerTitleScalarFieldEnum | PlayerTitleScalarFieldEnum[]
  }

  /**
   * PlayerTitle findMany
   */
  export type PlayerTitleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * Filter, which PlayerTitles to fetch.
     */
    where?: PlayerTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerTitles to fetch.
     */
    orderBy?: PlayerTitleOrderByWithRelationInput | PlayerTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerTitles.
     */
    cursor?: PlayerTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerTitles.
     */
    skip?: number
    distinct?: PlayerTitleScalarFieldEnum | PlayerTitleScalarFieldEnum[]
  }

  /**
   * PlayerTitle create
   */
  export type PlayerTitleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerTitle.
     */
    data: XOR<PlayerTitleCreateInput, PlayerTitleUncheckedCreateInput>
  }

  /**
   * PlayerTitle createMany
   */
  export type PlayerTitleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerTitles.
     */
    data: PlayerTitleCreateManyInput | PlayerTitleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerTitle createManyAndReturn
   */
  export type PlayerTitleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerTitles.
     */
    data: PlayerTitleCreateManyInput | PlayerTitleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerTitle update
   */
  export type PlayerTitleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerTitle.
     */
    data: XOR<PlayerTitleUpdateInput, PlayerTitleUncheckedUpdateInput>
    /**
     * Choose, which PlayerTitle to update.
     */
    where: PlayerTitleWhereUniqueInput
  }

  /**
   * PlayerTitle updateMany
   */
  export type PlayerTitleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerTitles.
     */
    data: XOR<PlayerTitleUpdateManyMutationInput, PlayerTitleUncheckedUpdateManyInput>
    /**
     * Filter which PlayerTitles to update
     */
    where?: PlayerTitleWhereInput
    /**
     * Limit how many PlayerTitles to update.
     */
    limit?: number
  }

  /**
   * PlayerTitle updateManyAndReturn
   */
  export type PlayerTitleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * The data used to update PlayerTitles.
     */
    data: XOR<PlayerTitleUpdateManyMutationInput, PlayerTitleUncheckedUpdateManyInput>
    /**
     * Filter which PlayerTitles to update
     */
    where?: PlayerTitleWhereInput
    /**
     * Limit how many PlayerTitles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerTitle upsert
   */
  export type PlayerTitleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerTitle to update in case it exists.
     */
    where: PlayerTitleWhereUniqueInput
    /**
     * In case the PlayerTitle found by the `where` argument doesn't exist, create a new PlayerTitle with this data.
     */
    create: XOR<PlayerTitleCreateInput, PlayerTitleUncheckedCreateInput>
    /**
     * In case the PlayerTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerTitleUpdateInput, PlayerTitleUncheckedUpdateInput>
  }

  /**
   * PlayerTitle delete
   */
  export type PlayerTitleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
    /**
     * Filter which PlayerTitle to delete.
     */
    where: PlayerTitleWhereUniqueInput
  }

  /**
   * PlayerTitle deleteMany
   */
  export type PlayerTitleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerTitles to delete
     */
    where?: PlayerTitleWhereInput
    /**
     * Limit how many PlayerTitles to delete.
     */
    limit?: number
  }

  /**
   * PlayerTitle without action
   */
  export type PlayerTitleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerTitle
     */
    select?: PlayerTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerTitle
     */
    omit?: PlayerTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerTitleInclude<ExtArgs> | null
  }


  /**
   * Model Economy
   */

  export type AggregateEconomy = {
    _count: EconomyCountAggregateOutputType | null
    _avg: EconomyAvgAggregateOutputType | null
    _sum: EconomySumAggregateOutputType | null
    _min: EconomyMinAggregateOutputType | null
    _max: EconomyMaxAggregateOutputType | null
  }

  export type EconomyAvgAggregateOutputType = {
    id: number | null
    cityId: number | null
    price: number | null
  }

  export type EconomySumAggregateOutputType = {
    id: number | null
    cityId: number | null
    price: number | null
  }

  export type EconomyMinAggregateOutputType = {
    id: number | null
    cityId: number | null
    item: string | null
    price: number | null
    demand: string | null
    supply: string | null
  }

  export type EconomyMaxAggregateOutputType = {
    id: number | null
    cityId: number | null
    item: string | null
    price: number | null
    demand: string | null
    supply: string | null
  }

  export type EconomyCountAggregateOutputType = {
    id: number
    cityId: number
    item: number
    price: number
    demand: number
    supply: number
    _all: number
  }


  export type EconomyAvgAggregateInputType = {
    id?: true
    cityId?: true
    price?: true
  }

  export type EconomySumAggregateInputType = {
    id?: true
    cityId?: true
    price?: true
  }

  export type EconomyMinAggregateInputType = {
    id?: true
    cityId?: true
    item?: true
    price?: true
    demand?: true
    supply?: true
  }

  export type EconomyMaxAggregateInputType = {
    id?: true
    cityId?: true
    item?: true
    price?: true
    demand?: true
    supply?: true
  }

  export type EconomyCountAggregateInputType = {
    id?: true
    cityId?: true
    item?: true
    price?: true
    demand?: true
    supply?: true
    _all?: true
  }

  export type EconomyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Economy to aggregate.
     */
    where?: EconomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Economies to fetch.
     */
    orderBy?: EconomyOrderByWithRelationInput | EconomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EconomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Economies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Economies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Economies
    **/
    _count?: true | EconomyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EconomyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EconomySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EconomyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EconomyMaxAggregateInputType
  }

  export type GetEconomyAggregateType<T extends EconomyAggregateArgs> = {
        [P in keyof T & keyof AggregateEconomy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEconomy[P]>
      : GetScalarType<T[P], AggregateEconomy[P]>
  }




  export type EconomyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EconomyWhereInput
    orderBy?: EconomyOrderByWithAggregationInput | EconomyOrderByWithAggregationInput[]
    by: EconomyScalarFieldEnum[] | EconomyScalarFieldEnum
    having?: EconomyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EconomyCountAggregateInputType | true
    _avg?: EconomyAvgAggregateInputType
    _sum?: EconomySumAggregateInputType
    _min?: EconomyMinAggregateInputType
    _max?: EconomyMaxAggregateInputType
  }

  export type EconomyGroupByOutputType = {
    id: number
    cityId: number
    item: string
    price: number
    demand: string
    supply: string
    _count: EconomyCountAggregateOutputType | null
    _avg: EconomyAvgAggregateOutputType | null
    _sum: EconomySumAggregateOutputType | null
    _min: EconomyMinAggregateOutputType | null
    _max: EconomyMaxAggregateOutputType | null
  }

  type GetEconomyGroupByPayload<T extends EconomyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EconomyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EconomyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EconomyGroupByOutputType[P]>
            : GetScalarType<T[P], EconomyGroupByOutputType[P]>
        }
      >
    >


  export type EconomySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    item?: boolean
    price?: boolean
    demand?: boolean
    supply?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["economy"]>

  export type EconomySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    item?: boolean
    price?: boolean
    demand?: boolean
    supply?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["economy"]>

  export type EconomySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    item?: boolean
    price?: boolean
    demand?: boolean
    supply?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["economy"]>

  export type EconomySelectScalar = {
    id?: boolean
    cityId?: boolean
    item?: boolean
    price?: boolean
    demand?: boolean
    supply?: boolean
  }

  export type EconomyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "item" | "price" | "demand" | "supply", ExtArgs["result"]["economy"]>
  export type EconomyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type EconomyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type EconomyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $EconomyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Economy"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cityId: number
      item: string
      price: number
      demand: string
      supply: string
    }, ExtArgs["result"]["economy"]>
    composites: {}
  }

  type EconomyGetPayload<S extends boolean | null | undefined | EconomyDefaultArgs> = $Result.GetResult<Prisma.$EconomyPayload, S>

  type EconomyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EconomyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EconomyCountAggregateInputType | true
    }

  export interface EconomyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Economy'], meta: { name: 'Economy' } }
    /**
     * Find zero or one Economy that matches the filter.
     * @param {EconomyFindUniqueArgs} args - Arguments to find a Economy
     * @example
     * // Get one Economy
     * const economy = await prisma.economy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EconomyFindUniqueArgs>(args: SelectSubset<T, EconomyFindUniqueArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Economy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EconomyFindUniqueOrThrowArgs} args - Arguments to find a Economy
     * @example
     * // Get one Economy
     * const economy = await prisma.economy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EconomyFindUniqueOrThrowArgs>(args: SelectSubset<T, EconomyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Economy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyFindFirstArgs} args - Arguments to find a Economy
     * @example
     * // Get one Economy
     * const economy = await prisma.economy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EconomyFindFirstArgs>(args?: SelectSubset<T, EconomyFindFirstArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Economy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyFindFirstOrThrowArgs} args - Arguments to find a Economy
     * @example
     * // Get one Economy
     * const economy = await prisma.economy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EconomyFindFirstOrThrowArgs>(args?: SelectSubset<T, EconomyFindFirstOrThrowArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Economies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Economies
     * const economies = await prisma.economy.findMany()
     * 
     * // Get first 10 Economies
     * const economies = await prisma.economy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const economyWithIdOnly = await prisma.economy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EconomyFindManyArgs>(args?: SelectSubset<T, EconomyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Economy.
     * @param {EconomyCreateArgs} args - Arguments to create a Economy.
     * @example
     * // Create one Economy
     * const Economy = await prisma.economy.create({
     *   data: {
     *     // ... data to create a Economy
     *   }
     * })
     * 
     */
    create<T extends EconomyCreateArgs>(args: SelectSubset<T, EconomyCreateArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Economies.
     * @param {EconomyCreateManyArgs} args - Arguments to create many Economies.
     * @example
     * // Create many Economies
     * const economy = await prisma.economy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EconomyCreateManyArgs>(args?: SelectSubset<T, EconomyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Economies and returns the data saved in the database.
     * @param {EconomyCreateManyAndReturnArgs} args - Arguments to create many Economies.
     * @example
     * // Create many Economies
     * const economy = await prisma.economy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Economies and only return the `id`
     * const economyWithIdOnly = await prisma.economy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EconomyCreateManyAndReturnArgs>(args?: SelectSubset<T, EconomyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Economy.
     * @param {EconomyDeleteArgs} args - Arguments to delete one Economy.
     * @example
     * // Delete one Economy
     * const Economy = await prisma.economy.delete({
     *   where: {
     *     // ... filter to delete one Economy
     *   }
     * })
     * 
     */
    delete<T extends EconomyDeleteArgs>(args: SelectSubset<T, EconomyDeleteArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Economy.
     * @param {EconomyUpdateArgs} args - Arguments to update one Economy.
     * @example
     * // Update one Economy
     * const economy = await prisma.economy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EconomyUpdateArgs>(args: SelectSubset<T, EconomyUpdateArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Economies.
     * @param {EconomyDeleteManyArgs} args - Arguments to filter Economies to delete.
     * @example
     * // Delete a few Economies
     * const { count } = await prisma.economy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EconomyDeleteManyArgs>(args?: SelectSubset<T, EconomyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Economies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Economies
     * const economy = await prisma.economy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EconomyUpdateManyArgs>(args: SelectSubset<T, EconomyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Economies and returns the data updated in the database.
     * @param {EconomyUpdateManyAndReturnArgs} args - Arguments to update many Economies.
     * @example
     * // Update many Economies
     * const economy = await prisma.economy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Economies and only return the `id`
     * const economyWithIdOnly = await prisma.economy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EconomyUpdateManyAndReturnArgs>(args: SelectSubset<T, EconomyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Economy.
     * @param {EconomyUpsertArgs} args - Arguments to update or create a Economy.
     * @example
     * // Update or create a Economy
     * const economy = await prisma.economy.upsert({
     *   create: {
     *     // ... data to create a Economy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Economy we want to update
     *   }
     * })
     */
    upsert<T extends EconomyUpsertArgs>(args: SelectSubset<T, EconomyUpsertArgs<ExtArgs>>): Prisma__EconomyClient<$Result.GetResult<Prisma.$EconomyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Economies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyCountArgs} args - Arguments to filter Economies to count.
     * @example
     * // Count the number of Economies
     * const count = await prisma.economy.count({
     *   where: {
     *     // ... the filter for the Economies we want to count
     *   }
     * })
    **/
    count<T extends EconomyCountArgs>(
      args?: Subset<T, EconomyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EconomyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Economy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EconomyAggregateArgs>(args: Subset<T, EconomyAggregateArgs>): Prisma.PrismaPromise<GetEconomyAggregateType<T>>

    /**
     * Group by Economy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EconomyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EconomyGroupByArgs['orderBy'] }
        : { orderBy?: EconomyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EconomyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEconomyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Economy model
   */
  readonly fields: EconomyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Economy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EconomyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Economy model
   */
  interface EconomyFieldRefs {
    readonly id: FieldRef<"Economy", 'Int'>
    readonly cityId: FieldRef<"Economy", 'Int'>
    readonly item: FieldRef<"Economy", 'String'>
    readonly price: FieldRef<"Economy", 'Int'>
    readonly demand: FieldRef<"Economy", 'String'>
    readonly supply: FieldRef<"Economy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Economy findUnique
   */
  export type EconomyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * Filter, which Economy to fetch.
     */
    where: EconomyWhereUniqueInput
  }

  /**
   * Economy findUniqueOrThrow
   */
  export type EconomyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * Filter, which Economy to fetch.
     */
    where: EconomyWhereUniqueInput
  }

  /**
   * Economy findFirst
   */
  export type EconomyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * Filter, which Economy to fetch.
     */
    where?: EconomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Economies to fetch.
     */
    orderBy?: EconomyOrderByWithRelationInput | EconomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Economies.
     */
    cursor?: EconomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Economies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Economies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Economies.
     */
    distinct?: EconomyScalarFieldEnum | EconomyScalarFieldEnum[]
  }

  /**
   * Economy findFirstOrThrow
   */
  export type EconomyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * Filter, which Economy to fetch.
     */
    where?: EconomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Economies to fetch.
     */
    orderBy?: EconomyOrderByWithRelationInput | EconomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Economies.
     */
    cursor?: EconomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Economies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Economies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Economies.
     */
    distinct?: EconomyScalarFieldEnum | EconomyScalarFieldEnum[]
  }

  /**
   * Economy findMany
   */
  export type EconomyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * Filter, which Economies to fetch.
     */
    where?: EconomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Economies to fetch.
     */
    orderBy?: EconomyOrderByWithRelationInput | EconomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Economies.
     */
    cursor?: EconomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Economies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Economies.
     */
    skip?: number
    distinct?: EconomyScalarFieldEnum | EconomyScalarFieldEnum[]
  }

  /**
   * Economy create
   */
  export type EconomyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * The data needed to create a Economy.
     */
    data: XOR<EconomyCreateInput, EconomyUncheckedCreateInput>
  }

  /**
   * Economy createMany
   */
  export type EconomyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Economies.
     */
    data: EconomyCreateManyInput | EconomyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Economy createManyAndReturn
   */
  export type EconomyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * The data used to create many Economies.
     */
    data: EconomyCreateManyInput | EconomyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Economy update
   */
  export type EconomyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * The data needed to update a Economy.
     */
    data: XOR<EconomyUpdateInput, EconomyUncheckedUpdateInput>
    /**
     * Choose, which Economy to update.
     */
    where: EconomyWhereUniqueInput
  }

  /**
   * Economy updateMany
   */
  export type EconomyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Economies.
     */
    data: XOR<EconomyUpdateManyMutationInput, EconomyUncheckedUpdateManyInput>
    /**
     * Filter which Economies to update
     */
    where?: EconomyWhereInput
    /**
     * Limit how many Economies to update.
     */
    limit?: number
  }

  /**
   * Economy updateManyAndReturn
   */
  export type EconomyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * The data used to update Economies.
     */
    data: XOR<EconomyUpdateManyMutationInput, EconomyUncheckedUpdateManyInput>
    /**
     * Filter which Economies to update
     */
    where?: EconomyWhereInput
    /**
     * Limit how many Economies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Economy upsert
   */
  export type EconomyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * The filter to search for the Economy to update in case it exists.
     */
    where: EconomyWhereUniqueInput
    /**
     * In case the Economy found by the `where` argument doesn't exist, create a new Economy with this data.
     */
    create: XOR<EconomyCreateInput, EconomyUncheckedCreateInput>
    /**
     * In case the Economy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EconomyUpdateInput, EconomyUncheckedUpdateInput>
  }

  /**
   * Economy delete
   */
  export type EconomyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
    /**
     * Filter which Economy to delete.
     */
    where: EconomyWhereUniqueInput
  }

  /**
   * Economy deleteMany
   */
  export type EconomyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Economies to delete
     */
    where?: EconomyWhereInput
    /**
     * Limit how many Economies to delete.
     */
    limit?: number
  }

  /**
   * Economy without action
   */
  export type EconomyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Economy
     */
    select?: EconomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Economy
     */
    omit?: EconomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EconomyInclude<ExtArgs> | null
  }


  /**
   * Model WorldTime
   */

  export type AggregateWorldTime = {
    _count: WorldTimeCountAggregateOutputType | null
    _avg: WorldTimeAvgAggregateOutputType | null
    _sum: WorldTimeSumAggregateOutputType | null
    _min: WorldTimeMinAggregateOutputType | null
    _max: WorldTimeMaxAggregateOutputType | null
  }

  export type WorldTimeAvgAggregateOutputType = {
    id: number | null
  }

  export type WorldTimeSumAggregateOutputType = {
    id: number | null
  }

  export type WorldTimeMinAggregateOutputType = {
    id: number | null
    lastSimulated: Date | null
  }

  export type WorldTimeMaxAggregateOutputType = {
    id: number | null
    lastSimulated: Date | null
  }

  export type WorldTimeCountAggregateOutputType = {
    id: number
    lastSimulated: number
    _all: number
  }


  export type WorldTimeAvgAggregateInputType = {
    id?: true
  }

  export type WorldTimeSumAggregateInputType = {
    id?: true
  }

  export type WorldTimeMinAggregateInputType = {
    id?: true
    lastSimulated?: true
  }

  export type WorldTimeMaxAggregateInputType = {
    id?: true
    lastSimulated?: true
  }

  export type WorldTimeCountAggregateInputType = {
    id?: true
    lastSimulated?: true
    _all?: true
  }

  export type WorldTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorldTime to aggregate.
     */
    where?: WorldTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldTimes to fetch.
     */
    orderBy?: WorldTimeOrderByWithRelationInput | WorldTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorldTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorldTimes
    **/
    _count?: true | WorldTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorldTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorldTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorldTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorldTimeMaxAggregateInputType
  }

  export type GetWorldTimeAggregateType<T extends WorldTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateWorldTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorldTime[P]>
      : GetScalarType<T[P], AggregateWorldTime[P]>
  }




  export type WorldTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorldTimeWhereInput
    orderBy?: WorldTimeOrderByWithAggregationInput | WorldTimeOrderByWithAggregationInput[]
    by: WorldTimeScalarFieldEnum[] | WorldTimeScalarFieldEnum
    having?: WorldTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorldTimeCountAggregateInputType | true
    _avg?: WorldTimeAvgAggregateInputType
    _sum?: WorldTimeSumAggregateInputType
    _min?: WorldTimeMinAggregateInputType
    _max?: WorldTimeMaxAggregateInputType
  }

  export type WorldTimeGroupByOutputType = {
    id: number
    lastSimulated: Date
    _count: WorldTimeCountAggregateOutputType | null
    _avg: WorldTimeAvgAggregateOutputType | null
    _sum: WorldTimeSumAggregateOutputType | null
    _min: WorldTimeMinAggregateOutputType | null
    _max: WorldTimeMaxAggregateOutputType | null
  }

  type GetWorldTimeGroupByPayload<T extends WorldTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorldTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorldTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorldTimeGroupByOutputType[P]>
            : GetScalarType<T[P], WorldTimeGroupByOutputType[P]>
        }
      >
    >


  export type WorldTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSimulated?: boolean
  }, ExtArgs["result"]["worldTime"]>

  export type WorldTimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSimulated?: boolean
  }, ExtArgs["result"]["worldTime"]>

  export type WorldTimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSimulated?: boolean
  }, ExtArgs["result"]["worldTime"]>

  export type WorldTimeSelectScalar = {
    id?: boolean
    lastSimulated?: boolean
  }

  export type WorldTimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastSimulated", ExtArgs["result"]["worldTime"]>

  export type $WorldTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorldTime"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lastSimulated: Date
    }, ExtArgs["result"]["worldTime"]>
    composites: {}
  }

  type WorldTimeGetPayload<S extends boolean | null | undefined | WorldTimeDefaultArgs> = $Result.GetResult<Prisma.$WorldTimePayload, S>

  type WorldTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorldTimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorldTimeCountAggregateInputType | true
    }

  export interface WorldTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorldTime'], meta: { name: 'WorldTime' } }
    /**
     * Find zero or one WorldTime that matches the filter.
     * @param {WorldTimeFindUniqueArgs} args - Arguments to find a WorldTime
     * @example
     * // Get one WorldTime
     * const worldTime = await prisma.worldTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorldTimeFindUniqueArgs>(args: SelectSubset<T, WorldTimeFindUniqueArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorldTime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorldTimeFindUniqueOrThrowArgs} args - Arguments to find a WorldTime
     * @example
     * // Get one WorldTime
     * const worldTime = await prisma.worldTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorldTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, WorldTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorldTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeFindFirstArgs} args - Arguments to find a WorldTime
     * @example
     * // Get one WorldTime
     * const worldTime = await prisma.worldTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorldTimeFindFirstArgs>(args?: SelectSubset<T, WorldTimeFindFirstArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorldTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeFindFirstOrThrowArgs} args - Arguments to find a WorldTime
     * @example
     * // Get one WorldTime
     * const worldTime = await prisma.worldTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorldTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, WorldTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorldTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorldTimes
     * const worldTimes = await prisma.worldTime.findMany()
     * 
     * // Get first 10 WorldTimes
     * const worldTimes = await prisma.worldTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const worldTimeWithIdOnly = await prisma.worldTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorldTimeFindManyArgs>(args?: SelectSubset<T, WorldTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorldTime.
     * @param {WorldTimeCreateArgs} args - Arguments to create a WorldTime.
     * @example
     * // Create one WorldTime
     * const WorldTime = await prisma.worldTime.create({
     *   data: {
     *     // ... data to create a WorldTime
     *   }
     * })
     * 
     */
    create<T extends WorldTimeCreateArgs>(args: SelectSubset<T, WorldTimeCreateArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorldTimes.
     * @param {WorldTimeCreateManyArgs} args - Arguments to create many WorldTimes.
     * @example
     * // Create many WorldTimes
     * const worldTime = await prisma.worldTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorldTimeCreateManyArgs>(args?: SelectSubset<T, WorldTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorldTimes and returns the data saved in the database.
     * @param {WorldTimeCreateManyAndReturnArgs} args - Arguments to create many WorldTimes.
     * @example
     * // Create many WorldTimes
     * const worldTime = await prisma.worldTime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorldTimes and only return the `id`
     * const worldTimeWithIdOnly = await prisma.worldTime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorldTimeCreateManyAndReturnArgs>(args?: SelectSubset<T, WorldTimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorldTime.
     * @param {WorldTimeDeleteArgs} args - Arguments to delete one WorldTime.
     * @example
     * // Delete one WorldTime
     * const WorldTime = await prisma.worldTime.delete({
     *   where: {
     *     // ... filter to delete one WorldTime
     *   }
     * })
     * 
     */
    delete<T extends WorldTimeDeleteArgs>(args: SelectSubset<T, WorldTimeDeleteArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorldTime.
     * @param {WorldTimeUpdateArgs} args - Arguments to update one WorldTime.
     * @example
     * // Update one WorldTime
     * const worldTime = await prisma.worldTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorldTimeUpdateArgs>(args: SelectSubset<T, WorldTimeUpdateArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorldTimes.
     * @param {WorldTimeDeleteManyArgs} args - Arguments to filter WorldTimes to delete.
     * @example
     * // Delete a few WorldTimes
     * const { count } = await prisma.worldTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorldTimeDeleteManyArgs>(args?: SelectSubset<T, WorldTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorldTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorldTimes
     * const worldTime = await prisma.worldTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorldTimeUpdateManyArgs>(args: SelectSubset<T, WorldTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorldTimes and returns the data updated in the database.
     * @param {WorldTimeUpdateManyAndReturnArgs} args - Arguments to update many WorldTimes.
     * @example
     * // Update many WorldTimes
     * const worldTime = await prisma.worldTime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorldTimes and only return the `id`
     * const worldTimeWithIdOnly = await prisma.worldTime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorldTimeUpdateManyAndReturnArgs>(args: SelectSubset<T, WorldTimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorldTime.
     * @param {WorldTimeUpsertArgs} args - Arguments to update or create a WorldTime.
     * @example
     * // Update or create a WorldTime
     * const worldTime = await prisma.worldTime.upsert({
     *   create: {
     *     // ... data to create a WorldTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorldTime we want to update
     *   }
     * })
     */
    upsert<T extends WorldTimeUpsertArgs>(args: SelectSubset<T, WorldTimeUpsertArgs<ExtArgs>>): Prisma__WorldTimeClient<$Result.GetResult<Prisma.$WorldTimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorldTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeCountArgs} args - Arguments to filter WorldTimes to count.
     * @example
     * // Count the number of WorldTimes
     * const count = await prisma.worldTime.count({
     *   where: {
     *     // ... the filter for the WorldTimes we want to count
     *   }
     * })
    **/
    count<T extends WorldTimeCountArgs>(
      args?: Subset<T, WorldTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorldTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorldTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorldTimeAggregateArgs>(args: Subset<T, WorldTimeAggregateArgs>): Prisma.PrismaPromise<GetWorldTimeAggregateType<T>>

    /**
     * Group by WorldTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorldTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorldTimeGroupByArgs['orderBy'] }
        : { orderBy?: WorldTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorldTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorldTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorldTime model
   */
  readonly fields: WorldTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorldTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorldTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorldTime model
   */
  interface WorldTimeFieldRefs {
    readonly id: FieldRef<"WorldTime", 'Int'>
    readonly lastSimulated: FieldRef<"WorldTime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorldTime findUnique
   */
  export type WorldTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * Filter, which WorldTime to fetch.
     */
    where: WorldTimeWhereUniqueInput
  }

  /**
   * WorldTime findUniqueOrThrow
   */
  export type WorldTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * Filter, which WorldTime to fetch.
     */
    where: WorldTimeWhereUniqueInput
  }

  /**
   * WorldTime findFirst
   */
  export type WorldTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * Filter, which WorldTime to fetch.
     */
    where?: WorldTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldTimes to fetch.
     */
    orderBy?: WorldTimeOrderByWithRelationInput | WorldTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorldTimes.
     */
    cursor?: WorldTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorldTimes.
     */
    distinct?: WorldTimeScalarFieldEnum | WorldTimeScalarFieldEnum[]
  }

  /**
   * WorldTime findFirstOrThrow
   */
  export type WorldTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * Filter, which WorldTime to fetch.
     */
    where?: WorldTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldTimes to fetch.
     */
    orderBy?: WorldTimeOrderByWithRelationInput | WorldTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorldTimes.
     */
    cursor?: WorldTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorldTimes.
     */
    distinct?: WorldTimeScalarFieldEnum | WorldTimeScalarFieldEnum[]
  }

  /**
   * WorldTime findMany
   */
  export type WorldTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * Filter, which WorldTimes to fetch.
     */
    where?: WorldTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldTimes to fetch.
     */
    orderBy?: WorldTimeOrderByWithRelationInput | WorldTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorldTimes.
     */
    cursor?: WorldTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldTimes.
     */
    skip?: number
    distinct?: WorldTimeScalarFieldEnum | WorldTimeScalarFieldEnum[]
  }

  /**
   * WorldTime create
   */
  export type WorldTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * The data needed to create a WorldTime.
     */
    data: XOR<WorldTimeCreateInput, WorldTimeUncheckedCreateInput>
  }

  /**
   * WorldTime createMany
   */
  export type WorldTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorldTimes.
     */
    data: WorldTimeCreateManyInput | WorldTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorldTime createManyAndReturn
   */
  export type WorldTimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * The data used to create many WorldTimes.
     */
    data: WorldTimeCreateManyInput | WorldTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorldTime update
   */
  export type WorldTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * The data needed to update a WorldTime.
     */
    data: XOR<WorldTimeUpdateInput, WorldTimeUncheckedUpdateInput>
    /**
     * Choose, which WorldTime to update.
     */
    where: WorldTimeWhereUniqueInput
  }

  /**
   * WorldTime updateMany
   */
  export type WorldTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorldTimes.
     */
    data: XOR<WorldTimeUpdateManyMutationInput, WorldTimeUncheckedUpdateManyInput>
    /**
     * Filter which WorldTimes to update
     */
    where?: WorldTimeWhereInput
    /**
     * Limit how many WorldTimes to update.
     */
    limit?: number
  }

  /**
   * WorldTime updateManyAndReturn
   */
  export type WorldTimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * The data used to update WorldTimes.
     */
    data: XOR<WorldTimeUpdateManyMutationInput, WorldTimeUncheckedUpdateManyInput>
    /**
     * Filter which WorldTimes to update
     */
    where?: WorldTimeWhereInput
    /**
     * Limit how many WorldTimes to update.
     */
    limit?: number
  }

  /**
   * WorldTime upsert
   */
  export type WorldTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * The filter to search for the WorldTime to update in case it exists.
     */
    where: WorldTimeWhereUniqueInput
    /**
     * In case the WorldTime found by the `where` argument doesn't exist, create a new WorldTime with this data.
     */
    create: XOR<WorldTimeCreateInput, WorldTimeUncheckedCreateInput>
    /**
     * In case the WorldTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorldTimeUpdateInput, WorldTimeUncheckedUpdateInput>
  }

  /**
   * WorldTime delete
   */
  export type WorldTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
    /**
     * Filter which WorldTime to delete.
     */
    where: WorldTimeWhereUniqueInput
  }

  /**
   * WorldTime deleteMany
   */
  export type WorldTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorldTimes to delete
     */
    where?: WorldTimeWhereInput
    /**
     * Limit how many WorldTimes to delete.
     */
    limit?: number
  }

  /**
   * WorldTime without action
   */
  export type WorldTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldTime
     */
    select?: WorldTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldTime
     */
    omit?: WorldTimeOmit<ExtArgs> | null
  }


  /**
   * Model WorldSnapshot
   */

  export type AggregateWorldSnapshot = {
    _count: WorldSnapshotCountAggregateOutputType | null
    _avg: WorldSnapshotAvgAggregateOutputType | null
    _sum: WorldSnapshotSumAggregateOutputType | null
    _min: WorldSnapshotMinAggregateOutputType | null
    _max: WorldSnapshotMaxAggregateOutputType | null
  }

  export type WorldSnapshotAvgAggregateOutputType = {
    id: number | null
  }

  export type WorldSnapshotSumAggregateOutputType = {
    id: number | null
  }

  export type WorldSnapshotMinAggregateOutputType = {
    id: number | null
    label: string | null
    createdAt: Date | null
  }

  export type WorldSnapshotMaxAggregateOutputType = {
    id: number | null
    label: string | null
    createdAt: Date | null
  }

  export type WorldSnapshotCountAggregateOutputType = {
    id: number
    label: number
    jsonData: number
    createdAt: number
    _all: number
  }


  export type WorldSnapshotAvgAggregateInputType = {
    id?: true
  }

  export type WorldSnapshotSumAggregateInputType = {
    id?: true
  }

  export type WorldSnapshotMinAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
  }

  export type WorldSnapshotMaxAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
  }

  export type WorldSnapshotCountAggregateInputType = {
    id?: true
    label?: true
    jsonData?: true
    createdAt?: true
    _all?: true
  }

  export type WorldSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorldSnapshot to aggregate.
     */
    where?: WorldSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldSnapshots to fetch.
     */
    orderBy?: WorldSnapshotOrderByWithRelationInput | WorldSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorldSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorldSnapshots
    **/
    _count?: true | WorldSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorldSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorldSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorldSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorldSnapshotMaxAggregateInputType
  }

  export type GetWorldSnapshotAggregateType<T extends WorldSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateWorldSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorldSnapshot[P]>
      : GetScalarType<T[P], AggregateWorldSnapshot[P]>
  }




  export type WorldSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorldSnapshotWhereInput
    orderBy?: WorldSnapshotOrderByWithAggregationInput | WorldSnapshotOrderByWithAggregationInput[]
    by: WorldSnapshotScalarFieldEnum[] | WorldSnapshotScalarFieldEnum
    having?: WorldSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorldSnapshotCountAggregateInputType | true
    _avg?: WorldSnapshotAvgAggregateInputType
    _sum?: WorldSnapshotSumAggregateInputType
    _min?: WorldSnapshotMinAggregateInputType
    _max?: WorldSnapshotMaxAggregateInputType
  }

  export type WorldSnapshotGroupByOutputType = {
    id: number
    label: string
    jsonData: JsonValue
    createdAt: Date
    _count: WorldSnapshotCountAggregateOutputType | null
    _avg: WorldSnapshotAvgAggregateOutputType | null
    _sum: WorldSnapshotSumAggregateOutputType | null
    _min: WorldSnapshotMinAggregateOutputType | null
    _max: WorldSnapshotMaxAggregateOutputType | null
  }

  type GetWorldSnapshotGroupByPayload<T extends WorldSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorldSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorldSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorldSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], WorldSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type WorldSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["worldSnapshot"]>

  export type WorldSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["worldSnapshot"]>

  export type WorldSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["worldSnapshot"]>

  export type WorldSnapshotSelectScalar = {
    id?: boolean
    label?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }

  export type WorldSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "jsonData" | "createdAt", ExtArgs["result"]["worldSnapshot"]>

  export type $WorldSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorldSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      jsonData: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["worldSnapshot"]>
    composites: {}
  }

  type WorldSnapshotGetPayload<S extends boolean | null | undefined | WorldSnapshotDefaultArgs> = $Result.GetResult<Prisma.$WorldSnapshotPayload, S>

  type WorldSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorldSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorldSnapshotCountAggregateInputType | true
    }

  export interface WorldSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorldSnapshot'], meta: { name: 'WorldSnapshot' } }
    /**
     * Find zero or one WorldSnapshot that matches the filter.
     * @param {WorldSnapshotFindUniqueArgs} args - Arguments to find a WorldSnapshot
     * @example
     * // Get one WorldSnapshot
     * const worldSnapshot = await prisma.worldSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorldSnapshotFindUniqueArgs>(args: SelectSubset<T, WorldSnapshotFindUniqueArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorldSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorldSnapshotFindUniqueOrThrowArgs} args - Arguments to find a WorldSnapshot
     * @example
     * // Get one WorldSnapshot
     * const worldSnapshot = await prisma.worldSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorldSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, WorldSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorldSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotFindFirstArgs} args - Arguments to find a WorldSnapshot
     * @example
     * // Get one WorldSnapshot
     * const worldSnapshot = await prisma.worldSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorldSnapshotFindFirstArgs>(args?: SelectSubset<T, WorldSnapshotFindFirstArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorldSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotFindFirstOrThrowArgs} args - Arguments to find a WorldSnapshot
     * @example
     * // Get one WorldSnapshot
     * const worldSnapshot = await prisma.worldSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorldSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, WorldSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorldSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorldSnapshots
     * const worldSnapshots = await prisma.worldSnapshot.findMany()
     * 
     * // Get first 10 WorldSnapshots
     * const worldSnapshots = await prisma.worldSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const worldSnapshotWithIdOnly = await prisma.worldSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorldSnapshotFindManyArgs>(args?: SelectSubset<T, WorldSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorldSnapshot.
     * @param {WorldSnapshotCreateArgs} args - Arguments to create a WorldSnapshot.
     * @example
     * // Create one WorldSnapshot
     * const WorldSnapshot = await prisma.worldSnapshot.create({
     *   data: {
     *     // ... data to create a WorldSnapshot
     *   }
     * })
     * 
     */
    create<T extends WorldSnapshotCreateArgs>(args: SelectSubset<T, WorldSnapshotCreateArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorldSnapshots.
     * @param {WorldSnapshotCreateManyArgs} args - Arguments to create many WorldSnapshots.
     * @example
     * // Create many WorldSnapshots
     * const worldSnapshot = await prisma.worldSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorldSnapshotCreateManyArgs>(args?: SelectSubset<T, WorldSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorldSnapshots and returns the data saved in the database.
     * @param {WorldSnapshotCreateManyAndReturnArgs} args - Arguments to create many WorldSnapshots.
     * @example
     * // Create many WorldSnapshots
     * const worldSnapshot = await prisma.worldSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorldSnapshots and only return the `id`
     * const worldSnapshotWithIdOnly = await prisma.worldSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorldSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, WorldSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorldSnapshot.
     * @param {WorldSnapshotDeleteArgs} args - Arguments to delete one WorldSnapshot.
     * @example
     * // Delete one WorldSnapshot
     * const WorldSnapshot = await prisma.worldSnapshot.delete({
     *   where: {
     *     // ... filter to delete one WorldSnapshot
     *   }
     * })
     * 
     */
    delete<T extends WorldSnapshotDeleteArgs>(args: SelectSubset<T, WorldSnapshotDeleteArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorldSnapshot.
     * @param {WorldSnapshotUpdateArgs} args - Arguments to update one WorldSnapshot.
     * @example
     * // Update one WorldSnapshot
     * const worldSnapshot = await prisma.worldSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorldSnapshotUpdateArgs>(args: SelectSubset<T, WorldSnapshotUpdateArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorldSnapshots.
     * @param {WorldSnapshotDeleteManyArgs} args - Arguments to filter WorldSnapshots to delete.
     * @example
     * // Delete a few WorldSnapshots
     * const { count } = await prisma.worldSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorldSnapshotDeleteManyArgs>(args?: SelectSubset<T, WorldSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorldSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorldSnapshots
     * const worldSnapshot = await prisma.worldSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorldSnapshotUpdateManyArgs>(args: SelectSubset<T, WorldSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorldSnapshots and returns the data updated in the database.
     * @param {WorldSnapshotUpdateManyAndReturnArgs} args - Arguments to update many WorldSnapshots.
     * @example
     * // Update many WorldSnapshots
     * const worldSnapshot = await prisma.worldSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorldSnapshots and only return the `id`
     * const worldSnapshotWithIdOnly = await prisma.worldSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorldSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, WorldSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorldSnapshot.
     * @param {WorldSnapshotUpsertArgs} args - Arguments to update or create a WorldSnapshot.
     * @example
     * // Update or create a WorldSnapshot
     * const worldSnapshot = await prisma.worldSnapshot.upsert({
     *   create: {
     *     // ... data to create a WorldSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorldSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends WorldSnapshotUpsertArgs>(args: SelectSubset<T, WorldSnapshotUpsertArgs<ExtArgs>>): Prisma__WorldSnapshotClient<$Result.GetResult<Prisma.$WorldSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorldSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotCountArgs} args - Arguments to filter WorldSnapshots to count.
     * @example
     * // Count the number of WorldSnapshots
     * const count = await prisma.worldSnapshot.count({
     *   where: {
     *     // ... the filter for the WorldSnapshots we want to count
     *   }
     * })
    **/
    count<T extends WorldSnapshotCountArgs>(
      args?: Subset<T, WorldSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorldSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorldSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorldSnapshotAggregateArgs>(args: Subset<T, WorldSnapshotAggregateArgs>): Prisma.PrismaPromise<GetWorldSnapshotAggregateType<T>>

    /**
     * Group by WorldSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorldSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorldSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: WorldSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorldSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorldSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorldSnapshot model
   */
  readonly fields: WorldSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorldSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorldSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorldSnapshot model
   */
  interface WorldSnapshotFieldRefs {
    readonly id: FieldRef<"WorldSnapshot", 'Int'>
    readonly label: FieldRef<"WorldSnapshot", 'String'>
    readonly jsonData: FieldRef<"WorldSnapshot", 'Json'>
    readonly createdAt: FieldRef<"WorldSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorldSnapshot findUnique
   */
  export type WorldSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which WorldSnapshot to fetch.
     */
    where: WorldSnapshotWhereUniqueInput
  }

  /**
   * WorldSnapshot findUniqueOrThrow
   */
  export type WorldSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which WorldSnapshot to fetch.
     */
    where: WorldSnapshotWhereUniqueInput
  }

  /**
   * WorldSnapshot findFirst
   */
  export type WorldSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which WorldSnapshot to fetch.
     */
    where?: WorldSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldSnapshots to fetch.
     */
    orderBy?: WorldSnapshotOrderByWithRelationInput | WorldSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorldSnapshots.
     */
    cursor?: WorldSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorldSnapshots.
     */
    distinct?: WorldSnapshotScalarFieldEnum | WorldSnapshotScalarFieldEnum[]
  }

  /**
   * WorldSnapshot findFirstOrThrow
   */
  export type WorldSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which WorldSnapshot to fetch.
     */
    where?: WorldSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldSnapshots to fetch.
     */
    orderBy?: WorldSnapshotOrderByWithRelationInput | WorldSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorldSnapshots.
     */
    cursor?: WorldSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorldSnapshots.
     */
    distinct?: WorldSnapshotScalarFieldEnum | WorldSnapshotScalarFieldEnum[]
  }

  /**
   * WorldSnapshot findMany
   */
  export type WorldSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which WorldSnapshots to fetch.
     */
    where?: WorldSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorldSnapshots to fetch.
     */
    orderBy?: WorldSnapshotOrderByWithRelationInput | WorldSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorldSnapshots.
     */
    cursor?: WorldSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorldSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorldSnapshots.
     */
    skip?: number
    distinct?: WorldSnapshotScalarFieldEnum | WorldSnapshotScalarFieldEnum[]
  }

  /**
   * WorldSnapshot create
   */
  export type WorldSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to create a WorldSnapshot.
     */
    data: XOR<WorldSnapshotCreateInput, WorldSnapshotUncheckedCreateInput>
  }

  /**
   * WorldSnapshot createMany
   */
  export type WorldSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorldSnapshots.
     */
    data: WorldSnapshotCreateManyInput | WorldSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorldSnapshot createManyAndReturn
   */
  export type WorldSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many WorldSnapshots.
     */
    data: WorldSnapshotCreateManyInput | WorldSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorldSnapshot update
   */
  export type WorldSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to update a WorldSnapshot.
     */
    data: XOR<WorldSnapshotUpdateInput, WorldSnapshotUncheckedUpdateInput>
    /**
     * Choose, which WorldSnapshot to update.
     */
    where: WorldSnapshotWhereUniqueInput
  }

  /**
   * WorldSnapshot updateMany
   */
  export type WorldSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorldSnapshots.
     */
    data: XOR<WorldSnapshotUpdateManyMutationInput, WorldSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which WorldSnapshots to update
     */
    where?: WorldSnapshotWhereInput
    /**
     * Limit how many WorldSnapshots to update.
     */
    limit?: number
  }

  /**
   * WorldSnapshot updateManyAndReturn
   */
  export type WorldSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update WorldSnapshots.
     */
    data: XOR<WorldSnapshotUpdateManyMutationInput, WorldSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which WorldSnapshots to update
     */
    where?: WorldSnapshotWhereInput
    /**
     * Limit how many WorldSnapshots to update.
     */
    limit?: number
  }

  /**
   * WorldSnapshot upsert
   */
  export type WorldSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * The filter to search for the WorldSnapshot to update in case it exists.
     */
    where: WorldSnapshotWhereUniqueInput
    /**
     * In case the WorldSnapshot found by the `where` argument doesn't exist, create a new WorldSnapshot with this data.
     */
    create: XOR<WorldSnapshotCreateInput, WorldSnapshotUncheckedCreateInput>
    /**
     * In case the WorldSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorldSnapshotUpdateInput, WorldSnapshotUncheckedUpdateInput>
  }

  /**
   * WorldSnapshot delete
   */
  export type WorldSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
    /**
     * Filter which WorldSnapshot to delete.
     */
    where: WorldSnapshotWhereUniqueInput
  }

  /**
   * WorldSnapshot deleteMany
   */
  export type WorldSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorldSnapshots to delete
     */
    where?: WorldSnapshotWhereInput
    /**
     * Limit how many WorldSnapshots to delete.
     */
    limit?: number
  }

  /**
   * WorldSnapshot without action
   */
  export type WorldSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldSnapshot
     */
    select?: WorldSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorldSnapshot
     */
    omit?: WorldSnapshotOmit<ExtArgs> | null
  }


  /**
   * Model TaxPolicy
   */

  export type AggregateTaxPolicy = {
    _count: TaxPolicyCountAggregateOutputType | null
    _avg: TaxPolicyAvgAggregateOutputType | null
    _sum: TaxPolicySumAggregateOutputType | null
    _min: TaxPolicyMinAggregateOutputType | null
    _max: TaxPolicyMaxAggregateOutputType | null
  }

  export type TaxPolicyAvgAggregateOutputType = {
    id: number | null
    rate: number | null
  }

  export type TaxPolicySumAggregateOutputType = {
    id: number | null
    rate: number | null
  }

  export type TaxPolicyMinAggregateOutputType = {
    id: number | null
    region: string | null
    rate: number | null
    updatedAt: Date | null
  }

  export type TaxPolicyMaxAggregateOutputType = {
    id: number | null
    region: string | null
    rate: number | null
    updatedAt: Date | null
  }

  export type TaxPolicyCountAggregateOutputType = {
    id: number
    region: number
    rate: number
    updatedAt: number
    _all: number
  }


  export type TaxPolicyAvgAggregateInputType = {
    id?: true
    rate?: true
  }

  export type TaxPolicySumAggregateInputType = {
    id?: true
    rate?: true
  }

  export type TaxPolicyMinAggregateInputType = {
    id?: true
    region?: true
    rate?: true
    updatedAt?: true
  }

  export type TaxPolicyMaxAggregateInputType = {
    id?: true
    region?: true
    rate?: true
    updatedAt?: true
  }

  export type TaxPolicyCountAggregateInputType = {
    id?: true
    region?: true
    rate?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPolicy to aggregate.
     */
    where?: TaxPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPolicies to fetch.
     */
    orderBy?: TaxPolicyOrderByWithRelationInput | TaxPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxPolicies
    **/
    _count?: true | TaxPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxPolicyMaxAggregateInputType
  }

  export type GetTaxPolicyAggregateType<T extends TaxPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxPolicy[P]>
      : GetScalarType<T[P], AggregateTaxPolicy[P]>
  }




  export type TaxPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxPolicyWhereInput
    orderBy?: TaxPolicyOrderByWithAggregationInput | TaxPolicyOrderByWithAggregationInput[]
    by: TaxPolicyScalarFieldEnum[] | TaxPolicyScalarFieldEnum
    having?: TaxPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxPolicyCountAggregateInputType | true
    _avg?: TaxPolicyAvgAggregateInputType
    _sum?: TaxPolicySumAggregateInputType
    _min?: TaxPolicyMinAggregateInputType
    _max?: TaxPolicyMaxAggregateInputType
  }

  export type TaxPolicyGroupByOutputType = {
    id: number
    region: string
    rate: number
    updatedAt: Date
    _count: TaxPolicyCountAggregateOutputType | null
    _avg: TaxPolicyAvgAggregateOutputType | null
    _sum: TaxPolicySumAggregateOutputType | null
    _min: TaxPolicyMinAggregateOutputType | null
    _max: TaxPolicyMaxAggregateOutputType | null
  }

  type GetTaxPolicyGroupByPayload<T extends TaxPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], TaxPolicyGroupByOutputType[P]>
        }
      >
    >


  export type TaxPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    rate?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxPolicy"]>

  export type TaxPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    rate?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxPolicy"]>

  export type TaxPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    rate?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxPolicy"]>

  export type TaxPolicySelectScalar = {
    id?: boolean
    region?: boolean
    rate?: boolean
    updatedAt?: boolean
  }

  export type TaxPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "region" | "rate" | "updatedAt", ExtArgs["result"]["taxPolicy"]>

  export type $TaxPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      region: string
      rate: number
      updatedAt: Date
    }, ExtArgs["result"]["taxPolicy"]>
    composites: {}
  }

  type TaxPolicyGetPayload<S extends boolean | null | undefined | TaxPolicyDefaultArgs> = $Result.GetResult<Prisma.$TaxPolicyPayload, S>

  type TaxPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxPolicyCountAggregateInputType | true
    }

  export interface TaxPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxPolicy'], meta: { name: 'TaxPolicy' } }
    /**
     * Find zero or one TaxPolicy that matches the filter.
     * @param {TaxPolicyFindUniqueArgs} args - Arguments to find a TaxPolicy
     * @example
     * // Get one TaxPolicy
     * const taxPolicy = await prisma.taxPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxPolicyFindUniqueArgs>(args: SelectSubset<T, TaxPolicyFindUniqueArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxPolicyFindUniqueOrThrowArgs} args - Arguments to find a TaxPolicy
     * @example
     * // Get one TaxPolicy
     * const taxPolicy = await prisma.taxPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyFindFirstArgs} args - Arguments to find a TaxPolicy
     * @example
     * // Get one TaxPolicy
     * const taxPolicy = await prisma.taxPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxPolicyFindFirstArgs>(args?: SelectSubset<T, TaxPolicyFindFirstArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyFindFirstOrThrowArgs} args - Arguments to find a TaxPolicy
     * @example
     * // Get one TaxPolicy
     * const taxPolicy = await prisma.taxPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxPolicies
     * const taxPolicies = await prisma.taxPolicy.findMany()
     * 
     * // Get first 10 TaxPolicies
     * const taxPolicies = await prisma.taxPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxPolicyWithIdOnly = await prisma.taxPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxPolicyFindManyArgs>(args?: SelectSubset<T, TaxPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxPolicy.
     * @param {TaxPolicyCreateArgs} args - Arguments to create a TaxPolicy.
     * @example
     * // Create one TaxPolicy
     * const TaxPolicy = await prisma.taxPolicy.create({
     *   data: {
     *     // ... data to create a TaxPolicy
     *   }
     * })
     * 
     */
    create<T extends TaxPolicyCreateArgs>(args: SelectSubset<T, TaxPolicyCreateArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxPolicies.
     * @param {TaxPolicyCreateManyArgs} args - Arguments to create many TaxPolicies.
     * @example
     * // Create many TaxPolicies
     * const taxPolicy = await prisma.taxPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxPolicyCreateManyArgs>(args?: SelectSubset<T, TaxPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxPolicies and returns the data saved in the database.
     * @param {TaxPolicyCreateManyAndReturnArgs} args - Arguments to create many TaxPolicies.
     * @example
     * // Create many TaxPolicies
     * const taxPolicy = await prisma.taxPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxPolicies and only return the `id`
     * const taxPolicyWithIdOnly = await prisma.taxPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxPolicy.
     * @param {TaxPolicyDeleteArgs} args - Arguments to delete one TaxPolicy.
     * @example
     * // Delete one TaxPolicy
     * const TaxPolicy = await prisma.taxPolicy.delete({
     *   where: {
     *     // ... filter to delete one TaxPolicy
     *   }
     * })
     * 
     */
    delete<T extends TaxPolicyDeleteArgs>(args: SelectSubset<T, TaxPolicyDeleteArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxPolicy.
     * @param {TaxPolicyUpdateArgs} args - Arguments to update one TaxPolicy.
     * @example
     * // Update one TaxPolicy
     * const taxPolicy = await prisma.taxPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxPolicyUpdateArgs>(args: SelectSubset<T, TaxPolicyUpdateArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxPolicies.
     * @param {TaxPolicyDeleteManyArgs} args - Arguments to filter TaxPolicies to delete.
     * @example
     * // Delete a few TaxPolicies
     * const { count } = await prisma.taxPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxPolicyDeleteManyArgs>(args?: SelectSubset<T, TaxPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxPolicies
     * const taxPolicy = await prisma.taxPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxPolicyUpdateManyArgs>(args: SelectSubset<T, TaxPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPolicies and returns the data updated in the database.
     * @param {TaxPolicyUpdateManyAndReturnArgs} args - Arguments to update many TaxPolicies.
     * @example
     * // Update many TaxPolicies
     * const taxPolicy = await prisma.taxPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxPolicies and only return the `id`
     * const taxPolicyWithIdOnly = await prisma.taxPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxPolicy.
     * @param {TaxPolicyUpsertArgs} args - Arguments to update or create a TaxPolicy.
     * @example
     * // Update or create a TaxPolicy
     * const taxPolicy = await prisma.taxPolicy.upsert({
     *   create: {
     *     // ... data to create a TaxPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxPolicy we want to update
     *   }
     * })
     */
    upsert<T extends TaxPolicyUpsertArgs>(args: SelectSubset<T, TaxPolicyUpsertArgs<ExtArgs>>): Prisma__TaxPolicyClient<$Result.GetResult<Prisma.$TaxPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyCountArgs} args - Arguments to filter TaxPolicies to count.
     * @example
     * // Count the number of TaxPolicies
     * const count = await prisma.taxPolicy.count({
     *   where: {
     *     // ... the filter for the TaxPolicies we want to count
     *   }
     * })
    **/
    count<T extends TaxPolicyCountArgs>(
      args?: Subset<T, TaxPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxPolicyAggregateArgs>(args: Subset<T, TaxPolicyAggregateArgs>): Prisma.PrismaPromise<GetTaxPolicyAggregateType<T>>

    /**
     * Group by TaxPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxPolicyGroupByArgs['orderBy'] }
        : { orderBy?: TaxPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxPolicy model
   */
  readonly fields: TaxPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxPolicy model
   */
  interface TaxPolicyFieldRefs {
    readonly id: FieldRef<"TaxPolicy", 'Int'>
    readonly region: FieldRef<"TaxPolicy", 'String'>
    readonly rate: FieldRef<"TaxPolicy", 'Int'>
    readonly updatedAt: FieldRef<"TaxPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxPolicy findUnique
   */
  export type TaxPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * Filter, which TaxPolicy to fetch.
     */
    where: TaxPolicyWhereUniqueInput
  }

  /**
   * TaxPolicy findUniqueOrThrow
   */
  export type TaxPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * Filter, which TaxPolicy to fetch.
     */
    where: TaxPolicyWhereUniqueInput
  }

  /**
   * TaxPolicy findFirst
   */
  export type TaxPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * Filter, which TaxPolicy to fetch.
     */
    where?: TaxPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPolicies to fetch.
     */
    orderBy?: TaxPolicyOrderByWithRelationInput | TaxPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPolicies.
     */
    cursor?: TaxPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPolicies.
     */
    distinct?: TaxPolicyScalarFieldEnum | TaxPolicyScalarFieldEnum[]
  }

  /**
   * TaxPolicy findFirstOrThrow
   */
  export type TaxPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * Filter, which TaxPolicy to fetch.
     */
    where?: TaxPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPolicies to fetch.
     */
    orderBy?: TaxPolicyOrderByWithRelationInput | TaxPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPolicies.
     */
    cursor?: TaxPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPolicies.
     */
    distinct?: TaxPolicyScalarFieldEnum | TaxPolicyScalarFieldEnum[]
  }

  /**
   * TaxPolicy findMany
   */
  export type TaxPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * Filter, which TaxPolicies to fetch.
     */
    where?: TaxPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPolicies to fetch.
     */
    orderBy?: TaxPolicyOrderByWithRelationInput | TaxPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxPolicies.
     */
    cursor?: TaxPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPolicies.
     */
    skip?: number
    distinct?: TaxPolicyScalarFieldEnum | TaxPolicyScalarFieldEnum[]
  }

  /**
   * TaxPolicy create
   */
  export type TaxPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * The data needed to create a TaxPolicy.
     */
    data: XOR<TaxPolicyCreateInput, TaxPolicyUncheckedCreateInput>
  }

  /**
   * TaxPolicy createMany
   */
  export type TaxPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxPolicies.
     */
    data: TaxPolicyCreateManyInput | TaxPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPolicy createManyAndReturn
   */
  export type TaxPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many TaxPolicies.
     */
    data: TaxPolicyCreateManyInput | TaxPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPolicy update
   */
  export type TaxPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * The data needed to update a TaxPolicy.
     */
    data: XOR<TaxPolicyUpdateInput, TaxPolicyUncheckedUpdateInput>
    /**
     * Choose, which TaxPolicy to update.
     */
    where: TaxPolicyWhereUniqueInput
  }

  /**
   * TaxPolicy updateMany
   */
  export type TaxPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxPolicies.
     */
    data: XOR<TaxPolicyUpdateManyMutationInput, TaxPolicyUncheckedUpdateManyInput>
    /**
     * Filter which TaxPolicies to update
     */
    where?: TaxPolicyWhereInput
    /**
     * Limit how many TaxPolicies to update.
     */
    limit?: number
  }

  /**
   * TaxPolicy updateManyAndReturn
   */
  export type TaxPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * The data used to update TaxPolicies.
     */
    data: XOR<TaxPolicyUpdateManyMutationInput, TaxPolicyUncheckedUpdateManyInput>
    /**
     * Filter which TaxPolicies to update
     */
    where?: TaxPolicyWhereInput
    /**
     * Limit how many TaxPolicies to update.
     */
    limit?: number
  }

  /**
   * TaxPolicy upsert
   */
  export type TaxPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * The filter to search for the TaxPolicy to update in case it exists.
     */
    where: TaxPolicyWhereUniqueInput
    /**
     * In case the TaxPolicy found by the `where` argument doesn't exist, create a new TaxPolicy with this data.
     */
    create: XOR<TaxPolicyCreateInput, TaxPolicyUncheckedCreateInput>
    /**
     * In case the TaxPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxPolicyUpdateInput, TaxPolicyUncheckedUpdateInput>
  }

  /**
   * TaxPolicy delete
   */
  export type TaxPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
    /**
     * Filter which TaxPolicy to delete.
     */
    where: TaxPolicyWhereUniqueInput
  }

  /**
   * TaxPolicy deleteMany
   */
  export type TaxPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPolicies to delete
     */
    where?: TaxPolicyWhereInput
    /**
     * Limit how many TaxPolicies to delete.
     */
    limit?: number
  }

  /**
   * TaxPolicy without action
   */
  export type TaxPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPolicy
     */
    select?: TaxPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPolicy
     */
    omit?: TaxPolicyOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    positionX: 'positionX',
    positionY: 'positionY',
    reputation: 'reputation',
    notoriety: 'notoriety',
    maxHp: 'maxHp',
    maxMp: 'maxMp',
    isOnline: 'isOnline'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NPCScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gender: 'gender',
    birthYear: 'birthYear',
    deathYear: 'deathYear',
    isAlive: 'isAlive',
    mood: 'mood',
    fame: 'fame',
    notoriety: 'notoriety',
    cityId: 'cityId',
    partnerId: 'partnerId',
    parent1Id: 'parent1Id',
    parent2Id: 'parent2Id',
    isNoble: 'isNoble',
    nobleTitle: 'nobleTitle',
    personality: 'personality',
    background: 'background',
    job: 'job',
    skills: 'skills',
    languageId: 'languageId',
    religionId: 'religionId'
  };

  export type NPCScalarFieldEnum = (typeof NPCScalarFieldEnum)[keyof typeof NPCScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    population: 'population',
    countryId: 'countryId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    language: 'language'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const WildAreaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    dangerLevel: 'dangerLevel',
    countryId: 'countryId',
    cityId: 'cityId'
  };

  export type WildAreaScalarFieldEnum = (typeof WildAreaScalarFieldEnum)[keyof typeof WildAreaScalarFieldEnum]


  export const DungeonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    levelRequirement: 'levelRequirement',
    isRaid: 'isRaid',
    countryId: 'countryId',
    cityId: 'cityId'
  };

  export type DungeonScalarFieldEnum = (typeof DungeonScalarFieldEnum)[keyof typeof DungeonScalarFieldEnum]


  export const QuestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    isTaken: 'isTaken',
    takenAt: 'takenAt',
    completedAt: 'completedAt',
    reputationRequired: 'reputationRequired',
    notorietyTrigger: 'notorietyTrigger',
    issuerId: 'issuerId',
    takerId: 'takerId',
    bountyTargetId: 'bountyTargetId',
    metadata: 'metadata'
  };

  export type QuestScalarFieldEnum = (typeof QuestScalarFieldEnum)[keyof typeof QuestScalarFieldEnum]


  export const PlayerProfessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    skillLevel: 'skillLevel',
    experience: 'experience'
  };

  export type PlayerProfessionScalarFieldEnum = (typeof PlayerProfessionScalarFieldEnum)[keyof typeof PlayerProfessionScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    quality: 'quality'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemInstanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId',
    quantity: 'quantity'
  };

  export type ItemInstanceScalarFieldEnum = (typeof ItemInstanceScalarFieldEnum)[keyof typeof ItemInstanceScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    profession: 'profession',
    difficulty: 'difficulty',
    productId: 'productId'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeMaterialScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    itemId: 'itemId',
    quantity: 'quantity'
  };

  export type RecipeMaterialScalarFieldEnum = (typeof RecipeMaterialScalarFieldEnum)[keyof typeof RecipeMaterialScalarFieldEnum]


  export const CorpseScalarFieldEnum: {
    id: 'id',
    npcId: 'npcId',
    userId: 'userId',
    type: 'type',
    decayStage: 'decayStage',
    location: 'location',
    causeOfDeath: 'causeOfDeath',
    isWaterlogged: 'isWaterlogged',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorpseScalarFieldEnum = (typeof CorpseScalarFieldEnum)[keyof typeof CorpseScalarFieldEnum]


  export const AnimalPopulationScalarFieldEnum: {
    id: 'id',
    species: 'species',
    type: 'type',
    population: 'population',
    areaId: 'areaId'
  };

  export type AnimalPopulationScalarFieldEnum = (typeof AnimalPopulationScalarFieldEnum)[keyof typeof AnimalPopulationScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isAncient: 'isAncient',
    region: 'region'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const UserLanguageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    languageId: 'languageId',
    fluency: 'fluency'
  };

  export type UserLanguageScalarFieldEnum = (typeof UserLanguageScalarFieldEnum)[keyof typeof UserLanguageScalarFieldEnum]


  export const ReligionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originRegion: 'originRegion',
    description: 'description',
    doctrine: 'doctrine',
    influenceLevel: 'influenceLevel',
    estimatedFollowers: 'estimatedFollowers'
  };

  export type ReligionScalarFieldEnum = (typeof ReligionScalarFieldEnum)[keyof typeof ReligionScalarFieldEnum]


  export const ArtifactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lore: 'lore',
    powerHint: 'powerHint',
    religionId: 'religionId'
  };

  export type ArtifactScalarFieldEnum = (typeof ArtifactScalarFieldEnum)[keyof typeof ArtifactScalarFieldEnum]


  export const GlobalEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    affectedRegion: 'affectedRegion',
    description: 'description',
    durationDays: 'durationDays',
    impact: 'impact',
    isActive: 'isActive',
    startedAt: 'startedAt',
    endedAt: 'endedAt'
  };

  export type GlobalEventScalarFieldEnum = (typeof GlobalEventScalarFieldEnum)[keyof typeof GlobalEventScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    condition: 'condition',
    updatedAt: 'updatedAt'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const NPCStoryScalarFieldEnum: {
    id: 'id',
    npcId: 'npcId',
    title: 'title',
    summary: 'summary',
    createdAt: 'createdAt'
  };

  export type NPCStoryScalarFieldEnum = (typeof NPCStoryScalarFieldEnum)[keyof typeof NPCStoryScalarFieldEnum]


  export const PlayerTitleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    region: 'region',
    grantedAt: 'grantedAt',
    authority: 'authority'
  };

  export type PlayerTitleScalarFieldEnum = (typeof PlayerTitleScalarFieldEnum)[keyof typeof PlayerTitleScalarFieldEnum]


  export const EconomyScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    item: 'item',
    price: 'price',
    demand: 'demand',
    supply: 'supply'
  };

  export type EconomyScalarFieldEnum = (typeof EconomyScalarFieldEnum)[keyof typeof EconomyScalarFieldEnum]


  export const WorldTimeScalarFieldEnum: {
    id: 'id',
    lastSimulated: 'lastSimulated'
  };

  export type WorldTimeScalarFieldEnum = (typeof WorldTimeScalarFieldEnum)[keyof typeof WorldTimeScalarFieldEnum]


  export const WorldSnapshotScalarFieldEnum: {
    id: 'id',
    label: 'label',
    jsonData: 'jsonData',
    createdAt: 'createdAt'
  };

  export type WorldSnapshotScalarFieldEnum = (typeof WorldSnapshotScalarFieldEnum)[keyof typeof WorldSnapshotScalarFieldEnum]


  export const TaxPolicyScalarFieldEnum: {
    id: 'id',
    region: 'region',
    rate: 'rate',
    updatedAt: 'updatedAt'
  };

  export type TaxPolicyScalarFieldEnum = (typeof TaxPolicyScalarFieldEnum)[keyof typeof TaxPolicyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    positionX?: FloatFilter<"User"> | number
    positionY?: FloatFilter<"User"> | number
    reputation?: IntFilter<"User"> | number
    notoriety?: IntFilter<"User"> | number
    maxHp?: IntFilter<"User"> | number
    maxMp?: IntFilter<"User"> | number
    isOnline?: BoolFilter<"User"> | boolean
    profession?: PlayerProfessionListRelationFilter
    inventory?: ItemInstanceListRelationFilter
    titles?: PlayerTitleListRelationFilter
    languages?: UserLanguageListRelationFilter
    quests?: QuestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
    isOnline?: SortOrder
    profession?: PlayerProfessionOrderByRelationAggregateInput
    inventory?: ItemInstanceOrderByRelationAggregateInput
    titles?: PlayerTitleOrderByRelationAggregateInput
    languages?: UserLanguageOrderByRelationAggregateInput
    quests?: QuestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    positionX?: FloatFilter<"User"> | number
    positionY?: FloatFilter<"User"> | number
    reputation?: IntFilter<"User"> | number
    notoriety?: IntFilter<"User"> | number
    maxHp?: IntFilter<"User"> | number
    maxMp?: IntFilter<"User"> | number
    isOnline?: BoolFilter<"User"> | boolean
    profession?: PlayerProfessionListRelationFilter
    inventory?: ItemInstanceListRelationFilter
    titles?: PlayerTitleListRelationFilter
    languages?: UserLanguageListRelationFilter
    quests?: QuestListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
    isOnline?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    positionX?: FloatWithAggregatesFilter<"User"> | number
    positionY?: FloatWithAggregatesFilter<"User"> | number
    reputation?: IntWithAggregatesFilter<"User"> | number
    notoriety?: IntWithAggregatesFilter<"User"> | number
    maxHp?: IntWithAggregatesFilter<"User"> | number
    maxMp?: IntWithAggregatesFilter<"User"> | number
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type NPCWhereInput = {
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    id?: IntFilter<"NPC"> | number
    name?: StringFilter<"NPC"> | string
    gender?: StringFilter<"NPC"> | string
    birthYear?: IntFilter<"NPC"> | number
    deathYear?: IntNullableFilter<"NPC"> | number | null
    isAlive?: BoolFilter<"NPC"> | boolean
    mood?: StringFilter<"NPC"> | string
    fame?: IntFilter<"NPC"> | number
    notoriety?: IntFilter<"NPC"> | number
    cityId?: IntFilter<"NPC"> | number
    partnerId?: IntNullableFilter<"NPC"> | number | null
    parent1Id?: IntNullableFilter<"NPC"> | number | null
    parent2Id?: IntNullableFilter<"NPC"> | number | null
    isNoble?: BoolFilter<"NPC"> | boolean
    nobleTitle?: StringNullableFilter<"NPC"> | string | null
    personality?: StringNullableFilter<"NPC"> | string | null
    background?: StringFilter<"NPC"> | string
    job?: StringFilter<"NPC"> | string
    skills?: StringFilter<"NPC"> | string
    languageId?: IntFilter<"NPC"> | number
    religionId?: IntNullableFilter<"NPC"> | number | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
    religion?: XOR<ReligionNullableScalarRelationFilter, ReligionWhereInput> | null
    stories?: NPCStoryListRelationFilter
    quests?: QuestListRelationFilter
  }

  export type NPCOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrderInput | SortOrder
    isAlive?: SortOrder
    mood?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    parent1Id?: SortOrderInput | SortOrder
    parent2Id?: SortOrderInput | SortOrder
    isNoble?: SortOrder
    nobleTitle?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    background?: SortOrder
    job?: SortOrder
    skills?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrderInput | SortOrder
    city?: CityOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
    religion?: ReligionOrderByWithRelationInput
    stories?: NPCStoryOrderByRelationAggregateInput
    quests?: QuestOrderByRelationAggregateInput
  }

  export type NPCWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    name?: StringFilter<"NPC"> | string
    gender?: StringFilter<"NPC"> | string
    birthYear?: IntFilter<"NPC"> | number
    deathYear?: IntNullableFilter<"NPC"> | number | null
    isAlive?: BoolFilter<"NPC"> | boolean
    mood?: StringFilter<"NPC"> | string
    fame?: IntFilter<"NPC"> | number
    notoriety?: IntFilter<"NPC"> | number
    cityId?: IntFilter<"NPC"> | number
    partnerId?: IntNullableFilter<"NPC"> | number | null
    parent1Id?: IntNullableFilter<"NPC"> | number | null
    parent2Id?: IntNullableFilter<"NPC"> | number | null
    isNoble?: BoolFilter<"NPC"> | boolean
    nobleTitle?: StringNullableFilter<"NPC"> | string | null
    personality?: StringNullableFilter<"NPC"> | string | null
    background?: StringFilter<"NPC"> | string
    job?: StringFilter<"NPC"> | string
    skills?: StringFilter<"NPC"> | string
    languageId?: IntFilter<"NPC"> | number
    religionId?: IntNullableFilter<"NPC"> | number | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
    religion?: XOR<ReligionNullableScalarRelationFilter, ReligionWhereInput> | null
    stories?: NPCStoryListRelationFilter
    quests?: QuestListRelationFilter
  }, "id">

  export type NPCOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrderInput | SortOrder
    isAlive?: SortOrder
    mood?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    parent1Id?: SortOrderInput | SortOrder
    parent2Id?: SortOrderInput | SortOrder
    isNoble?: SortOrder
    nobleTitle?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    background?: SortOrder
    job?: SortOrder
    skills?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrderInput | SortOrder
    _count?: NPCCountOrderByAggregateInput
    _avg?: NPCAvgOrderByAggregateInput
    _max?: NPCMaxOrderByAggregateInput
    _min?: NPCMinOrderByAggregateInput
    _sum?: NPCSumOrderByAggregateInput
  }

  export type NPCScalarWhereWithAggregatesInput = {
    AND?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    OR?: NPCScalarWhereWithAggregatesInput[]
    NOT?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NPC"> | number
    name?: StringWithAggregatesFilter<"NPC"> | string
    gender?: StringWithAggregatesFilter<"NPC"> | string
    birthYear?: IntWithAggregatesFilter<"NPC"> | number
    deathYear?: IntNullableWithAggregatesFilter<"NPC"> | number | null
    isAlive?: BoolWithAggregatesFilter<"NPC"> | boolean
    mood?: StringWithAggregatesFilter<"NPC"> | string
    fame?: IntWithAggregatesFilter<"NPC"> | number
    notoriety?: IntWithAggregatesFilter<"NPC"> | number
    cityId?: IntWithAggregatesFilter<"NPC"> | number
    partnerId?: IntNullableWithAggregatesFilter<"NPC"> | number | null
    parent1Id?: IntNullableWithAggregatesFilter<"NPC"> | number | null
    parent2Id?: IntNullableWithAggregatesFilter<"NPC"> | number | null
    isNoble?: BoolWithAggregatesFilter<"NPC"> | boolean
    nobleTitle?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    personality?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    background?: StringWithAggregatesFilter<"NPC"> | string
    job?: StringWithAggregatesFilter<"NPC"> | string
    skills?: StringWithAggregatesFilter<"NPC"> | string
    languageId?: IntWithAggregatesFilter<"NPC"> | number
    religionId?: IntNullableWithAggregatesFilter<"NPC"> | number | null
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: IntFilter<"City"> | number
    name?: StringFilter<"City"> | string
    description?: StringFilter<"City"> | string
    population?: IntFilter<"City"> | number
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    wildAreas?: WildAreaListRelationFilter
    dungeons?: DungeonListRelationFilter
    weather?: XOR<WeatherNullableScalarRelationFilter, WeatherWhereInput> | null
    npcs?: NPCListRelationFilter
    economies?: EconomyListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
    wildAreas?: WildAreaOrderByRelationAggregateInput
    dungeons?: DungeonOrderByRelationAggregateInput
    weather?: WeatherOrderByWithRelationInput
    npcs?: NPCOrderByRelationAggregateInput
    economies?: EconomyOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    description?: StringFilter<"City"> | string
    population?: IntFilter<"City"> | number
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    wildAreas?: WildAreaListRelationFilter
    dungeons?: DungeonListRelationFilter
    weather?: XOR<WeatherNullableScalarRelationFilter, WeatherWhereInput> | null
    npcs?: NPCListRelationFilter
    economies?: EconomyListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"City"> | number
    name?: StringWithAggregatesFilter<"City"> | string
    description?: StringWithAggregatesFilter<"City"> | string
    population?: IntWithAggregatesFilter<"City"> | number
    countryId?: IntWithAggregatesFilter<"City"> | number
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    description?: StringFilter<"Country"> | string
    language?: StringFilter<"Country"> | string
    cities?: CityListRelationFilter
    wildAreas?: WildAreaListRelationFilter
    dungeons?: DungeonListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    language?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    wildAreas?: WildAreaOrderByRelationAggregateInput
    dungeons?: DungeonOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    description?: StringFilter<"Country"> | string
    language?: StringFilter<"Country"> | string
    cities?: CityListRelationFilter
    wildAreas?: WildAreaListRelationFilter
    dungeons?: DungeonListRelationFilter
  }, "id">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    language?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    description?: StringWithAggregatesFilter<"Country"> | string
    language?: StringWithAggregatesFilter<"Country"> | string
  }

  export type WildAreaWhereInput = {
    AND?: WildAreaWhereInput | WildAreaWhereInput[]
    OR?: WildAreaWhereInput[]
    NOT?: WildAreaWhereInput | WildAreaWhereInput[]
    id?: IntFilter<"WildArea"> | number
    name?: StringFilter<"WildArea"> | string
    type?: StringFilter<"WildArea"> | string
    dangerLevel?: IntFilter<"WildArea"> | number
    countryId?: IntFilter<"WildArea"> | number
    cityId?: IntNullableFilter<"WildArea"> | number | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    populations?: AnimalPopulationListRelationFilter
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
  }

  export type WildAreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    populations?: AnimalPopulationOrderByRelationAggregateInput
    city?: CityOrderByWithRelationInput
  }

  export type WildAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WildAreaWhereInput | WildAreaWhereInput[]
    OR?: WildAreaWhereInput[]
    NOT?: WildAreaWhereInput | WildAreaWhereInput[]
    name?: StringFilter<"WildArea"> | string
    type?: StringFilter<"WildArea"> | string
    dangerLevel?: IntFilter<"WildArea"> | number
    countryId?: IntFilter<"WildArea"> | number
    cityId?: IntNullableFilter<"WildArea"> | number | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    populations?: AnimalPopulationListRelationFilter
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
  }, "id">

  export type WildAreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrderInput | SortOrder
    _count?: WildAreaCountOrderByAggregateInput
    _avg?: WildAreaAvgOrderByAggregateInput
    _max?: WildAreaMaxOrderByAggregateInput
    _min?: WildAreaMinOrderByAggregateInput
    _sum?: WildAreaSumOrderByAggregateInput
  }

  export type WildAreaScalarWhereWithAggregatesInput = {
    AND?: WildAreaScalarWhereWithAggregatesInput | WildAreaScalarWhereWithAggregatesInput[]
    OR?: WildAreaScalarWhereWithAggregatesInput[]
    NOT?: WildAreaScalarWhereWithAggregatesInput | WildAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WildArea"> | number
    name?: StringWithAggregatesFilter<"WildArea"> | string
    type?: StringWithAggregatesFilter<"WildArea"> | string
    dangerLevel?: IntWithAggregatesFilter<"WildArea"> | number
    countryId?: IntWithAggregatesFilter<"WildArea"> | number
    cityId?: IntNullableWithAggregatesFilter<"WildArea"> | number | null
  }

  export type DungeonWhereInput = {
    AND?: DungeonWhereInput | DungeonWhereInput[]
    OR?: DungeonWhereInput[]
    NOT?: DungeonWhereInput | DungeonWhereInput[]
    id?: IntFilter<"Dungeon"> | number
    name?: StringFilter<"Dungeon"> | string
    levelRequirement?: IntFilter<"Dungeon"> | number
    isRaid?: BoolFilter<"Dungeon"> | boolean
    countryId?: IntFilter<"Dungeon"> | number
    cityId?: IntNullableFilter<"Dungeon"> | number | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
  }

  export type DungeonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    levelRequirement?: SortOrder
    isRaid?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
  }

  export type DungeonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DungeonWhereInput | DungeonWhereInput[]
    OR?: DungeonWhereInput[]
    NOT?: DungeonWhereInput | DungeonWhereInput[]
    name?: StringFilter<"Dungeon"> | string
    levelRequirement?: IntFilter<"Dungeon"> | number
    isRaid?: BoolFilter<"Dungeon"> | boolean
    countryId?: IntFilter<"Dungeon"> | number
    cityId?: IntNullableFilter<"Dungeon"> | number | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
  }, "id">

  export type DungeonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    levelRequirement?: SortOrder
    isRaid?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrderInput | SortOrder
    _count?: DungeonCountOrderByAggregateInput
    _avg?: DungeonAvgOrderByAggregateInput
    _max?: DungeonMaxOrderByAggregateInput
    _min?: DungeonMinOrderByAggregateInput
    _sum?: DungeonSumOrderByAggregateInput
  }

  export type DungeonScalarWhereWithAggregatesInput = {
    AND?: DungeonScalarWhereWithAggregatesInput | DungeonScalarWhereWithAggregatesInput[]
    OR?: DungeonScalarWhereWithAggregatesInput[]
    NOT?: DungeonScalarWhereWithAggregatesInput | DungeonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dungeon"> | number
    name?: StringWithAggregatesFilter<"Dungeon"> | string
    levelRequirement?: IntWithAggregatesFilter<"Dungeon"> | number
    isRaid?: BoolWithAggregatesFilter<"Dungeon"> | boolean
    countryId?: IntWithAggregatesFilter<"Dungeon"> | number
    cityId?: IntNullableWithAggregatesFilter<"Dungeon"> | number | null
  }

  export type QuestWhereInput = {
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    id?: IntFilter<"Quest"> | number
    title?: StringFilter<"Quest"> | string
    description?: StringFilter<"Quest"> | string
    isTaken?: BoolFilter<"Quest"> | boolean
    takenAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    reputationRequired?: IntFilter<"Quest"> | number
    notorietyTrigger?: BoolFilter<"Quest"> | boolean
    issuerId?: IntNullableFilter<"Quest"> | number | null
    takerId?: IntNullableFilter<"Quest"> | number | null
    bountyTargetId?: IntNullableFilter<"Quest"> | number | null
    metadata?: JsonNullableFilter<"Quest">
    issuer?: XOR<NPCNullableScalarRelationFilter, NPCWhereInput> | null
    taker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type QuestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isTaken?: SortOrder
    takenAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    reputationRequired?: SortOrder
    notorietyTrigger?: SortOrder
    issuerId?: SortOrderInput | SortOrder
    takerId?: SortOrderInput | SortOrder
    bountyTargetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    issuer?: NPCOrderByWithRelationInput
    taker?: UserOrderByWithRelationInput
  }

  export type QuestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    title?: StringFilter<"Quest"> | string
    description?: StringFilter<"Quest"> | string
    isTaken?: BoolFilter<"Quest"> | boolean
    takenAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    reputationRequired?: IntFilter<"Quest"> | number
    notorietyTrigger?: BoolFilter<"Quest"> | boolean
    issuerId?: IntNullableFilter<"Quest"> | number | null
    takerId?: IntNullableFilter<"Quest"> | number | null
    bountyTargetId?: IntNullableFilter<"Quest"> | number | null
    metadata?: JsonNullableFilter<"Quest">
    issuer?: XOR<NPCNullableScalarRelationFilter, NPCWhereInput> | null
    taker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type QuestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isTaken?: SortOrder
    takenAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    reputationRequired?: SortOrder
    notorietyTrigger?: SortOrder
    issuerId?: SortOrderInput | SortOrder
    takerId?: SortOrderInput | SortOrder
    bountyTargetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: QuestCountOrderByAggregateInput
    _avg?: QuestAvgOrderByAggregateInput
    _max?: QuestMaxOrderByAggregateInput
    _min?: QuestMinOrderByAggregateInput
    _sum?: QuestSumOrderByAggregateInput
  }

  export type QuestScalarWhereWithAggregatesInput = {
    AND?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    OR?: QuestScalarWhereWithAggregatesInput[]
    NOT?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quest"> | number
    title?: StringWithAggregatesFilter<"Quest"> | string
    description?: StringWithAggregatesFilter<"Quest"> | string
    isTaken?: BoolWithAggregatesFilter<"Quest"> | boolean
    takenAt?: DateTimeNullableWithAggregatesFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Quest"> | Date | string | null
    reputationRequired?: IntWithAggregatesFilter<"Quest"> | number
    notorietyTrigger?: BoolWithAggregatesFilter<"Quest"> | boolean
    issuerId?: IntNullableWithAggregatesFilter<"Quest"> | number | null
    takerId?: IntNullableWithAggregatesFilter<"Quest"> | number | null
    bountyTargetId?: IntNullableWithAggregatesFilter<"Quest"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"Quest">
  }

  export type PlayerProfessionWhereInput = {
    AND?: PlayerProfessionWhereInput | PlayerProfessionWhereInput[]
    OR?: PlayerProfessionWhereInput[]
    NOT?: PlayerProfessionWhereInput | PlayerProfessionWhereInput[]
    id?: IntFilter<"PlayerProfession"> | number
    userId?: IntFilter<"PlayerProfession"> | number
    type?: StringFilter<"PlayerProfession"> | string
    skillLevel?: IntFilter<"PlayerProfession"> | number
    experience?: IntFilter<"PlayerProfession"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlayerProfessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlayerProfessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlayerProfessionWhereInput | PlayerProfessionWhereInput[]
    OR?: PlayerProfessionWhereInput[]
    NOT?: PlayerProfessionWhereInput | PlayerProfessionWhereInput[]
    userId?: IntFilter<"PlayerProfession"> | number
    type?: StringFilter<"PlayerProfession"> | string
    skillLevel?: IntFilter<"PlayerProfession"> | number
    experience?: IntFilter<"PlayerProfession"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PlayerProfessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
    _count?: PlayerProfessionCountOrderByAggregateInput
    _avg?: PlayerProfessionAvgOrderByAggregateInput
    _max?: PlayerProfessionMaxOrderByAggregateInput
    _min?: PlayerProfessionMinOrderByAggregateInput
    _sum?: PlayerProfessionSumOrderByAggregateInput
  }

  export type PlayerProfessionScalarWhereWithAggregatesInput = {
    AND?: PlayerProfessionScalarWhereWithAggregatesInput | PlayerProfessionScalarWhereWithAggregatesInput[]
    OR?: PlayerProfessionScalarWhereWithAggregatesInput[]
    NOT?: PlayerProfessionScalarWhereWithAggregatesInput | PlayerProfessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerProfession"> | number
    userId?: IntWithAggregatesFilter<"PlayerProfession"> | number
    type?: StringWithAggregatesFilter<"PlayerProfession"> | string
    skillLevel?: IntWithAggregatesFilter<"PlayerProfession"> | number
    experience?: IntWithAggregatesFilter<"PlayerProfession"> | number
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    name?: StringFilter<"Item"> | string
    quality?: IntFilter<"Item"> | number
    instances?: ItemInstanceListRelationFilter
    recipesAsProduct?: RecipeListRelationFilter
    recipeMaterials?: RecipeMaterialListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    instances?: ItemInstanceOrderByRelationAggregateInput
    recipesAsProduct?: RecipeOrderByRelationAggregateInput
    recipeMaterials?: RecipeMaterialOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    quality?: IntFilter<"Item"> | number
    instances?: ItemInstanceListRelationFilter
    recipesAsProduct?: RecipeListRelationFilter
    recipeMaterials?: RecipeMaterialListRelationFilter
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    name?: StringWithAggregatesFilter<"Item"> | string
    quality?: IntWithAggregatesFilter<"Item"> | number
  }

  export type ItemInstanceWhereInput = {
    AND?: ItemInstanceWhereInput | ItemInstanceWhereInput[]
    OR?: ItemInstanceWhereInput[]
    NOT?: ItemInstanceWhereInput | ItemInstanceWhereInput[]
    id?: IntFilter<"ItemInstance"> | number
    userId?: IntFilter<"ItemInstance"> | number
    itemId?: IntFilter<"ItemInstance"> | number
    quantity?: IntFilter<"ItemInstance"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ItemInstanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    user?: UserOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type ItemInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemInstanceWhereInput | ItemInstanceWhereInput[]
    OR?: ItemInstanceWhereInput[]
    NOT?: ItemInstanceWhereInput | ItemInstanceWhereInput[]
    userId?: IntFilter<"ItemInstance"> | number
    itemId?: IntFilter<"ItemInstance"> | number
    quantity?: IntFilter<"ItemInstance"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type ItemInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    _count?: ItemInstanceCountOrderByAggregateInput
    _avg?: ItemInstanceAvgOrderByAggregateInput
    _max?: ItemInstanceMaxOrderByAggregateInput
    _min?: ItemInstanceMinOrderByAggregateInput
    _sum?: ItemInstanceSumOrderByAggregateInput
  }

  export type ItemInstanceScalarWhereWithAggregatesInput = {
    AND?: ItemInstanceScalarWhereWithAggregatesInput | ItemInstanceScalarWhereWithAggregatesInput[]
    OR?: ItemInstanceScalarWhereWithAggregatesInput[]
    NOT?: ItemInstanceScalarWhereWithAggregatesInput | ItemInstanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemInstance"> | number
    userId?: IntWithAggregatesFilter<"ItemInstance"> | number
    itemId?: IntWithAggregatesFilter<"ItemInstance"> | number
    quantity?: IntWithAggregatesFilter<"ItemInstance"> | number
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: IntFilter<"Recipe"> | number
    name?: StringFilter<"Recipe"> | string
    profession?: StringFilter<"Recipe"> | string
    difficulty?: IntFilter<"Recipe"> | number
    productId?: IntFilter<"Recipe"> | number
    product?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    materials?: RecipeMaterialListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
    product?: ItemOrderByWithRelationInput
    materials?: RecipeMaterialOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    name?: StringFilter<"Recipe"> | string
    profession?: StringFilter<"Recipe"> | string
    difficulty?: IntFilter<"Recipe"> | number
    productId?: IntFilter<"Recipe"> | number
    product?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    materials?: RecipeMaterialListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Recipe"> | number
    name?: StringWithAggregatesFilter<"Recipe"> | string
    profession?: StringWithAggregatesFilter<"Recipe"> | string
    difficulty?: IntWithAggregatesFilter<"Recipe"> | number
    productId?: IntWithAggregatesFilter<"Recipe"> | number
  }

  export type RecipeMaterialWhereInput = {
    AND?: RecipeMaterialWhereInput | RecipeMaterialWhereInput[]
    OR?: RecipeMaterialWhereInput[]
    NOT?: RecipeMaterialWhereInput | RecipeMaterialWhereInput[]
    id?: IntFilter<"RecipeMaterial"> | number
    recipeId?: IntFilter<"RecipeMaterial"> | number
    itemId?: IntFilter<"RecipeMaterial"> | number
    quantity?: IntFilter<"RecipeMaterial"> | number
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type RecipeMaterialOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type RecipeMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecipeMaterialWhereInput | RecipeMaterialWhereInput[]
    OR?: RecipeMaterialWhereInput[]
    NOT?: RecipeMaterialWhereInput | RecipeMaterialWhereInput[]
    recipeId?: IntFilter<"RecipeMaterial"> | number
    itemId?: IntFilter<"RecipeMaterial"> | number
    quantity?: IntFilter<"RecipeMaterial"> | number
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type RecipeMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    _count?: RecipeMaterialCountOrderByAggregateInput
    _avg?: RecipeMaterialAvgOrderByAggregateInput
    _max?: RecipeMaterialMaxOrderByAggregateInput
    _min?: RecipeMaterialMinOrderByAggregateInput
    _sum?: RecipeMaterialSumOrderByAggregateInput
  }

  export type RecipeMaterialScalarWhereWithAggregatesInput = {
    AND?: RecipeMaterialScalarWhereWithAggregatesInput | RecipeMaterialScalarWhereWithAggregatesInput[]
    OR?: RecipeMaterialScalarWhereWithAggregatesInput[]
    NOT?: RecipeMaterialScalarWhereWithAggregatesInput | RecipeMaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecipeMaterial"> | number
    recipeId?: IntWithAggregatesFilter<"RecipeMaterial"> | number
    itemId?: IntWithAggregatesFilter<"RecipeMaterial"> | number
    quantity?: IntWithAggregatesFilter<"RecipeMaterial"> | number
  }

  export type CorpseWhereInput = {
    AND?: CorpseWhereInput | CorpseWhereInput[]
    OR?: CorpseWhereInput[]
    NOT?: CorpseWhereInput | CorpseWhereInput[]
    id?: IntFilter<"Corpse"> | number
    npcId?: IntNullableFilter<"Corpse"> | number | null
    userId?: IntNullableFilter<"Corpse"> | number | null
    type?: StringFilter<"Corpse"> | string
    decayStage?: StringFilter<"Corpse"> | string
    location?: StringFilter<"Corpse"> | string
    causeOfDeath?: StringNullableFilter<"Corpse"> | string | null
    isWaterlogged?: BoolFilter<"Corpse"> | boolean
    createdAt?: DateTimeFilter<"Corpse"> | Date | string
    updatedAt?: DateTimeFilter<"Corpse"> | Date | string
  }

  export type CorpseOrderByWithRelationInput = {
    id?: SortOrder
    npcId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    decayStage?: SortOrder
    location?: SortOrder
    causeOfDeath?: SortOrderInput | SortOrder
    isWaterlogged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorpseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorpseWhereInput | CorpseWhereInput[]
    OR?: CorpseWhereInput[]
    NOT?: CorpseWhereInput | CorpseWhereInput[]
    npcId?: IntNullableFilter<"Corpse"> | number | null
    userId?: IntNullableFilter<"Corpse"> | number | null
    type?: StringFilter<"Corpse"> | string
    decayStage?: StringFilter<"Corpse"> | string
    location?: StringFilter<"Corpse"> | string
    causeOfDeath?: StringNullableFilter<"Corpse"> | string | null
    isWaterlogged?: BoolFilter<"Corpse"> | boolean
    createdAt?: DateTimeFilter<"Corpse"> | Date | string
    updatedAt?: DateTimeFilter<"Corpse"> | Date | string
  }, "id">

  export type CorpseOrderByWithAggregationInput = {
    id?: SortOrder
    npcId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    decayStage?: SortOrder
    location?: SortOrder
    causeOfDeath?: SortOrderInput | SortOrder
    isWaterlogged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorpseCountOrderByAggregateInput
    _avg?: CorpseAvgOrderByAggregateInput
    _max?: CorpseMaxOrderByAggregateInput
    _min?: CorpseMinOrderByAggregateInput
    _sum?: CorpseSumOrderByAggregateInput
  }

  export type CorpseScalarWhereWithAggregatesInput = {
    AND?: CorpseScalarWhereWithAggregatesInput | CorpseScalarWhereWithAggregatesInput[]
    OR?: CorpseScalarWhereWithAggregatesInput[]
    NOT?: CorpseScalarWhereWithAggregatesInput | CorpseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Corpse"> | number
    npcId?: IntNullableWithAggregatesFilter<"Corpse"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Corpse"> | number | null
    type?: StringWithAggregatesFilter<"Corpse"> | string
    decayStage?: StringWithAggregatesFilter<"Corpse"> | string
    location?: StringWithAggregatesFilter<"Corpse"> | string
    causeOfDeath?: StringNullableWithAggregatesFilter<"Corpse"> | string | null
    isWaterlogged?: BoolWithAggregatesFilter<"Corpse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Corpse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Corpse"> | Date | string
  }

  export type AnimalPopulationWhereInput = {
    AND?: AnimalPopulationWhereInput | AnimalPopulationWhereInput[]
    OR?: AnimalPopulationWhereInput[]
    NOT?: AnimalPopulationWhereInput | AnimalPopulationWhereInput[]
    id?: IntFilter<"AnimalPopulation"> | number
    species?: StringFilter<"AnimalPopulation"> | string
    type?: StringFilter<"AnimalPopulation"> | string
    population?: IntFilter<"AnimalPopulation"> | number
    areaId?: IntFilter<"AnimalPopulation"> | number
    area?: XOR<WildAreaScalarRelationFilter, WildAreaWhereInput>
  }

  export type AnimalPopulationOrderByWithRelationInput = {
    id?: SortOrder
    species?: SortOrder
    type?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
    area?: WildAreaOrderByWithRelationInput
  }

  export type AnimalPopulationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnimalPopulationWhereInput | AnimalPopulationWhereInput[]
    OR?: AnimalPopulationWhereInput[]
    NOT?: AnimalPopulationWhereInput | AnimalPopulationWhereInput[]
    species?: StringFilter<"AnimalPopulation"> | string
    type?: StringFilter<"AnimalPopulation"> | string
    population?: IntFilter<"AnimalPopulation"> | number
    areaId?: IntFilter<"AnimalPopulation"> | number
    area?: XOR<WildAreaScalarRelationFilter, WildAreaWhereInput>
  }, "id">

  export type AnimalPopulationOrderByWithAggregationInput = {
    id?: SortOrder
    species?: SortOrder
    type?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
    _count?: AnimalPopulationCountOrderByAggregateInput
    _avg?: AnimalPopulationAvgOrderByAggregateInput
    _max?: AnimalPopulationMaxOrderByAggregateInput
    _min?: AnimalPopulationMinOrderByAggregateInput
    _sum?: AnimalPopulationSumOrderByAggregateInput
  }

  export type AnimalPopulationScalarWhereWithAggregatesInput = {
    AND?: AnimalPopulationScalarWhereWithAggregatesInput | AnimalPopulationScalarWhereWithAggregatesInput[]
    OR?: AnimalPopulationScalarWhereWithAggregatesInput[]
    NOT?: AnimalPopulationScalarWhereWithAggregatesInput | AnimalPopulationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AnimalPopulation"> | number
    species?: StringWithAggregatesFilter<"AnimalPopulation"> | string
    type?: StringWithAggregatesFilter<"AnimalPopulation"> | string
    population?: IntWithAggregatesFilter<"AnimalPopulation"> | number
    areaId?: IntWithAggregatesFilter<"AnimalPopulation"> | number
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: IntFilter<"Language"> | number
    name?: StringFilter<"Language"> | string
    isAncient?: BoolFilter<"Language"> | boolean
    region?: StringNullableFilter<"Language"> | string | null
    speakers?: NPCListRelationFilter
    userLanguages?: UserLanguageListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isAncient?: SortOrder
    region?: SortOrderInput | SortOrder
    speakers?: NPCOrderByRelationAggregateInput
    userLanguages?: UserLanguageOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    isAncient?: BoolFilter<"Language"> | boolean
    region?: StringNullableFilter<"Language"> | string | null
    speakers?: NPCListRelationFilter
    userLanguages?: UserLanguageListRelationFilter
  }, "id" | "name">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isAncient?: SortOrder
    region?: SortOrderInput | SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Language"> | number
    name?: StringWithAggregatesFilter<"Language"> | string
    isAncient?: BoolWithAggregatesFilter<"Language"> | boolean
    region?: StringNullableWithAggregatesFilter<"Language"> | string | null
  }

  export type UserLanguageWhereInput = {
    AND?: UserLanguageWhereInput | UserLanguageWhereInput[]
    OR?: UserLanguageWhereInput[]
    NOT?: UserLanguageWhereInput | UserLanguageWhereInput[]
    id?: IntFilter<"UserLanguage"> | number
    userId?: IntFilter<"UserLanguage"> | number
    languageId?: IntFilter<"UserLanguage"> | number
    fluency?: IntFilter<"UserLanguage"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }

  export type UserLanguageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
    user?: UserOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type UserLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserLanguageWhereInput | UserLanguageWhereInput[]
    OR?: UserLanguageWhereInput[]
    NOT?: UserLanguageWhereInput | UserLanguageWhereInput[]
    userId?: IntFilter<"UserLanguage"> | number
    languageId?: IntFilter<"UserLanguage"> | number
    fluency?: IntFilter<"UserLanguage"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }, "id">

  export type UserLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
    _count?: UserLanguageCountOrderByAggregateInput
    _avg?: UserLanguageAvgOrderByAggregateInput
    _max?: UserLanguageMaxOrderByAggregateInput
    _min?: UserLanguageMinOrderByAggregateInput
    _sum?: UserLanguageSumOrderByAggregateInput
  }

  export type UserLanguageScalarWhereWithAggregatesInput = {
    AND?: UserLanguageScalarWhereWithAggregatesInput | UserLanguageScalarWhereWithAggregatesInput[]
    OR?: UserLanguageScalarWhereWithAggregatesInput[]
    NOT?: UserLanguageScalarWhereWithAggregatesInput | UserLanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserLanguage"> | number
    userId?: IntWithAggregatesFilter<"UserLanguage"> | number
    languageId?: IntWithAggregatesFilter<"UserLanguage"> | number
    fluency?: IntWithAggregatesFilter<"UserLanguage"> | number
  }

  export type ReligionWhereInput = {
    AND?: ReligionWhereInput | ReligionWhereInput[]
    OR?: ReligionWhereInput[]
    NOT?: ReligionWhereInput | ReligionWhereInput[]
    id?: IntFilter<"Religion"> | number
    name?: StringFilter<"Religion"> | string
    originRegion?: StringFilter<"Religion"> | string
    description?: StringFilter<"Religion"> | string
    doctrine?: StringFilter<"Religion"> | string
    influenceLevel?: IntFilter<"Religion"> | number
    estimatedFollowers?: IntFilter<"Religion"> | number
    artifacts?: ArtifactListRelationFilter
    followers?: NPCListRelationFilter
  }

  export type ReligionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originRegion?: SortOrder
    description?: SortOrder
    doctrine?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
    artifacts?: ArtifactOrderByRelationAggregateInput
    followers?: NPCOrderByRelationAggregateInput
  }

  export type ReligionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReligionWhereInput | ReligionWhereInput[]
    OR?: ReligionWhereInput[]
    NOT?: ReligionWhereInput | ReligionWhereInput[]
    name?: StringFilter<"Religion"> | string
    originRegion?: StringFilter<"Religion"> | string
    description?: StringFilter<"Religion"> | string
    doctrine?: StringFilter<"Religion"> | string
    influenceLevel?: IntFilter<"Religion"> | number
    estimatedFollowers?: IntFilter<"Religion"> | number
    artifacts?: ArtifactListRelationFilter
    followers?: NPCListRelationFilter
  }, "id">

  export type ReligionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originRegion?: SortOrder
    description?: SortOrder
    doctrine?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
    _count?: ReligionCountOrderByAggregateInput
    _avg?: ReligionAvgOrderByAggregateInput
    _max?: ReligionMaxOrderByAggregateInput
    _min?: ReligionMinOrderByAggregateInput
    _sum?: ReligionSumOrderByAggregateInput
  }

  export type ReligionScalarWhereWithAggregatesInput = {
    AND?: ReligionScalarWhereWithAggregatesInput | ReligionScalarWhereWithAggregatesInput[]
    OR?: ReligionScalarWhereWithAggregatesInput[]
    NOT?: ReligionScalarWhereWithAggregatesInput | ReligionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Religion"> | number
    name?: StringWithAggregatesFilter<"Religion"> | string
    originRegion?: StringWithAggregatesFilter<"Religion"> | string
    description?: StringWithAggregatesFilter<"Religion"> | string
    doctrine?: StringWithAggregatesFilter<"Religion"> | string
    influenceLevel?: IntWithAggregatesFilter<"Religion"> | number
    estimatedFollowers?: IntWithAggregatesFilter<"Religion"> | number
  }

  export type ArtifactWhereInput = {
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    id?: IntFilter<"Artifact"> | number
    name?: StringFilter<"Artifact"> | string
    lore?: StringFilter<"Artifact"> | string
    powerHint?: StringFilter<"Artifact"> | string
    religionId?: IntFilter<"Artifact"> | number
    religion?: XOR<ReligionScalarRelationFilter, ReligionWhereInput>
  }

  export type ArtifactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lore?: SortOrder
    powerHint?: SortOrder
    religionId?: SortOrder
    religion?: ReligionOrderByWithRelationInput
  }

  export type ArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    name?: StringFilter<"Artifact"> | string
    lore?: StringFilter<"Artifact"> | string
    powerHint?: StringFilter<"Artifact"> | string
    religionId?: IntFilter<"Artifact"> | number
    religion?: XOR<ReligionScalarRelationFilter, ReligionWhereInput>
  }, "id">

  export type ArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lore?: SortOrder
    powerHint?: SortOrder
    religionId?: SortOrder
    _count?: ArtifactCountOrderByAggregateInput
    _avg?: ArtifactAvgOrderByAggregateInput
    _max?: ArtifactMaxOrderByAggregateInput
    _min?: ArtifactMinOrderByAggregateInput
    _sum?: ArtifactSumOrderByAggregateInput
  }

  export type ArtifactScalarWhereWithAggregatesInput = {
    AND?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    OR?: ArtifactScalarWhereWithAggregatesInput[]
    NOT?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Artifact"> | number
    name?: StringWithAggregatesFilter<"Artifact"> | string
    lore?: StringWithAggregatesFilter<"Artifact"> | string
    powerHint?: StringWithAggregatesFilter<"Artifact"> | string
    religionId?: IntWithAggregatesFilter<"Artifact"> | number
  }

  export type GlobalEventWhereInput = {
    AND?: GlobalEventWhereInput | GlobalEventWhereInput[]
    OR?: GlobalEventWhereInput[]
    NOT?: GlobalEventWhereInput | GlobalEventWhereInput[]
    id?: IntFilter<"GlobalEvent"> | number
    title?: StringFilter<"GlobalEvent"> | string
    type?: StringFilter<"GlobalEvent"> | string
    affectedRegion?: StringFilter<"GlobalEvent"> | string
    description?: StringFilter<"GlobalEvent"> | string
    durationDays?: IntFilter<"GlobalEvent"> | number
    impact?: StringFilter<"GlobalEvent"> | string
    isActive?: BoolFilter<"GlobalEvent"> | boolean
    startedAt?: DateTimeFilter<"GlobalEvent"> | Date | string
    endedAt?: DateTimeNullableFilter<"GlobalEvent"> | Date | string | null
  }

  export type GlobalEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    affectedRegion?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    impact?: SortOrder
    isActive?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
  }

  export type GlobalEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GlobalEventWhereInput | GlobalEventWhereInput[]
    OR?: GlobalEventWhereInput[]
    NOT?: GlobalEventWhereInput | GlobalEventWhereInput[]
    title?: StringFilter<"GlobalEvent"> | string
    type?: StringFilter<"GlobalEvent"> | string
    affectedRegion?: StringFilter<"GlobalEvent"> | string
    description?: StringFilter<"GlobalEvent"> | string
    durationDays?: IntFilter<"GlobalEvent"> | number
    impact?: StringFilter<"GlobalEvent"> | string
    isActive?: BoolFilter<"GlobalEvent"> | boolean
    startedAt?: DateTimeFilter<"GlobalEvent"> | Date | string
    endedAt?: DateTimeNullableFilter<"GlobalEvent"> | Date | string | null
  }, "id">

  export type GlobalEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    affectedRegion?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    impact?: SortOrder
    isActive?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: GlobalEventCountOrderByAggregateInput
    _avg?: GlobalEventAvgOrderByAggregateInput
    _max?: GlobalEventMaxOrderByAggregateInput
    _min?: GlobalEventMinOrderByAggregateInput
    _sum?: GlobalEventSumOrderByAggregateInput
  }

  export type GlobalEventScalarWhereWithAggregatesInput = {
    AND?: GlobalEventScalarWhereWithAggregatesInput | GlobalEventScalarWhereWithAggregatesInput[]
    OR?: GlobalEventScalarWhereWithAggregatesInput[]
    NOT?: GlobalEventScalarWhereWithAggregatesInput | GlobalEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GlobalEvent"> | number
    title?: StringWithAggregatesFilter<"GlobalEvent"> | string
    type?: StringWithAggregatesFilter<"GlobalEvent"> | string
    affectedRegion?: StringWithAggregatesFilter<"GlobalEvent"> | string
    description?: StringWithAggregatesFilter<"GlobalEvent"> | string
    durationDays?: IntWithAggregatesFilter<"GlobalEvent"> | number
    impact?: StringWithAggregatesFilter<"GlobalEvent"> | string
    isActive?: BoolWithAggregatesFilter<"GlobalEvent"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"GlobalEvent"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"GlobalEvent"> | Date | string | null
  }

  export type WeatherWhereInput = {
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    id?: IntFilter<"Weather"> | number
    cityId?: IntFilter<"Weather"> | number
    condition?: StringFilter<"Weather"> | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type WeatherOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    condition?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type WeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cityId?: number
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    condition?: StringFilter<"Weather"> | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id" | "cityId">

  export type WeatherOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    condition?: SortOrder
    updatedAt?: SortOrder
    _count?: WeatherCountOrderByAggregateInput
    _avg?: WeatherAvgOrderByAggregateInput
    _max?: WeatherMaxOrderByAggregateInput
    _min?: WeatherMinOrderByAggregateInput
    _sum?: WeatherSumOrderByAggregateInput
  }

  export type WeatherScalarWhereWithAggregatesInput = {
    AND?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    OR?: WeatherScalarWhereWithAggregatesInput[]
    NOT?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Weather"> | number
    cityId?: IntWithAggregatesFilter<"Weather"> | number
    condition?: StringWithAggregatesFilter<"Weather"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
  }

  export type NPCStoryWhereInput = {
    AND?: NPCStoryWhereInput | NPCStoryWhereInput[]
    OR?: NPCStoryWhereInput[]
    NOT?: NPCStoryWhereInput | NPCStoryWhereInput[]
    id?: IntFilter<"NPCStory"> | number
    npcId?: IntFilter<"NPCStory"> | number
    title?: StringFilter<"NPCStory"> | string
    summary?: StringFilter<"NPCStory"> | string
    createdAt?: DateTimeFilter<"NPCStory"> | Date | string
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
  }

  export type NPCStoryOrderByWithRelationInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    npc?: NPCOrderByWithRelationInput
  }

  export type NPCStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NPCStoryWhereInput | NPCStoryWhereInput[]
    OR?: NPCStoryWhereInput[]
    NOT?: NPCStoryWhereInput | NPCStoryWhereInput[]
    npcId?: IntFilter<"NPCStory"> | number
    title?: StringFilter<"NPCStory"> | string
    summary?: StringFilter<"NPCStory"> | string
    createdAt?: DateTimeFilter<"NPCStory"> | Date | string
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
  }, "id">

  export type NPCStoryOrderByWithAggregationInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    _count?: NPCStoryCountOrderByAggregateInput
    _avg?: NPCStoryAvgOrderByAggregateInput
    _max?: NPCStoryMaxOrderByAggregateInput
    _min?: NPCStoryMinOrderByAggregateInput
    _sum?: NPCStorySumOrderByAggregateInput
  }

  export type NPCStoryScalarWhereWithAggregatesInput = {
    AND?: NPCStoryScalarWhereWithAggregatesInput | NPCStoryScalarWhereWithAggregatesInput[]
    OR?: NPCStoryScalarWhereWithAggregatesInput[]
    NOT?: NPCStoryScalarWhereWithAggregatesInput | NPCStoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NPCStory"> | number
    npcId?: IntWithAggregatesFilter<"NPCStory"> | number
    title?: StringWithAggregatesFilter<"NPCStory"> | string
    summary?: StringWithAggregatesFilter<"NPCStory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NPCStory"> | Date | string
  }

  export type PlayerTitleWhereInput = {
    AND?: PlayerTitleWhereInput | PlayerTitleWhereInput[]
    OR?: PlayerTitleWhereInput[]
    NOT?: PlayerTitleWhereInput | PlayerTitleWhereInput[]
    id?: IntFilter<"PlayerTitle"> | number
    userId?: IntFilter<"PlayerTitle"> | number
    type?: StringFilter<"PlayerTitle"> | string
    region?: StringFilter<"PlayerTitle"> | string
    grantedAt?: DateTimeFilter<"PlayerTitle"> | Date | string
    authority?: IntFilter<"PlayerTitle"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlayerTitleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    region?: SortOrder
    grantedAt?: SortOrder
    authority?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlayerTitleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlayerTitleWhereInput | PlayerTitleWhereInput[]
    OR?: PlayerTitleWhereInput[]
    NOT?: PlayerTitleWhereInput | PlayerTitleWhereInput[]
    userId?: IntFilter<"PlayerTitle"> | number
    type?: StringFilter<"PlayerTitle"> | string
    region?: StringFilter<"PlayerTitle"> | string
    grantedAt?: DateTimeFilter<"PlayerTitle"> | Date | string
    authority?: IntFilter<"PlayerTitle"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PlayerTitleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    region?: SortOrder
    grantedAt?: SortOrder
    authority?: SortOrder
    _count?: PlayerTitleCountOrderByAggregateInput
    _avg?: PlayerTitleAvgOrderByAggregateInput
    _max?: PlayerTitleMaxOrderByAggregateInput
    _min?: PlayerTitleMinOrderByAggregateInput
    _sum?: PlayerTitleSumOrderByAggregateInput
  }

  export type PlayerTitleScalarWhereWithAggregatesInput = {
    AND?: PlayerTitleScalarWhereWithAggregatesInput | PlayerTitleScalarWhereWithAggregatesInput[]
    OR?: PlayerTitleScalarWhereWithAggregatesInput[]
    NOT?: PlayerTitleScalarWhereWithAggregatesInput | PlayerTitleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerTitle"> | number
    userId?: IntWithAggregatesFilter<"PlayerTitle"> | number
    type?: StringWithAggregatesFilter<"PlayerTitle"> | string
    region?: StringWithAggregatesFilter<"PlayerTitle"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"PlayerTitle"> | Date | string
    authority?: IntWithAggregatesFilter<"PlayerTitle"> | number
  }

  export type EconomyWhereInput = {
    AND?: EconomyWhereInput | EconomyWhereInput[]
    OR?: EconomyWhereInput[]
    NOT?: EconomyWhereInput | EconomyWhereInput[]
    id?: IntFilter<"Economy"> | number
    cityId?: IntFilter<"Economy"> | number
    item?: StringFilter<"Economy"> | string
    price?: IntFilter<"Economy"> | number
    demand?: StringFilter<"Economy"> | string
    supply?: StringFilter<"Economy"> | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type EconomyOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    item?: SortOrder
    price?: SortOrder
    demand?: SortOrder
    supply?: SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type EconomyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cityId_item?: EconomyCityId_itemCompoundUniqueInput
    AND?: EconomyWhereInput | EconomyWhereInput[]
    OR?: EconomyWhereInput[]
    NOT?: EconomyWhereInput | EconomyWhereInput[]
    cityId?: IntFilter<"Economy"> | number
    item?: StringFilter<"Economy"> | string
    price?: IntFilter<"Economy"> | number
    demand?: StringFilter<"Economy"> | string
    supply?: StringFilter<"Economy"> | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id" | "cityId_item">

  export type EconomyOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    item?: SortOrder
    price?: SortOrder
    demand?: SortOrder
    supply?: SortOrder
    _count?: EconomyCountOrderByAggregateInput
    _avg?: EconomyAvgOrderByAggregateInput
    _max?: EconomyMaxOrderByAggregateInput
    _min?: EconomyMinOrderByAggregateInput
    _sum?: EconomySumOrderByAggregateInput
  }

  export type EconomyScalarWhereWithAggregatesInput = {
    AND?: EconomyScalarWhereWithAggregatesInput | EconomyScalarWhereWithAggregatesInput[]
    OR?: EconomyScalarWhereWithAggregatesInput[]
    NOT?: EconomyScalarWhereWithAggregatesInput | EconomyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Economy"> | number
    cityId?: IntWithAggregatesFilter<"Economy"> | number
    item?: StringWithAggregatesFilter<"Economy"> | string
    price?: IntWithAggregatesFilter<"Economy"> | number
    demand?: StringWithAggregatesFilter<"Economy"> | string
    supply?: StringWithAggregatesFilter<"Economy"> | string
  }

  export type WorldTimeWhereInput = {
    AND?: WorldTimeWhereInput | WorldTimeWhereInput[]
    OR?: WorldTimeWhereInput[]
    NOT?: WorldTimeWhereInput | WorldTimeWhereInput[]
    id?: IntFilter<"WorldTime"> | number
    lastSimulated?: DateTimeFilter<"WorldTime"> | Date | string
  }

  export type WorldTimeOrderByWithRelationInput = {
    id?: SortOrder
    lastSimulated?: SortOrder
  }

  export type WorldTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorldTimeWhereInput | WorldTimeWhereInput[]
    OR?: WorldTimeWhereInput[]
    NOT?: WorldTimeWhereInput | WorldTimeWhereInput[]
    lastSimulated?: DateTimeFilter<"WorldTime"> | Date | string
  }, "id">

  export type WorldTimeOrderByWithAggregationInput = {
    id?: SortOrder
    lastSimulated?: SortOrder
    _count?: WorldTimeCountOrderByAggregateInput
    _avg?: WorldTimeAvgOrderByAggregateInput
    _max?: WorldTimeMaxOrderByAggregateInput
    _min?: WorldTimeMinOrderByAggregateInput
    _sum?: WorldTimeSumOrderByAggregateInput
  }

  export type WorldTimeScalarWhereWithAggregatesInput = {
    AND?: WorldTimeScalarWhereWithAggregatesInput | WorldTimeScalarWhereWithAggregatesInput[]
    OR?: WorldTimeScalarWhereWithAggregatesInput[]
    NOT?: WorldTimeScalarWhereWithAggregatesInput | WorldTimeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorldTime"> | number
    lastSimulated?: DateTimeWithAggregatesFilter<"WorldTime"> | Date | string
  }

  export type WorldSnapshotWhereInput = {
    AND?: WorldSnapshotWhereInput | WorldSnapshotWhereInput[]
    OR?: WorldSnapshotWhereInput[]
    NOT?: WorldSnapshotWhereInput | WorldSnapshotWhereInput[]
    id?: IntFilter<"WorldSnapshot"> | number
    label?: StringFilter<"WorldSnapshot"> | string
    jsonData?: JsonFilter<"WorldSnapshot">
    createdAt?: DateTimeFilter<"WorldSnapshot"> | Date | string
  }

  export type WorldSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    jsonData?: SortOrder
    createdAt?: SortOrder
  }

  export type WorldSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorldSnapshotWhereInput | WorldSnapshotWhereInput[]
    OR?: WorldSnapshotWhereInput[]
    NOT?: WorldSnapshotWhereInput | WorldSnapshotWhereInput[]
    label?: StringFilter<"WorldSnapshot"> | string
    jsonData?: JsonFilter<"WorldSnapshot">
    createdAt?: DateTimeFilter<"WorldSnapshot"> | Date | string
  }, "id">

  export type WorldSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    jsonData?: SortOrder
    createdAt?: SortOrder
    _count?: WorldSnapshotCountOrderByAggregateInput
    _avg?: WorldSnapshotAvgOrderByAggregateInput
    _max?: WorldSnapshotMaxOrderByAggregateInput
    _min?: WorldSnapshotMinOrderByAggregateInput
    _sum?: WorldSnapshotSumOrderByAggregateInput
  }

  export type WorldSnapshotScalarWhereWithAggregatesInput = {
    AND?: WorldSnapshotScalarWhereWithAggregatesInput | WorldSnapshotScalarWhereWithAggregatesInput[]
    OR?: WorldSnapshotScalarWhereWithAggregatesInput[]
    NOT?: WorldSnapshotScalarWhereWithAggregatesInput | WorldSnapshotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorldSnapshot"> | number
    label?: StringWithAggregatesFilter<"WorldSnapshot"> | string
    jsonData?: JsonWithAggregatesFilter<"WorldSnapshot">
    createdAt?: DateTimeWithAggregatesFilter<"WorldSnapshot"> | Date | string
  }

  export type TaxPolicyWhereInput = {
    AND?: TaxPolicyWhereInput | TaxPolicyWhereInput[]
    OR?: TaxPolicyWhereInput[]
    NOT?: TaxPolicyWhereInput | TaxPolicyWhereInput[]
    id?: IntFilter<"TaxPolicy"> | number
    region?: StringFilter<"TaxPolicy"> | string
    rate?: IntFilter<"TaxPolicy"> | number
    updatedAt?: DateTimeFilter<"TaxPolicy"> | Date | string
  }

  export type TaxPolicyOrderByWithRelationInput = {
    id?: SortOrder
    region?: SortOrder
    rate?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    region?: string
    AND?: TaxPolicyWhereInput | TaxPolicyWhereInput[]
    OR?: TaxPolicyWhereInput[]
    NOT?: TaxPolicyWhereInput | TaxPolicyWhereInput[]
    rate?: IntFilter<"TaxPolicy"> | number
    updatedAt?: DateTimeFilter<"TaxPolicy"> | Date | string
  }, "id" | "region">

  export type TaxPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    region?: SortOrder
    rate?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxPolicyCountOrderByAggregateInput
    _avg?: TaxPolicyAvgOrderByAggregateInput
    _max?: TaxPolicyMaxOrderByAggregateInput
    _min?: TaxPolicyMinOrderByAggregateInput
    _sum?: TaxPolicySumOrderByAggregateInput
  }

  export type TaxPolicyScalarWhereWithAggregatesInput = {
    AND?: TaxPolicyScalarWhereWithAggregatesInput | TaxPolicyScalarWhereWithAggregatesInput[]
    OR?: TaxPolicyScalarWhereWithAggregatesInput[]
    NOT?: TaxPolicyScalarWhereWithAggregatesInput | TaxPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaxPolicy"> | number
    region?: StringWithAggregatesFilter<"TaxPolicy"> | string
    rate?: IntWithAggregatesFilter<"TaxPolicy"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"TaxPolicy"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceCreateNestedManyWithoutUserInput
    titles?: PlayerTitleCreateNestedManyWithoutUserInput
    languages?: UserLanguageCreateNestedManyWithoutUserInput
    quests?: QuestCreateNestedManyWithoutTakerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionUncheckedCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceUncheckedCreateNestedManyWithoutUserInput
    titles?: PlayerTitleUncheckedCreateNestedManyWithoutUserInput
    languages?: UserLanguageUncheckedCreateNestedManyWithoutUserInput
    quests?: QuestUncheckedCreateNestedManyWithoutTakerInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUpdateManyWithoutUserNestedInput
    quests?: QuestUpdateManyWithoutTakerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUncheckedUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUncheckedUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUncheckedUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUncheckedUpdateManyWithoutUserNestedInput
    quests?: QuestUncheckedUpdateManyWithoutTakerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NPCCreateInput = {
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    city: CityCreateNestedOneWithoutNpcsInput
    language: LanguageCreateNestedOneWithoutSpeakersInput
    religion?: ReligionCreateNestedOneWithoutFollowersInput
    stories?: NPCStoryCreateNestedManyWithoutNpcInput
    quests?: QuestCreateNestedManyWithoutIssuerInput
  }

  export type NPCUncheckedCreateInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId?: number | null
    stories?: NPCStoryUncheckedCreateNestedManyWithoutNpcInput
    quests?: QuestUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type NPCUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutNpcsNestedInput
    language?: LanguageUpdateOneRequiredWithoutSpeakersNestedInput
    religion?: ReligionUpdateOneWithoutFollowersNestedInput
    stories?: NPCStoryUpdateManyWithoutNpcNestedInput
    quests?: QuestUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
    stories?: NPCStoryUncheckedUpdateManyWithoutNpcNestedInput
    quests?: QuestUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type NPCCreateManyInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId?: number | null
  }

  export type NPCUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
  }

  export type NPCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CityCreateInput = {
    name: string
    description: string
    population: number
    country: CountryCreateNestedOneWithoutCitiesInput
    wildAreas?: WildAreaCreateNestedManyWithoutCityInput
    dungeons?: DungeonCreateNestedManyWithoutCityInput
    weather?: WeatherCreateNestedOneWithoutCityInput
    npcs?: NPCCreateNestedManyWithoutCityInput
    economies?: EconomyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCityInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCityInput
    weather?: WeatherUncheckedCreateNestedOneWithoutCityInput
    npcs?: NPCUncheckedCreateNestedManyWithoutCityInput
    economies?: EconomyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUpdateManyWithoutCityNestedInput
    weather?: WeatherUpdateOneWithoutCityNestedInput
    npcs?: NPCUpdateManyWithoutCityNestedInput
    economies?: EconomyUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCityNestedInput
    weather?: WeatherUncheckedUpdateOneWithoutCityNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutCityNestedInput
    economies?: EconomyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type CountryCreateInput = {
    name: string
    description: string
    language: string
    cities?: CityCreateNestedManyWithoutCountryInput
    wildAreas?: WildAreaCreateNestedManyWithoutCountryInput
    dungeons?: DungeonCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    language: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCountryInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCountryNestedInput
    dungeons?: DungeonUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCountryNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    description: string
    language: string
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type WildAreaCreateInput = {
    name: string
    type: string
    dangerLevel: number
    country: CountryCreateNestedOneWithoutWildAreasInput
    populations?: AnimalPopulationCreateNestedManyWithoutAreaInput
    city?: CityCreateNestedOneWithoutWildAreasInput
  }

  export type WildAreaUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    countryId: number
    cityId?: number | null
    populations?: AnimalPopulationUncheckedCreateNestedManyWithoutAreaInput
  }

  export type WildAreaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutWildAreasNestedInput
    populations?: AnimalPopulationUpdateManyWithoutAreaNestedInput
    city?: CityUpdateOneWithoutWildAreasNestedInput
  }

  export type WildAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    populations?: AnimalPopulationUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type WildAreaCreateManyInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    countryId: number
    cityId?: number | null
  }

  export type WildAreaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
  }

  export type WildAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DungeonCreateInput = {
    name: string
    levelRequirement: number
    isRaid: boolean
    country: CountryCreateNestedOneWithoutDungeonsInput
    city?: CityCreateNestedOneWithoutDungeonsInput
  }

  export type DungeonUncheckedCreateInput = {
    id?: number
    name: string
    levelRequirement: number
    isRaid: boolean
    countryId: number
    cityId?: number | null
  }

  export type DungeonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    country?: CountryUpdateOneRequiredWithoutDungeonsNestedInput
    city?: CityUpdateOneWithoutDungeonsNestedInput
  }

  export type DungeonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DungeonCreateManyInput = {
    id?: number
    name: string
    levelRequirement: number
    isRaid: boolean
    countryId: number
    cityId?: number | null
  }

  export type DungeonUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DungeonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestCreateInput = {
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    issuer?: NPCCreateNestedOneWithoutQuestsInput
    taker?: UserCreateNestedOneWithoutQuestsInput
  }

  export type QuestUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    issuerId?: number | null
    takerId?: number | null
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    issuer?: NPCUpdateOneWithoutQuestsNestedInput
    taker?: UserUpdateOneWithoutQuestsNestedInput
  }

  export type QuestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    issuerId?: NullableIntFieldUpdateOperationsInput | number | null
    takerId?: NullableIntFieldUpdateOperationsInput | number | null
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestCreateManyInput = {
    id?: number
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    issuerId?: number | null
    takerId?: number | null
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    issuerId?: NullableIntFieldUpdateOperationsInput | number | null
    takerId?: NullableIntFieldUpdateOperationsInput | number | null
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PlayerProfessionCreateInput = {
    type: string
    skillLevel?: number
    experience?: number
    user: UserCreateNestedOneWithoutProfessionInput
  }

  export type PlayerProfessionUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    skillLevel?: number
    experience?: number
  }

  export type PlayerProfessionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutProfessionNestedInput
  }

  export type PlayerProfessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerProfessionCreateManyInput = {
    id?: number
    userId: number
    type: string
    skillLevel?: number
    experience?: number
  }

  export type PlayerProfessionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerProfessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCreateInput = {
    name: string
    quality: number
    instances?: ItemInstanceCreateNestedManyWithoutItemInput
    recipesAsProduct?: RecipeCreateNestedManyWithoutProductInput
    recipeMaterials?: RecipeMaterialCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    name: string
    quality: number
    instances?: ItemInstanceUncheckedCreateNestedManyWithoutItemInput
    recipesAsProduct?: RecipeUncheckedCreateNestedManyWithoutProductInput
    recipeMaterials?: RecipeMaterialUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    instances?: ItemInstanceUpdateManyWithoutItemNestedInput
    recipesAsProduct?: RecipeUpdateManyWithoutProductNestedInput
    recipeMaterials?: RecipeMaterialUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    instances?: ItemInstanceUncheckedUpdateManyWithoutItemNestedInput
    recipesAsProduct?: RecipeUncheckedUpdateManyWithoutProductNestedInput
    recipeMaterials?: RecipeMaterialUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: number
    name: string
    quality: number
  }

  export type ItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceCreateInput = {
    quantity: number
    user: UserCreateNestedOneWithoutInventoryInput
    item: ItemCreateNestedOneWithoutInstancesInput
  }

  export type ItemInstanceUncheckedCreateInput = {
    id?: number
    userId: number
    itemId: number
    quantity: number
  }

  export type ItemInstanceUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
    item?: ItemUpdateOneRequiredWithoutInstancesNestedInput
  }

  export type ItemInstanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceCreateManyInput = {
    id?: number
    userId: number
    itemId: number
    quantity: number
  }

  export type ItemInstanceUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeCreateInput = {
    name: string
    profession: string
    difficulty: number
    product: ItemCreateNestedOneWithoutRecipesAsProductInput
    materials?: RecipeMaterialCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: number
    name: string
    profession: string
    difficulty: number
    productId: number
    materials?: RecipeMaterialUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    product?: ItemUpdateOneRequiredWithoutRecipesAsProductNestedInput
    materials?: RecipeMaterialUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    materials?: RecipeMaterialUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: number
    name: string
    profession: string
    difficulty: number
    productId: number
  }

  export type RecipeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialCreateInput = {
    quantity: number
    recipe: RecipeCreateNestedOneWithoutMaterialsInput
    item: ItemCreateNestedOneWithoutRecipeMaterialsInput
  }

  export type RecipeMaterialUncheckedCreateInput = {
    id?: number
    recipeId: number
    itemId: number
    quantity: number
  }

  export type RecipeMaterialUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutMaterialsNestedInput
    item?: ItemUpdateOneRequiredWithoutRecipeMaterialsNestedInput
  }

  export type RecipeMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialCreateManyInput = {
    id?: number
    recipeId: number
    itemId: number
    quantity: number
  }

  export type RecipeMaterialUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CorpseCreateInput = {
    npcId?: number | null
    userId?: number | null
    type: string
    decayStage: string
    location: string
    causeOfDeath?: string | null
    isWaterlogged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorpseUncheckedCreateInput = {
    id?: number
    npcId?: number | null
    userId?: number | null
    type: string
    decayStage: string
    location: string
    causeOfDeath?: string | null
    isWaterlogged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorpseUpdateInput = {
    npcId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    decayStage?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    causeOfDeath?: NullableStringFieldUpdateOperationsInput | string | null
    isWaterlogged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorpseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    npcId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    decayStage?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    causeOfDeath?: NullableStringFieldUpdateOperationsInput | string | null
    isWaterlogged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorpseCreateManyInput = {
    id?: number
    npcId?: number | null
    userId?: number | null
    type: string
    decayStage: string
    location: string
    causeOfDeath?: string | null
    isWaterlogged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorpseUpdateManyMutationInput = {
    npcId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    decayStage?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    causeOfDeath?: NullableStringFieldUpdateOperationsInput | string | null
    isWaterlogged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorpseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    npcId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    decayStage?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    causeOfDeath?: NullableStringFieldUpdateOperationsInput | string | null
    isWaterlogged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimalPopulationCreateInput = {
    species: string
    type: string
    population: number
    area: WildAreaCreateNestedOneWithoutPopulationsInput
  }

  export type AnimalPopulationUncheckedCreateInput = {
    id?: number
    species: string
    type: string
    population: number
    areaId: number
  }

  export type AnimalPopulationUpdateInput = {
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    area?: WildAreaUpdateOneRequiredWithoutPopulationsNestedInput
  }

  export type AnimalPopulationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type AnimalPopulationCreateManyInput = {
    id?: number
    species: string
    type: string
    population: number
    areaId: number
  }

  export type AnimalPopulationUpdateManyMutationInput = {
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type AnimalPopulationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    name: string
    isAncient?: boolean
    region?: string | null
    speakers?: NPCCreateNestedManyWithoutLanguageInput
    userLanguages?: UserLanguageCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: number
    name: string
    isAncient?: boolean
    region?: string | null
    speakers?: NPCUncheckedCreateNestedManyWithoutLanguageInput
    userLanguages?: UserLanguageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NPCUpdateManyWithoutLanguageNestedInput
    userLanguages?: UserLanguageUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NPCUncheckedUpdateManyWithoutLanguageNestedInput
    userLanguages?: UserLanguageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: number
    name: string
    isAncient?: boolean
    region?: string | null
  }

  export type LanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLanguageCreateInput = {
    fluency: number
    user: UserCreateNestedOneWithoutLanguagesInput
    language: LanguageCreateNestedOneWithoutUserLanguagesInput
  }

  export type UserLanguageUncheckedCreateInput = {
    id?: number
    userId: number
    languageId: number
    fluency: number
  }

  export type UserLanguageUpdateInput = {
    fluency?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLanguagesNestedInput
    language?: LanguageUpdateOneRequiredWithoutUserLanguagesNestedInput
  }

  export type UserLanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type UserLanguageCreateManyInput = {
    id?: number
    userId: number
    languageId: number
    fluency: number
  }

  export type UserLanguageUpdateManyMutationInput = {
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type UserLanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type ReligionCreateInput = {
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    artifacts?: ArtifactCreateNestedManyWithoutReligionInput
    followers?: NPCCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateInput = {
    id?: number
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutReligionInput
    followers?: NPCUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
    artifacts?: ArtifactUpdateManyWithoutReligionNestedInput
    followers?: NPCUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
    artifacts?: ArtifactUncheckedUpdateManyWithoutReligionNestedInput
    followers?: NPCUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type ReligionCreateManyInput = {
    id?: number
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
  }

  export type ReligionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
  }

  export type ReligionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
  }

  export type ArtifactCreateInput = {
    name: string
    lore: string
    powerHint: string
    religion: ReligionCreateNestedOneWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateInput = {
    id?: number
    name: string
    lore: string
    powerHint: string
    religionId: number
  }

  export type ArtifactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
    religion?: ReligionUpdateOneRequiredWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type ArtifactCreateManyInput = {
    id?: number
    name: string
    lore: string
    powerHint: string
    religionId: number
  }

  export type ArtifactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type GlobalEventCreateInput = {
    title: string
    type: string
    affectedRegion: string
    description: string
    durationDays: number
    impact: string
    isActive?: boolean
    startedAt: Date | string
    endedAt?: Date | string | null
  }

  export type GlobalEventUncheckedCreateInput = {
    id?: number
    title: string
    type: string
    affectedRegion: string
    description: string
    durationDays: number
    impact: string
    isActive?: boolean
    startedAt: Date | string
    endedAt?: Date | string | null
  }

  export type GlobalEventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    affectedRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GlobalEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    affectedRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GlobalEventCreateManyInput = {
    id?: number
    title: string
    type: string
    affectedRegion: string
    description: string
    durationDays: number
    impact: string
    isActive?: boolean
    startedAt: Date | string
    endedAt?: Date | string | null
  }

  export type GlobalEventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    affectedRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GlobalEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    affectedRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeatherCreateInput = {
    condition: string
    updatedAt: Date | string
    city: CityCreateNestedOneWithoutWeatherInput
  }

  export type WeatherUncheckedCreateInput = {
    id?: number
    cityId: number
    condition: string
    updatedAt: Date | string
  }

  export type WeatherUpdateInput = {
    condition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutWeatherNestedInput
  }

  export type WeatherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateManyInput = {
    id?: number
    cityId: number
    condition: string
    updatedAt: Date | string
  }

  export type WeatherUpdateManyMutationInput = {
    condition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCStoryCreateInput = {
    title: string
    summary: string
    createdAt?: Date | string
    npc: NPCCreateNestedOneWithoutStoriesInput
  }

  export type NPCStoryUncheckedCreateInput = {
    id?: number
    npcId: number
    title: string
    summary: string
    createdAt?: Date | string
  }

  export type NPCStoryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npc?: NPCUpdateOneRequiredWithoutStoriesNestedInput
  }

  export type NPCStoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    npcId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCStoryCreateManyInput = {
    id?: number
    npcId: number
    title: string
    summary: string
    createdAt?: Date | string
  }

  export type NPCStoryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCStoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    npcId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerTitleCreateInput = {
    type: string
    region: string
    grantedAt: Date | string
    authority: number
    user: UserCreateNestedOneWithoutTitlesInput
  }

  export type PlayerTitleUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    region: string
    grantedAt: Date | string
    authority: number
  }

  export type PlayerTitleUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutTitlesNestedInput
  }

  export type PlayerTitleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerTitleCreateManyInput = {
    id?: number
    userId: number
    type: string
    region: string
    grantedAt: Date | string
    authority: number
  }

  export type PlayerTitleUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerTitleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
  }

  export type EconomyCreateInput = {
    item: string
    price: number
    demand: string
    supply: string
    city: CityCreateNestedOneWithoutEconomiesInput
  }

  export type EconomyUncheckedCreateInput = {
    id?: number
    cityId: number
    item: string
    price: number
    demand: string
    supply: string
  }

  export type EconomyUpdateInput = {
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutEconomiesNestedInput
  }

  export type EconomyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
  }

  export type EconomyCreateManyInput = {
    id?: number
    cityId: number
    item: string
    price: number
    demand: string
    supply: string
  }

  export type EconomyUpdateManyMutationInput = {
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
  }

  export type EconomyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
  }

  export type WorldTimeCreateInput = {
    lastSimulated: Date | string
  }

  export type WorldTimeUncheckedCreateInput = {
    id?: number
    lastSimulated: Date | string
  }

  export type WorldTimeUpdateInput = {
    lastSimulated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldTimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastSimulated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldTimeCreateManyInput = {
    id?: number
    lastSimulated: Date | string
  }

  export type WorldTimeUpdateManyMutationInput = {
    lastSimulated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldTimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastSimulated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldSnapshotCreateInput = {
    label: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WorldSnapshotUncheckedCreateInput = {
    id?: number
    label: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WorldSnapshotUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldSnapshotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldSnapshotCreateManyInput = {
    id?: number
    label: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WorldSnapshotUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldSnapshotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPolicyCreateInput = {
    region: string
    rate: number
    updatedAt: Date | string
  }

  export type TaxPolicyUncheckedCreateInput = {
    id?: number
    region: string
    rate: number
    updatedAt: Date | string
  }

  export type TaxPolicyUpdateInput = {
    region?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPolicyCreateManyInput = {
    id?: number
    region: string
    rate: number
    updatedAt: Date | string
  }

  export type TaxPolicyUpdateManyMutationInput = {
    region?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PlayerProfessionListRelationFilter = {
    every?: PlayerProfessionWhereInput
    some?: PlayerProfessionWhereInput
    none?: PlayerProfessionWhereInput
  }

  export type ItemInstanceListRelationFilter = {
    every?: ItemInstanceWhereInput
    some?: ItemInstanceWhereInput
    none?: ItemInstanceWhereInput
  }

  export type PlayerTitleListRelationFilter = {
    every?: PlayerTitleWhereInput
    some?: PlayerTitleWhereInput
    none?: PlayerTitleWhereInput
  }

  export type UserLanguageListRelationFilter = {
    every?: UserLanguageWhereInput
    some?: UserLanguageWhereInput
    none?: UserLanguageWhereInput
  }

  export type QuestListRelationFilter = {
    every?: QuestWhereInput
    some?: QuestWhereInput
    none?: QuestWhereInput
  }

  export type PlayerProfessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerTitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
    isOnline?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
    isOnline?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
    isOnline?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    reputation?: SortOrder
    notoriety?: SortOrder
    maxHp?: SortOrder
    maxMp?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type LanguageScalarRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type ReligionNullableScalarRelationFilter = {
    is?: ReligionWhereInput | null
    isNot?: ReligionWhereInput | null
  }

  export type NPCStoryListRelationFilter = {
    every?: NPCStoryWhereInput
    some?: NPCStoryWhereInput
    none?: NPCStoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NPCStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NPCCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrder
    isAlive?: SortOrder
    mood?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrder
    parent1Id?: SortOrder
    parent2Id?: SortOrder
    isNoble?: SortOrder
    nobleTitle?: SortOrder
    personality?: SortOrder
    background?: SortOrder
    job?: SortOrder
    skills?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrder
  }

  export type NPCAvgOrderByAggregateInput = {
    id?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrder
    parent1Id?: SortOrder
    parent2Id?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrder
  }

  export type NPCMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrder
    isAlive?: SortOrder
    mood?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrder
    parent1Id?: SortOrder
    parent2Id?: SortOrder
    isNoble?: SortOrder
    nobleTitle?: SortOrder
    personality?: SortOrder
    background?: SortOrder
    job?: SortOrder
    skills?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrder
  }

  export type NPCMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrder
    isAlive?: SortOrder
    mood?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrder
    parent1Id?: SortOrder
    parent2Id?: SortOrder
    isNoble?: SortOrder
    nobleTitle?: SortOrder
    personality?: SortOrder
    background?: SortOrder
    job?: SortOrder
    skills?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrder
  }

  export type NPCSumOrderByAggregateInput = {
    id?: SortOrder
    birthYear?: SortOrder
    deathYear?: SortOrder
    fame?: SortOrder
    notoriety?: SortOrder
    cityId?: SortOrder
    partnerId?: SortOrder
    parent1Id?: SortOrder
    parent2Id?: SortOrder
    languageId?: SortOrder
    religionId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type WildAreaListRelationFilter = {
    every?: WildAreaWhereInput
    some?: WildAreaWhereInput
    none?: WildAreaWhereInput
  }

  export type DungeonListRelationFilter = {
    every?: DungeonWhereInput
    some?: DungeonWhereInput
    none?: DungeonWhereInput
  }

  export type WeatherNullableScalarRelationFilter = {
    is?: WeatherWhereInput | null
    isNot?: WeatherWhereInput | null
  }

  export type NPCListRelationFilter = {
    every?: NPCWhereInput
    some?: NPCWhereInput
    none?: NPCWhereInput
  }

  export type EconomyListRelationFilter = {
    every?: EconomyWhereInput
    some?: EconomyWhereInput
    none?: EconomyWhereInput
  }

  export type WildAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DungeonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EconomyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
    countryId?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    language?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    language?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    language?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnimalPopulationListRelationFilter = {
    every?: AnimalPopulationWhereInput
    some?: AnimalPopulationWhereInput
    none?: AnimalPopulationWhereInput
  }

  export type CityNullableScalarRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type AnimalPopulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WildAreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type WildAreaAvgOrderByAggregateInput = {
    id?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type WildAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type WildAreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type WildAreaSumOrderByAggregateInput = {
    id?: SortOrder
    dangerLevel?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type DungeonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    levelRequirement?: SortOrder
    isRaid?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type DungeonAvgOrderByAggregateInput = {
    id?: SortOrder
    levelRequirement?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type DungeonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    levelRequirement?: SortOrder
    isRaid?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type DungeonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    levelRequirement?: SortOrder
    isRaid?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type DungeonSumOrderByAggregateInput = {
    id?: SortOrder
    levelRequirement?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NPCNullableScalarRelationFilter = {
    is?: NPCWhereInput | null
    isNot?: NPCWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type QuestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isTaken?: SortOrder
    takenAt?: SortOrder
    completedAt?: SortOrder
    reputationRequired?: SortOrder
    notorietyTrigger?: SortOrder
    issuerId?: SortOrder
    takerId?: SortOrder
    bountyTargetId?: SortOrder
    metadata?: SortOrder
  }

  export type QuestAvgOrderByAggregateInput = {
    id?: SortOrder
    reputationRequired?: SortOrder
    issuerId?: SortOrder
    takerId?: SortOrder
    bountyTargetId?: SortOrder
  }

  export type QuestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isTaken?: SortOrder
    takenAt?: SortOrder
    completedAt?: SortOrder
    reputationRequired?: SortOrder
    notorietyTrigger?: SortOrder
    issuerId?: SortOrder
    takerId?: SortOrder
    bountyTargetId?: SortOrder
  }

  export type QuestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isTaken?: SortOrder
    takenAt?: SortOrder
    completedAt?: SortOrder
    reputationRequired?: SortOrder
    notorietyTrigger?: SortOrder
    issuerId?: SortOrder
    takerId?: SortOrder
    bountyTargetId?: SortOrder
  }

  export type QuestSumOrderByAggregateInput = {
    id?: SortOrder
    reputationRequired?: SortOrder
    issuerId?: SortOrder
    takerId?: SortOrder
    bountyTargetId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PlayerProfessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
  }

  export type PlayerProfessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
  }

  export type PlayerProfessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
  }

  export type PlayerProfessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
  }

  export type PlayerProfessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillLevel?: SortOrder
    experience?: SortOrder
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type RecipeMaterialListRelationFilter = {
    every?: RecipeMaterialWhereInput
    some?: RecipeMaterialWhereInput
    none?: RecipeMaterialWhereInput
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quality?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quality?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quality?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quality?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    quality?: SortOrder
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ItemInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type ItemInstanceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type ItemInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type ItemInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type ItemInstanceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    id?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    id?: SortOrder
    difficulty?: SortOrder
    productId?: SortOrder
  }

  export type RecipeScalarRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type RecipeMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeMaterialSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CorpseCountOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    decayStage?: SortOrder
    location?: SortOrder
    causeOfDeath?: SortOrder
    isWaterlogged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorpseAvgOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    userId?: SortOrder
  }

  export type CorpseMaxOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    decayStage?: SortOrder
    location?: SortOrder
    causeOfDeath?: SortOrder
    isWaterlogged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorpseMinOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    decayStage?: SortOrder
    location?: SortOrder
    causeOfDeath?: SortOrder
    isWaterlogged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorpseSumOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WildAreaScalarRelationFilter = {
    is?: WildAreaWhereInput
    isNot?: WildAreaWhereInput
  }

  export type AnimalPopulationCountOrderByAggregateInput = {
    id?: SortOrder
    species?: SortOrder
    type?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
  }

  export type AnimalPopulationAvgOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
  }

  export type AnimalPopulationMaxOrderByAggregateInput = {
    id?: SortOrder
    species?: SortOrder
    type?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
  }

  export type AnimalPopulationMinOrderByAggregateInput = {
    id?: SortOrder
    species?: SortOrder
    type?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
  }

  export type AnimalPopulationSumOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
    areaId?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isAncient?: SortOrder
    region?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isAncient?: SortOrder
    region?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isAncient?: SortOrder
    region?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
  }

  export type UserLanguageAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
  }

  export type UserLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
  }

  export type UserLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
  }

  export type UserLanguageSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    languageId?: SortOrder
    fluency?: SortOrder
  }

  export type ArtifactListRelationFilter = {
    every?: ArtifactWhereInput
    some?: ArtifactWhereInput
    none?: ArtifactWhereInput
  }

  export type ArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReligionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originRegion?: SortOrder
    description?: SortOrder
    doctrine?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
  }

  export type ReligionAvgOrderByAggregateInput = {
    id?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
  }

  export type ReligionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originRegion?: SortOrder
    description?: SortOrder
    doctrine?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
  }

  export type ReligionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originRegion?: SortOrder
    description?: SortOrder
    doctrine?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
  }

  export type ReligionSumOrderByAggregateInput = {
    id?: SortOrder
    influenceLevel?: SortOrder
    estimatedFollowers?: SortOrder
  }

  export type ReligionScalarRelationFilter = {
    is?: ReligionWhereInput
    isNot?: ReligionWhereInput
  }

  export type ArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lore?: SortOrder
    powerHint?: SortOrder
    religionId?: SortOrder
  }

  export type ArtifactAvgOrderByAggregateInput = {
    id?: SortOrder
    religionId?: SortOrder
  }

  export type ArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lore?: SortOrder
    powerHint?: SortOrder
    religionId?: SortOrder
  }

  export type ArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lore?: SortOrder
    powerHint?: SortOrder
    religionId?: SortOrder
  }

  export type ArtifactSumOrderByAggregateInput = {
    id?: SortOrder
    religionId?: SortOrder
  }

  export type GlobalEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    affectedRegion?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    impact?: SortOrder
    isActive?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type GlobalEventAvgOrderByAggregateInput = {
    id?: SortOrder
    durationDays?: SortOrder
  }

  export type GlobalEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    affectedRegion?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    impact?: SortOrder
    isActive?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type GlobalEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    affectedRegion?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    impact?: SortOrder
    isActive?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type GlobalEventSumOrderByAggregateInput = {
    id?: SortOrder
    durationDays?: SortOrder
  }

  export type WeatherCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    condition?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherAvgOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type WeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    condition?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    condition?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherSumOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type NPCScalarRelationFilter = {
    is?: NPCWhereInput
    isNot?: NPCWhereInput
  }

  export type NPCStoryCountOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type NPCStoryAvgOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
  }

  export type NPCStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type NPCStoryMinOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type NPCStorySumOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
  }

  export type PlayerTitleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    region?: SortOrder
    grantedAt?: SortOrder
    authority?: SortOrder
  }

  export type PlayerTitleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    authority?: SortOrder
  }

  export type PlayerTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    region?: SortOrder
    grantedAt?: SortOrder
    authority?: SortOrder
  }

  export type PlayerTitleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    region?: SortOrder
    grantedAt?: SortOrder
    authority?: SortOrder
  }

  export type PlayerTitleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    authority?: SortOrder
  }

  export type EconomyCityId_itemCompoundUniqueInput = {
    cityId: number
    item: string
  }

  export type EconomyCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    item?: SortOrder
    price?: SortOrder
    demand?: SortOrder
    supply?: SortOrder
  }

  export type EconomyAvgOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    price?: SortOrder
  }

  export type EconomyMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    item?: SortOrder
    price?: SortOrder
    demand?: SortOrder
    supply?: SortOrder
  }

  export type EconomyMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    item?: SortOrder
    price?: SortOrder
    demand?: SortOrder
    supply?: SortOrder
  }

  export type EconomySumOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    price?: SortOrder
  }

  export type WorldTimeCountOrderByAggregateInput = {
    id?: SortOrder
    lastSimulated?: SortOrder
  }

  export type WorldTimeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorldTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    lastSimulated?: SortOrder
  }

  export type WorldTimeMinOrderByAggregateInput = {
    id?: SortOrder
    lastSimulated?: SortOrder
  }

  export type WorldTimeSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorldSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    jsonData?: SortOrder
    createdAt?: SortOrder
  }

  export type WorldSnapshotAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorldSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type WorldSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type WorldSnapshotSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TaxPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    rate?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
  }

  export type TaxPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    rate?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    rate?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPolicySumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
  }

  export type PlayerProfessionCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerProfessionCreateWithoutUserInput, PlayerProfessionUncheckedCreateWithoutUserInput> | PlayerProfessionCreateWithoutUserInput[] | PlayerProfessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerProfessionCreateOrConnectWithoutUserInput | PlayerProfessionCreateOrConnectWithoutUserInput[]
    createMany?: PlayerProfessionCreateManyUserInputEnvelope
    connect?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
  }

  export type ItemInstanceCreateNestedManyWithoutUserInput = {
    create?: XOR<ItemInstanceCreateWithoutUserInput, ItemInstanceUncheckedCreateWithoutUserInput> | ItemInstanceCreateWithoutUserInput[] | ItemInstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutUserInput | ItemInstanceCreateOrConnectWithoutUserInput[]
    createMany?: ItemInstanceCreateManyUserInputEnvelope
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
  }

  export type PlayerTitleCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerTitleCreateWithoutUserInput, PlayerTitleUncheckedCreateWithoutUserInput> | PlayerTitleCreateWithoutUserInput[] | PlayerTitleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerTitleCreateOrConnectWithoutUserInput | PlayerTitleCreateOrConnectWithoutUserInput[]
    createMany?: PlayerTitleCreateManyUserInputEnvelope
    connect?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
  }

  export type UserLanguageCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLanguageCreateWithoutUserInput, UserLanguageUncheckedCreateWithoutUserInput> | UserLanguageCreateWithoutUserInput[] | UserLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutUserInput | UserLanguageCreateOrConnectWithoutUserInput[]
    createMany?: UserLanguageCreateManyUserInputEnvelope
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutTakerInput = {
    create?: XOR<QuestCreateWithoutTakerInput, QuestUncheckedCreateWithoutTakerInput> | QuestCreateWithoutTakerInput[] | QuestUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutTakerInput | QuestCreateOrConnectWithoutTakerInput[]
    createMany?: QuestCreateManyTakerInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type PlayerProfessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerProfessionCreateWithoutUserInput, PlayerProfessionUncheckedCreateWithoutUserInput> | PlayerProfessionCreateWithoutUserInput[] | PlayerProfessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerProfessionCreateOrConnectWithoutUserInput | PlayerProfessionCreateOrConnectWithoutUserInput[]
    createMany?: PlayerProfessionCreateManyUserInputEnvelope
    connect?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
  }

  export type ItemInstanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ItemInstanceCreateWithoutUserInput, ItemInstanceUncheckedCreateWithoutUserInput> | ItemInstanceCreateWithoutUserInput[] | ItemInstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutUserInput | ItemInstanceCreateOrConnectWithoutUserInput[]
    createMany?: ItemInstanceCreateManyUserInputEnvelope
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
  }

  export type PlayerTitleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerTitleCreateWithoutUserInput, PlayerTitleUncheckedCreateWithoutUserInput> | PlayerTitleCreateWithoutUserInput[] | PlayerTitleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerTitleCreateOrConnectWithoutUserInput | PlayerTitleCreateOrConnectWithoutUserInput[]
    createMany?: PlayerTitleCreateManyUserInputEnvelope
    connect?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
  }

  export type UserLanguageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLanguageCreateWithoutUserInput, UserLanguageUncheckedCreateWithoutUserInput> | UserLanguageCreateWithoutUserInput[] | UserLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutUserInput | UserLanguageCreateOrConnectWithoutUserInput[]
    createMany?: UserLanguageCreateManyUserInputEnvelope
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutTakerInput = {
    create?: XOR<QuestCreateWithoutTakerInput, QuestUncheckedCreateWithoutTakerInput> | QuestCreateWithoutTakerInput[] | QuestUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutTakerInput | QuestCreateOrConnectWithoutTakerInput[]
    createMany?: QuestCreateManyTakerInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PlayerProfessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerProfessionCreateWithoutUserInput, PlayerProfessionUncheckedCreateWithoutUserInput> | PlayerProfessionCreateWithoutUserInput[] | PlayerProfessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerProfessionCreateOrConnectWithoutUserInput | PlayerProfessionCreateOrConnectWithoutUserInput[]
    upsert?: PlayerProfessionUpsertWithWhereUniqueWithoutUserInput | PlayerProfessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerProfessionCreateManyUserInputEnvelope
    set?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    disconnect?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    delete?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    connect?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    update?: PlayerProfessionUpdateWithWhereUniqueWithoutUserInput | PlayerProfessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerProfessionUpdateManyWithWhereWithoutUserInput | PlayerProfessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerProfessionScalarWhereInput | PlayerProfessionScalarWhereInput[]
  }

  export type ItemInstanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ItemInstanceCreateWithoutUserInput, ItemInstanceUncheckedCreateWithoutUserInput> | ItemInstanceCreateWithoutUserInput[] | ItemInstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutUserInput | ItemInstanceCreateOrConnectWithoutUserInput[]
    upsert?: ItemInstanceUpsertWithWhereUniqueWithoutUserInput | ItemInstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ItemInstanceCreateManyUserInputEnvelope
    set?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    disconnect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    delete?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    update?: ItemInstanceUpdateWithWhereUniqueWithoutUserInput | ItemInstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ItemInstanceUpdateManyWithWhereWithoutUserInput | ItemInstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ItemInstanceScalarWhereInput | ItemInstanceScalarWhereInput[]
  }

  export type PlayerTitleUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerTitleCreateWithoutUserInput, PlayerTitleUncheckedCreateWithoutUserInput> | PlayerTitleCreateWithoutUserInput[] | PlayerTitleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerTitleCreateOrConnectWithoutUserInput | PlayerTitleCreateOrConnectWithoutUserInput[]
    upsert?: PlayerTitleUpsertWithWhereUniqueWithoutUserInput | PlayerTitleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerTitleCreateManyUserInputEnvelope
    set?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    disconnect?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    delete?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    connect?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    update?: PlayerTitleUpdateWithWhereUniqueWithoutUserInput | PlayerTitleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerTitleUpdateManyWithWhereWithoutUserInput | PlayerTitleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerTitleScalarWhereInput | PlayerTitleScalarWhereInput[]
  }

  export type UserLanguageUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLanguageCreateWithoutUserInput, UserLanguageUncheckedCreateWithoutUserInput> | UserLanguageCreateWithoutUserInput[] | UserLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutUserInput | UserLanguageCreateOrConnectWithoutUserInput[]
    upsert?: UserLanguageUpsertWithWhereUniqueWithoutUserInput | UserLanguageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLanguageCreateManyUserInputEnvelope
    set?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    disconnect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    delete?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    update?: UserLanguageUpdateWithWhereUniqueWithoutUserInput | UserLanguageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLanguageUpdateManyWithWhereWithoutUserInput | UserLanguageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLanguageScalarWhereInput | UserLanguageScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutTakerNestedInput = {
    create?: XOR<QuestCreateWithoutTakerInput, QuestUncheckedCreateWithoutTakerInput> | QuestCreateWithoutTakerInput[] | QuestUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutTakerInput | QuestCreateOrConnectWithoutTakerInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutTakerInput | QuestUpsertWithWhereUniqueWithoutTakerInput[]
    createMany?: QuestCreateManyTakerInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutTakerInput | QuestUpdateWithWhereUniqueWithoutTakerInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutTakerInput | QuestUpdateManyWithWhereWithoutTakerInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type PlayerProfessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerProfessionCreateWithoutUserInput, PlayerProfessionUncheckedCreateWithoutUserInput> | PlayerProfessionCreateWithoutUserInput[] | PlayerProfessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerProfessionCreateOrConnectWithoutUserInput | PlayerProfessionCreateOrConnectWithoutUserInput[]
    upsert?: PlayerProfessionUpsertWithWhereUniqueWithoutUserInput | PlayerProfessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerProfessionCreateManyUserInputEnvelope
    set?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    disconnect?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    delete?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    connect?: PlayerProfessionWhereUniqueInput | PlayerProfessionWhereUniqueInput[]
    update?: PlayerProfessionUpdateWithWhereUniqueWithoutUserInput | PlayerProfessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerProfessionUpdateManyWithWhereWithoutUserInput | PlayerProfessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerProfessionScalarWhereInput | PlayerProfessionScalarWhereInput[]
  }

  export type ItemInstanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ItemInstanceCreateWithoutUserInput, ItemInstanceUncheckedCreateWithoutUserInput> | ItemInstanceCreateWithoutUserInput[] | ItemInstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutUserInput | ItemInstanceCreateOrConnectWithoutUserInput[]
    upsert?: ItemInstanceUpsertWithWhereUniqueWithoutUserInput | ItemInstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ItemInstanceCreateManyUserInputEnvelope
    set?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    disconnect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    delete?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    update?: ItemInstanceUpdateWithWhereUniqueWithoutUserInput | ItemInstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ItemInstanceUpdateManyWithWhereWithoutUserInput | ItemInstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ItemInstanceScalarWhereInput | ItemInstanceScalarWhereInput[]
  }

  export type PlayerTitleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerTitleCreateWithoutUserInput, PlayerTitleUncheckedCreateWithoutUserInput> | PlayerTitleCreateWithoutUserInput[] | PlayerTitleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerTitleCreateOrConnectWithoutUserInput | PlayerTitleCreateOrConnectWithoutUserInput[]
    upsert?: PlayerTitleUpsertWithWhereUniqueWithoutUserInput | PlayerTitleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerTitleCreateManyUserInputEnvelope
    set?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    disconnect?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    delete?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    connect?: PlayerTitleWhereUniqueInput | PlayerTitleWhereUniqueInput[]
    update?: PlayerTitleUpdateWithWhereUniqueWithoutUserInput | PlayerTitleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerTitleUpdateManyWithWhereWithoutUserInput | PlayerTitleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerTitleScalarWhereInput | PlayerTitleScalarWhereInput[]
  }

  export type UserLanguageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLanguageCreateWithoutUserInput, UserLanguageUncheckedCreateWithoutUserInput> | UserLanguageCreateWithoutUserInput[] | UserLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutUserInput | UserLanguageCreateOrConnectWithoutUserInput[]
    upsert?: UserLanguageUpsertWithWhereUniqueWithoutUserInput | UserLanguageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLanguageCreateManyUserInputEnvelope
    set?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    disconnect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    delete?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    update?: UserLanguageUpdateWithWhereUniqueWithoutUserInput | UserLanguageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLanguageUpdateManyWithWhereWithoutUserInput | UserLanguageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLanguageScalarWhereInput | UserLanguageScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutTakerNestedInput = {
    create?: XOR<QuestCreateWithoutTakerInput, QuestUncheckedCreateWithoutTakerInput> | QuestCreateWithoutTakerInput[] | QuestUncheckedCreateWithoutTakerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutTakerInput | QuestCreateOrConnectWithoutTakerInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutTakerInput | QuestUpsertWithWhereUniqueWithoutTakerInput[]
    createMany?: QuestCreateManyTakerInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutTakerInput | QuestUpdateWithWhereUniqueWithoutTakerInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutTakerInput | QuestUpdateManyWithWhereWithoutTakerInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutNpcsInput = {
    create?: XOR<CityCreateWithoutNpcsInput, CityUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: CityCreateOrConnectWithoutNpcsInput
    connect?: CityWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutSpeakersInput = {
    create?: XOR<LanguageCreateWithoutSpeakersInput, LanguageUncheckedCreateWithoutSpeakersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutSpeakersInput
    connect?: LanguageWhereUniqueInput
  }

  export type ReligionCreateNestedOneWithoutFollowersInput = {
    create?: XOR<ReligionCreateWithoutFollowersInput, ReligionUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutFollowersInput
    connect?: ReligionWhereUniqueInput
  }

  export type NPCStoryCreateNestedManyWithoutNpcInput = {
    create?: XOR<NPCStoryCreateWithoutNpcInput, NPCStoryUncheckedCreateWithoutNpcInput> | NPCStoryCreateWithoutNpcInput[] | NPCStoryUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCStoryCreateOrConnectWithoutNpcInput | NPCStoryCreateOrConnectWithoutNpcInput[]
    createMany?: NPCStoryCreateManyNpcInputEnvelope
    connect?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutIssuerInput = {
    create?: XOR<QuestCreateWithoutIssuerInput, QuestUncheckedCreateWithoutIssuerInput> | QuestCreateWithoutIssuerInput[] | QuestUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutIssuerInput | QuestCreateOrConnectWithoutIssuerInput[]
    createMany?: QuestCreateManyIssuerInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type NPCStoryUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<NPCStoryCreateWithoutNpcInput, NPCStoryUncheckedCreateWithoutNpcInput> | NPCStoryCreateWithoutNpcInput[] | NPCStoryUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCStoryCreateOrConnectWithoutNpcInput | NPCStoryCreateOrConnectWithoutNpcInput[]
    createMany?: NPCStoryCreateManyNpcInputEnvelope
    connect?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutIssuerInput = {
    create?: XOR<QuestCreateWithoutIssuerInput, QuestUncheckedCreateWithoutIssuerInput> | QuestCreateWithoutIssuerInput[] | QuestUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutIssuerInput | QuestCreateOrConnectWithoutIssuerInput[]
    createMany?: QuestCreateManyIssuerInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CityUpdateOneRequiredWithoutNpcsNestedInput = {
    create?: XOR<CityCreateWithoutNpcsInput, CityUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: CityCreateOrConnectWithoutNpcsInput
    upsert?: CityUpsertWithoutNpcsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutNpcsInput, CityUpdateWithoutNpcsInput>, CityUncheckedUpdateWithoutNpcsInput>
  }

  export type LanguageUpdateOneRequiredWithoutSpeakersNestedInput = {
    create?: XOR<LanguageCreateWithoutSpeakersInput, LanguageUncheckedCreateWithoutSpeakersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutSpeakersInput
    upsert?: LanguageUpsertWithoutSpeakersInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutSpeakersInput, LanguageUpdateWithoutSpeakersInput>, LanguageUncheckedUpdateWithoutSpeakersInput>
  }

  export type ReligionUpdateOneWithoutFollowersNestedInput = {
    create?: XOR<ReligionCreateWithoutFollowersInput, ReligionUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutFollowersInput
    upsert?: ReligionUpsertWithoutFollowersInput
    disconnect?: ReligionWhereInput | boolean
    delete?: ReligionWhereInput | boolean
    connect?: ReligionWhereUniqueInput
    update?: XOR<XOR<ReligionUpdateToOneWithWhereWithoutFollowersInput, ReligionUpdateWithoutFollowersInput>, ReligionUncheckedUpdateWithoutFollowersInput>
  }

  export type NPCStoryUpdateManyWithoutNpcNestedInput = {
    create?: XOR<NPCStoryCreateWithoutNpcInput, NPCStoryUncheckedCreateWithoutNpcInput> | NPCStoryCreateWithoutNpcInput[] | NPCStoryUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCStoryCreateOrConnectWithoutNpcInput | NPCStoryCreateOrConnectWithoutNpcInput[]
    upsert?: NPCStoryUpsertWithWhereUniqueWithoutNpcInput | NPCStoryUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: NPCStoryCreateManyNpcInputEnvelope
    set?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    disconnect?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    delete?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    connect?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    update?: NPCStoryUpdateWithWhereUniqueWithoutNpcInput | NPCStoryUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: NPCStoryUpdateManyWithWhereWithoutNpcInput | NPCStoryUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: NPCStoryScalarWhereInput | NPCStoryScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<QuestCreateWithoutIssuerInput, QuestUncheckedCreateWithoutIssuerInput> | QuestCreateWithoutIssuerInput[] | QuestUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutIssuerInput | QuestCreateOrConnectWithoutIssuerInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutIssuerInput | QuestUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: QuestCreateManyIssuerInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutIssuerInput | QuestUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutIssuerInput | QuestUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type NPCStoryUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<NPCStoryCreateWithoutNpcInput, NPCStoryUncheckedCreateWithoutNpcInput> | NPCStoryCreateWithoutNpcInput[] | NPCStoryUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCStoryCreateOrConnectWithoutNpcInput | NPCStoryCreateOrConnectWithoutNpcInput[]
    upsert?: NPCStoryUpsertWithWhereUniqueWithoutNpcInput | NPCStoryUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: NPCStoryCreateManyNpcInputEnvelope
    set?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    disconnect?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    delete?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    connect?: NPCStoryWhereUniqueInput | NPCStoryWhereUniqueInput[]
    update?: NPCStoryUpdateWithWhereUniqueWithoutNpcInput | NPCStoryUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: NPCStoryUpdateManyWithWhereWithoutNpcInput | NPCStoryUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: NPCStoryScalarWhereInput | NPCStoryScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<QuestCreateWithoutIssuerInput, QuestUncheckedCreateWithoutIssuerInput> | QuestCreateWithoutIssuerInput[] | QuestUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutIssuerInput | QuestCreateOrConnectWithoutIssuerInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutIssuerInput | QuestUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: QuestCreateManyIssuerInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutIssuerInput | QuestUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutIssuerInput | QuestUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type WildAreaCreateNestedManyWithoutCityInput = {
    create?: XOR<WildAreaCreateWithoutCityInput, WildAreaUncheckedCreateWithoutCityInput> | WildAreaCreateWithoutCityInput[] | WildAreaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCityInput | WildAreaCreateOrConnectWithoutCityInput[]
    createMany?: WildAreaCreateManyCityInputEnvelope
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
  }

  export type DungeonCreateNestedManyWithoutCityInput = {
    create?: XOR<DungeonCreateWithoutCityInput, DungeonUncheckedCreateWithoutCityInput> | DungeonCreateWithoutCityInput[] | DungeonUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCityInput | DungeonCreateOrConnectWithoutCityInput[]
    createMany?: DungeonCreateManyCityInputEnvelope
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
  }

  export type WeatherCreateNestedOneWithoutCityInput = {
    create?: XOR<WeatherCreateWithoutCityInput, WeatherUncheckedCreateWithoutCityInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCityInput
    connect?: WeatherWhereUniqueInput
  }

  export type NPCCreateNestedManyWithoutCityInput = {
    create?: XOR<NPCCreateWithoutCityInput, NPCUncheckedCreateWithoutCityInput> | NPCCreateWithoutCityInput[] | NPCUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCityInput | NPCCreateOrConnectWithoutCityInput[]
    createMany?: NPCCreateManyCityInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type EconomyCreateNestedManyWithoutCityInput = {
    create?: XOR<EconomyCreateWithoutCityInput, EconomyUncheckedCreateWithoutCityInput> | EconomyCreateWithoutCityInput[] | EconomyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: EconomyCreateOrConnectWithoutCityInput | EconomyCreateOrConnectWithoutCityInput[]
    createMany?: EconomyCreateManyCityInputEnvelope
    connect?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
  }

  export type WildAreaUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<WildAreaCreateWithoutCityInput, WildAreaUncheckedCreateWithoutCityInput> | WildAreaCreateWithoutCityInput[] | WildAreaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCityInput | WildAreaCreateOrConnectWithoutCityInput[]
    createMany?: WildAreaCreateManyCityInputEnvelope
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
  }

  export type DungeonUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DungeonCreateWithoutCityInput, DungeonUncheckedCreateWithoutCityInput> | DungeonCreateWithoutCityInput[] | DungeonUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCityInput | DungeonCreateOrConnectWithoutCityInput[]
    createMany?: DungeonCreateManyCityInputEnvelope
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
  }

  export type WeatherUncheckedCreateNestedOneWithoutCityInput = {
    create?: XOR<WeatherCreateWithoutCityInput, WeatherUncheckedCreateWithoutCityInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCityInput
    connect?: WeatherWhereUniqueInput
  }

  export type NPCUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<NPCCreateWithoutCityInput, NPCUncheckedCreateWithoutCityInput> | NPCCreateWithoutCityInput[] | NPCUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCityInput | NPCCreateOrConnectWithoutCityInput[]
    createMany?: NPCCreateManyCityInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type EconomyUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<EconomyCreateWithoutCityInput, EconomyUncheckedCreateWithoutCityInput> | EconomyCreateWithoutCityInput[] | EconomyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: EconomyCreateOrConnectWithoutCityInput | EconomyCreateOrConnectWithoutCityInput[]
    createMany?: EconomyCreateManyCityInputEnvelope
    connect?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type WildAreaUpdateManyWithoutCityNestedInput = {
    create?: XOR<WildAreaCreateWithoutCityInput, WildAreaUncheckedCreateWithoutCityInput> | WildAreaCreateWithoutCityInput[] | WildAreaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCityInput | WildAreaCreateOrConnectWithoutCityInput[]
    upsert?: WildAreaUpsertWithWhereUniqueWithoutCityInput | WildAreaUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: WildAreaCreateManyCityInputEnvelope
    set?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    disconnect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    delete?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    update?: WildAreaUpdateWithWhereUniqueWithoutCityInput | WildAreaUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: WildAreaUpdateManyWithWhereWithoutCityInput | WildAreaUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: WildAreaScalarWhereInput | WildAreaScalarWhereInput[]
  }

  export type DungeonUpdateManyWithoutCityNestedInput = {
    create?: XOR<DungeonCreateWithoutCityInput, DungeonUncheckedCreateWithoutCityInput> | DungeonCreateWithoutCityInput[] | DungeonUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCityInput | DungeonCreateOrConnectWithoutCityInput[]
    upsert?: DungeonUpsertWithWhereUniqueWithoutCityInput | DungeonUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DungeonCreateManyCityInputEnvelope
    set?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    disconnect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    delete?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    update?: DungeonUpdateWithWhereUniqueWithoutCityInput | DungeonUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DungeonUpdateManyWithWhereWithoutCityInput | DungeonUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DungeonScalarWhereInput | DungeonScalarWhereInput[]
  }

  export type WeatherUpdateOneWithoutCityNestedInput = {
    create?: XOR<WeatherCreateWithoutCityInput, WeatherUncheckedCreateWithoutCityInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCityInput
    upsert?: WeatherUpsertWithoutCityInput
    disconnect?: WeatherWhereInput | boolean
    delete?: WeatherWhereInput | boolean
    connect?: WeatherWhereUniqueInput
    update?: XOR<XOR<WeatherUpdateToOneWithWhereWithoutCityInput, WeatherUpdateWithoutCityInput>, WeatherUncheckedUpdateWithoutCityInput>
  }

  export type NPCUpdateManyWithoutCityNestedInput = {
    create?: XOR<NPCCreateWithoutCityInput, NPCUncheckedCreateWithoutCityInput> | NPCCreateWithoutCityInput[] | NPCUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCityInput | NPCCreateOrConnectWithoutCityInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutCityInput | NPCUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: NPCCreateManyCityInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutCityInput | NPCUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutCityInput | NPCUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type EconomyUpdateManyWithoutCityNestedInput = {
    create?: XOR<EconomyCreateWithoutCityInput, EconomyUncheckedCreateWithoutCityInput> | EconomyCreateWithoutCityInput[] | EconomyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: EconomyCreateOrConnectWithoutCityInput | EconomyCreateOrConnectWithoutCityInput[]
    upsert?: EconomyUpsertWithWhereUniqueWithoutCityInput | EconomyUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: EconomyCreateManyCityInputEnvelope
    set?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    disconnect?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    delete?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    connect?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    update?: EconomyUpdateWithWhereUniqueWithoutCityInput | EconomyUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: EconomyUpdateManyWithWhereWithoutCityInput | EconomyUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: EconomyScalarWhereInput | EconomyScalarWhereInput[]
  }

  export type WildAreaUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<WildAreaCreateWithoutCityInput, WildAreaUncheckedCreateWithoutCityInput> | WildAreaCreateWithoutCityInput[] | WildAreaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCityInput | WildAreaCreateOrConnectWithoutCityInput[]
    upsert?: WildAreaUpsertWithWhereUniqueWithoutCityInput | WildAreaUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: WildAreaCreateManyCityInputEnvelope
    set?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    disconnect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    delete?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    update?: WildAreaUpdateWithWhereUniqueWithoutCityInput | WildAreaUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: WildAreaUpdateManyWithWhereWithoutCityInput | WildAreaUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: WildAreaScalarWhereInput | WildAreaScalarWhereInput[]
  }

  export type DungeonUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DungeonCreateWithoutCityInput, DungeonUncheckedCreateWithoutCityInput> | DungeonCreateWithoutCityInput[] | DungeonUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCityInput | DungeonCreateOrConnectWithoutCityInput[]
    upsert?: DungeonUpsertWithWhereUniqueWithoutCityInput | DungeonUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DungeonCreateManyCityInputEnvelope
    set?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    disconnect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    delete?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    update?: DungeonUpdateWithWhereUniqueWithoutCityInput | DungeonUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DungeonUpdateManyWithWhereWithoutCityInput | DungeonUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DungeonScalarWhereInput | DungeonScalarWhereInput[]
  }

  export type WeatherUncheckedUpdateOneWithoutCityNestedInput = {
    create?: XOR<WeatherCreateWithoutCityInput, WeatherUncheckedCreateWithoutCityInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCityInput
    upsert?: WeatherUpsertWithoutCityInput
    disconnect?: WeatherWhereInput | boolean
    delete?: WeatherWhereInput | boolean
    connect?: WeatherWhereUniqueInput
    update?: XOR<XOR<WeatherUpdateToOneWithWhereWithoutCityInput, WeatherUpdateWithoutCityInput>, WeatherUncheckedUpdateWithoutCityInput>
  }

  export type NPCUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<NPCCreateWithoutCityInput, NPCUncheckedCreateWithoutCityInput> | NPCCreateWithoutCityInput[] | NPCUncheckedCreateWithoutCityInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCityInput | NPCCreateOrConnectWithoutCityInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutCityInput | NPCUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: NPCCreateManyCityInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutCityInput | NPCUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutCityInput | NPCUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type EconomyUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<EconomyCreateWithoutCityInput, EconomyUncheckedCreateWithoutCityInput> | EconomyCreateWithoutCityInput[] | EconomyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: EconomyCreateOrConnectWithoutCityInput | EconomyCreateOrConnectWithoutCityInput[]
    upsert?: EconomyUpsertWithWhereUniqueWithoutCityInput | EconomyUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: EconomyCreateManyCityInputEnvelope
    set?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    disconnect?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    delete?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    connect?: EconomyWhereUniqueInput | EconomyWhereUniqueInput[]
    update?: EconomyUpdateWithWhereUniqueWithoutCityInput | EconomyUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: EconomyUpdateManyWithWhereWithoutCityInput | EconomyUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: EconomyScalarWhereInput | EconomyScalarWhereInput[]
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type WildAreaCreateNestedManyWithoutCountryInput = {
    create?: XOR<WildAreaCreateWithoutCountryInput, WildAreaUncheckedCreateWithoutCountryInput> | WildAreaCreateWithoutCountryInput[] | WildAreaUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCountryInput | WildAreaCreateOrConnectWithoutCountryInput[]
    createMany?: WildAreaCreateManyCountryInputEnvelope
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
  }

  export type DungeonCreateNestedManyWithoutCountryInput = {
    create?: XOR<DungeonCreateWithoutCountryInput, DungeonUncheckedCreateWithoutCountryInput> | DungeonCreateWithoutCountryInput[] | DungeonUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCountryInput | DungeonCreateOrConnectWithoutCountryInput[]
    createMany?: DungeonCreateManyCountryInputEnvelope
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type WildAreaUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<WildAreaCreateWithoutCountryInput, WildAreaUncheckedCreateWithoutCountryInput> | WildAreaCreateWithoutCountryInput[] | WildAreaUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCountryInput | WildAreaCreateOrConnectWithoutCountryInput[]
    createMany?: WildAreaCreateManyCountryInputEnvelope
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
  }

  export type DungeonUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<DungeonCreateWithoutCountryInput, DungeonUncheckedCreateWithoutCountryInput> | DungeonCreateWithoutCountryInput[] | DungeonUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCountryInput | DungeonCreateOrConnectWithoutCountryInput[]
    createMany?: DungeonCreateManyCountryInputEnvelope
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type WildAreaUpdateManyWithoutCountryNestedInput = {
    create?: XOR<WildAreaCreateWithoutCountryInput, WildAreaUncheckedCreateWithoutCountryInput> | WildAreaCreateWithoutCountryInput[] | WildAreaUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCountryInput | WildAreaCreateOrConnectWithoutCountryInput[]
    upsert?: WildAreaUpsertWithWhereUniqueWithoutCountryInput | WildAreaUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: WildAreaCreateManyCountryInputEnvelope
    set?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    disconnect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    delete?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    update?: WildAreaUpdateWithWhereUniqueWithoutCountryInput | WildAreaUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: WildAreaUpdateManyWithWhereWithoutCountryInput | WildAreaUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: WildAreaScalarWhereInput | WildAreaScalarWhereInput[]
  }

  export type DungeonUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DungeonCreateWithoutCountryInput, DungeonUncheckedCreateWithoutCountryInput> | DungeonCreateWithoutCountryInput[] | DungeonUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCountryInput | DungeonCreateOrConnectWithoutCountryInput[]
    upsert?: DungeonUpsertWithWhereUniqueWithoutCountryInput | DungeonUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DungeonCreateManyCountryInputEnvelope
    set?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    disconnect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    delete?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    update?: DungeonUpdateWithWhereUniqueWithoutCountryInput | DungeonUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DungeonUpdateManyWithWhereWithoutCountryInput | DungeonUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DungeonScalarWhereInput | DungeonScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type WildAreaUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<WildAreaCreateWithoutCountryInput, WildAreaUncheckedCreateWithoutCountryInput> | WildAreaCreateWithoutCountryInput[] | WildAreaUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: WildAreaCreateOrConnectWithoutCountryInput | WildAreaCreateOrConnectWithoutCountryInput[]
    upsert?: WildAreaUpsertWithWhereUniqueWithoutCountryInput | WildAreaUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: WildAreaCreateManyCountryInputEnvelope
    set?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    disconnect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    delete?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    connect?: WildAreaWhereUniqueInput | WildAreaWhereUniqueInput[]
    update?: WildAreaUpdateWithWhereUniqueWithoutCountryInput | WildAreaUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: WildAreaUpdateManyWithWhereWithoutCountryInput | WildAreaUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: WildAreaScalarWhereInput | WildAreaScalarWhereInput[]
  }

  export type DungeonUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DungeonCreateWithoutCountryInput, DungeonUncheckedCreateWithoutCountryInput> | DungeonCreateWithoutCountryInput[] | DungeonUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DungeonCreateOrConnectWithoutCountryInput | DungeonCreateOrConnectWithoutCountryInput[]
    upsert?: DungeonUpsertWithWhereUniqueWithoutCountryInput | DungeonUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DungeonCreateManyCountryInputEnvelope
    set?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    disconnect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    delete?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    connect?: DungeonWhereUniqueInput | DungeonWhereUniqueInput[]
    update?: DungeonUpdateWithWhereUniqueWithoutCountryInput | DungeonUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DungeonUpdateManyWithWhereWithoutCountryInput | DungeonUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DungeonScalarWhereInput | DungeonScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutWildAreasInput = {
    create?: XOR<CountryCreateWithoutWildAreasInput, CountryUncheckedCreateWithoutWildAreasInput>
    connectOrCreate?: CountryCreateOrConnectWithoutWildAreasInput
    connect?: CountryWhereUniqueInput
  }

  export type AnimalPopulationCreateNestedManyWithoutAreaInput = {
    create?: XOR<AnimalPopulationCreateWithoutAreaInput, AnimalPopulationUncheckedCreateWithoutAreaInput> | AnimalPopulationCreateWithoutAreaInput[] | AnimalPopulationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AnimalPopulationCreateOrConnectWithoutAreaInput | AnimalPopulationCreateOrConnectWithoutAreaInput[]
    createMany?: AnimalPopulationCreateManyAreaInputEnvelope
    connect?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
  }

  export type CityCreateNestedOneWithoutWildAreasInput = {
    create?: XOR<CityCreateWithoutWildAreasInput, CityUncheckedCreateWithoutWildAreasInput>
    connectOrCreate?: CityCreateOrConnectWithoutWildAreasInput
    connect?: CityWhereUniqueInput
  }

  export type AnimalPopulationUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<AnimalPopulationCreateWithoutAreaInput, AnimalPopulationUncheckedCreateWithoutAreaInput> | AnimalPopulationCreateWithoutAreaInput[] | AnimalPopulationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AnimalPopulationCreateOrConnectWithoutAreaInput | AnimalPopulationCreateOrConnectWithoutAreaInput[]
    createMany?: AnimalPopulationCreateManyAreaInputEnvelope
    connect?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutWildAreasNestedInput = {
    create?: XOR<CountryCreateWithoutWildAreasInput, CountryUncheckedCreateWithoutWildAreasInput>
    connectOrCreate?: CountryCreateOrConnectWithoutWildAreasInput
    upsert?: CountryUpsertWithoutWildAreasInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutWildAreasInput, CountryUpdateWithoutWildAreasInput>, CountryUncheckedUpdateWithoutWildAreasInput>
  }

  export type AnimalPopulationUpdateManyWithoutAreaNestedInput = {
    create?: XOR<AnimalPopulationCreateWithoutAreaInput, AnimalPopulationUncheckedCreateWithoutAreaInput> | AnimalPopulationCreateWithoutAreaInput[] | AnimalPopulationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AnimalPopulationCreateOrConnectWithoutAreaInput | AnimalPopulationCreateOrConnectWithoutAreaInput[]
    upsert?: AnimalPopulationUpsertWithWhereUniqueWithoutAreaInput | AnimalPopulationUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: AnimalPopulationCreateManyAreaInputEnvelope
    set?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    disconnect?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    delete?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    connect?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    update?: AnimalPopulationUpdateWithWhereUniqueWithoutAreaInput | AnimalPopulationUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: AnimalPopulationUpdateManyWithWhereWithoutAreaInput | AnimalPopulationUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: AnimalPopulationScalarWhereInput | AnimalPopulationScalarWhereInput[]
  }

  export type CityUpdateOneWithoutWildAreasNestedInput = {
    create?: XOR<CityCreateWithoutWildAreasInput, CityUncheckedCreateWithoutWildAreasInput>
    connectOrCreate?: CityCreateOrConnectWithoutWildAreasInput
    upsert?: CityUpsertWithoutWildAreasInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutWildAreasInput, CityUpdateWithoutWildAreasInput>, CityUncheckedUpdateWithoutWildAreasInput>
  }

  export type AnimalPopulationUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<AnimalPopulationCreateWithoutAreaInput, AnimalPopulationUncheckedCreateWithoutAreaInput> | AnimalPopulationCreateWithoutAreaInput[] | AnimalPopulationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AnimalPopulationCreateOrConnectWithoutAreaInput | AnimalPopulationCreateOrConnectWithoutAreaInput[]
    upsert?: AnimalPopulationUpsertWithWhereUniqueWithoutAreaInput | AnimalPopulationUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: AnimalPopulationCreateManyAreaInputEnvelope
    set?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    disconnect?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    delete?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    connect?: AnimalPopulationWhereUniqueInput | AnimalPopulationWhereUniqueInput[]
    update?: AnimalPopulationUpdateWithWhereUniqueWithoutAreaInput | AnimalPopulationUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: AnimalPopulationUpdateManyWithWhereWithoutAreaInput | AnimalPopulationUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: AnimalPopulationScalarWhereInput | AnimalPopulationScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutDungeonsInput = {
    create?: XOR<CountryCreateWithoutDungeonsInput, CountryUncheckedCreateWithoutDungeonsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDungeonsInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutDungeonsInput = {
    create?: XOR<CityCreateWithoutDungeonsInput, CityUncheckedCreateWithoutDungeonsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDungeonsInput
    connect?: CityWhereUniqueInput
  }

  export type CountryUpdateOneRequiredWithoutDungeonsNestedInput = {
    create?: XOR<CountryCreateWithoutDungeonsInput, CountryUncheckedCreateWithoutDungeonsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDungeonsInput
    upsert?: CountryUpsertWithoutDungeonsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutDungeonsInput, CountryUpdateWithoutDungeonsInput>, CountryUncheckedUpdateWithoutDungeonsInput>
  }

  export type CityUpdateOneWithoutDungeonsNestedInput = {
    create?: XOR<CityCreateWithoutDungeonsInput, CityUncheckedCreateWithoutDungeonsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDungeonsInput
    upsert?: CityUpsertWithoutDungeonsInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDungeonsInput, CityUpdateWithoutDungeonsInput>, CityUncheckedUpdateWithoutDungeonsInput>
  }

  export type NPCCreateNestedOneWithoutQuestsInput = {
    create?: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsInput
    connect?: NPCWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuestsInput = {
    create?: XOR<UserCreateWithoutQuestsInput, UserUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NPCUpdateOneWithoutQuestsNestedInput = {
    create?: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsInput
    upsert?: NPCUpsertWithoutQuestsInput
    disconnect?: NPCWhereInput | boolean
    delete?: NPCWhereInput | boolean
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutQuestsInput, NPCUpdateWithoutQuestsInput>, NPCUncheckedUpdateWithoutQuestsInput>
  }

  export type UserUpdateOneWithoutQuestsNestedInput = {
    create?: XOR<UserCreateWithoutQuestsInput, UserUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestsInput
    upsert?: UserUpsertWithoutQuestsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestsInput, UserUpdateWithoutQuestsInput>, UserUncheckedUpdateWithoutQuestsInput>
  }

  export type UserCreateNestedOneWithoutProfessionInput = {
    create?: XOR<UserCreateWithoutProfessionInput, UserUncheckedCreateWithoutProfessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfessionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfessionNestedInput = {
    create?: XOR<UserCreateWithoutProfessionInput, UserUncheckedCreateWithoutProfessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfessionInput
    upsert?: UserUpsertWithoutProfessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfessionInput, UserUpdateWithoutProfessionInput>, UserUncheckedUpdateWithoutProfessionInput>
  }

  export type ItemInstanceCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemInstanceCreateWithoutItemInput, ItemInstanceUncheckedCreateWithoutItemInput> | ItemInstanceCreateWithoutItemInput[] | ItemInstanceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutItemInput | ItemInstanceCreateOrConnectWithoutItemInput[]
    createMany?: ItemInstanceCreateManyItemInputEnvelope
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutProductInput = {
    create?: XOR<RecipeCreateWithoutProductInput, RecipeUncheckedCreateWithoutProductInput> | RecipeCreateWithoutProductInput[] | RecipeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutProductInput | RecipeCreateOrConnectWithoutProductInput[]
    createMany?: RecipeCreateManyProductInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeMaterialCreateNestedManyWithoutItemInput = {
    create?: XOR<RecipeMaterialCreateWithoutItemInput, RecipeMaterialUncheckedCreateWithoutItemInput> | RecipeMaterialCreateWithoutItemInput[] | RecipeMaterialUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutItemInput | RecipeMaterialCreateOrConnectWithoutItemInput[]
    createMany?: RecipeMaterialCreateManyItemInputEnvelope
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
  }

  export type ItemInstanceUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemInstanceCreateWithoutItemInput, ItemInstanceUncheckedCreateWithoutItemInput> | ItemInstanceCreateWithoutItemInput[] | ItemInstanceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutItemInput | ItemInstanceCreateOrConnectWithoutItemInput[]
    createMany?: ItemInstanceCreateManyItemInputEnvelope
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RecipeCreateWithoutProductInput, RecipeUncheckedCreateWithoutProductInput> | RecipeCreateWithoutProductInput[] | RecipeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutProductInput | RecipeCreateOrConnectWithoutProductInput[]
    createMany?: RecipeCreateManyProductInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeMaterialUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<RecipeMaterialCreateWithoutItemInput, RecipeMaterialUncheckedCreateWithoutItemInput> | RecipeMaterialCreateWithoutItemInput[] | RecipeMaterialUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutItemInput | RecipeMaterialCreateOrConnectWithoutItemInput[]
    createMany?: RecipeMaterialCreateManyItemInputEnvelope
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
  }

  export type ItemInstanceUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemInstanceCreateWithoutItemInput, ItemInstanceUncheckedCreateWithoutItemInput> | ItemInstanceCreateWithoutItemInput[] | ItemInstanceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutItemInput | ItemInstanceCreateOrConnectWithoutItemInput[]
    upsert?: ItemInstanceUpsertWithWhereUniqueWithoutItemInput | ItemInstanceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemInstanceCreateManyItemInputEnvelope
    set?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    disconnect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    delete?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    update?: ItemInstanceUpdateWithWhereUniqueWithoutItemInput | ItemInstanceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemInstanceUpdateManyWithWhereWithoutItemInput | ItemInstanceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemInstanceScalarWhereInput | ItemInstanceScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutProductNestedInput = {
    create?: XOR<RecipeCreateWithoutProductInput, RecipeUncheckedCreateWithoutProductInput> | RecipeCreateWithoutProductInput[] | RecipeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutProductInput | RecipeCreateOrConnectWithoutProductInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutProductInput | RecipeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RecipeCreateManyProductInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutProductInput | RecipeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutProductInput | RecipeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeMaterialUpdateManyWithoutItemNestedInput = {
    create?: XOR<RecipeMaterialCreateWithoutItemInput, RecipeMaterialUncheckedCreateWithoutItemInput> | RecipeMaterialCreateWithoutItemInput[] | RecipeMaterialUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutItemInput | RecipeMaterialCreateOrConnectWithoutItemInput[]
    upsert?: RecipeMaterialUpsertWithWhereUniqueWithoutItemInput | RecipeMaterialUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: RecipeMaterialCreateManyItemInputEnvelope
    set?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    disconnect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    delete?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    update?: RecipeMaterialUpdateWithWhereUniqueWithoutItemInput | RecipeMaterialUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: RecipeMaterialUpdateManyWithWhereWithoutItemInput | RecipeMaterialUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: RecipeMaterialScalarWhereInput | RecipeMaterialScalarWhereInput[]
  }

  export type ItemInstanceUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemInstanceCreateWithoutItemInput, ItemInstanceUncheckedCreateWithoutItemInput> | ItemInstanceCreateWithoutItemInput[] | ItemInstanceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemInstanceCreateOrConnectWithoutItemInput | ItemInstanceCreateOrConnectWithoutItemInput[]
    upsert?: ItemInstanceUpsertWithWhereUniqueWithoutItemInput | ItemInstanceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemInstanceCreateManyItemInputEnvelope
    set?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    disconnect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    delete?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    connect?: ItemInstanceWhereUniqueInput | ItemInstanceWhereUniqueInput[]
    update?: ItemInstanceUpdateWithWhereUniqueWithoutItemInput | ItemInstanceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemInstanceUpdateManyWithWhereWithoutItemInput | ItemInstanceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemInstanceScalarWhereInput | ItemInstanceScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RecipeCreateWithoutProductInput, RecipeUncheckedCreateWithoutProductInput> | RecipeCreateWithoutProductInput[] | RecipeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutProductInput | RecipeCreateOrConnectWithoutProductInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutProductInput | RecipeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RecipeCreateManyProductInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutProductInput | RecipeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutProductInput | RecipeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeMaterialUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<RecipeMaterialCreateWithoutItemInput, RecipeMaterialUncheckedCreateWithoutItemInput> | RecipeMaterialCreateWithoutItemInput[] | RecipeMaterialUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutItemInput | RecipeMaterialCreateOrConnectWithoutItemInput[]
    upsert?: RecipeMaterialUpsertWithWhereUniqueWithoutItemInput | RecipeMaterialUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: RecipeMaterialCreateManyItemInputEnvelope
    set?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    disconnect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    delete?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    update?: RecipeMaterialUpdateWithWhereUniqueWithoutItemInput | RecipeMaterialUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: RecipeMaterialUpdateManyWithWhereWithoutItemInput | RecipeMaterialUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: RecipeMaterialScalarWhereInput | RecipeMaterialScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInstancesInput = {
    create?: XOR<ItemCreateWithoutInstancesInput, ItemUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInstancesInput
    connect?: ItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type ItemUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<ItemCreateWithoutInstancesInput, ItemUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInstancesInput
    upsert?: ItemUpsertWithoutInstancesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInstancesInput, ItemUpdateWithoutInstancesInput>, ItemUncheckedUpdateWithoutInstancesInput>
  }

  export type ItemCreateNestedOneWithoutRecipesAsProductInput = {
    create?: XOR<ItemCreateWithoutRecipesAsProductInput, ItemUncheckedCreateWithoutRecipesAsProductInput>
    connectOrCreate?: ItemCreateOrConnectWithoutRecipesAsProductInput
    connect?: ItemWhereUniqueInput
  }

  export type RecipeMaterialCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeMaterialCreateWithoutRecipeInput, RecipeMaterialUncheckedCreateWithoutRecipeInput> | RecipeMaterialCreateWithoutRecipeInput[] | RecipeMaterialUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutRecipeInput | RecipeMaterialCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeMaterialCreateManyRecipeInputEnvelope
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
  }

  export type RecipeMaterialUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeMaterialCreateWithoutRecipeInput, RecipeMaterialUncheckedCreateWithoutRecipeInput> | RecipeMaterialCreateWithoutRecipeInput[] | RecipeMaterialUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutRecipeInput | RecipeMaterialCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeMaterialCreateManyRecipeInputEnvelope
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
  }

  export type ItemUpdateOneRequiredWithoutRecipesAsProductNestedInput = {
    create?: XOR<ItemCreateWithoutRecipesAsProductInput, ItemUncheckedCreateWithoutRecipesAsProductInput>
    connectOrCreate?: ItemCreateOrConnectWithoutRecipesAsProductInput
    upsert?: ItemUpsertWithoutRecipesAsProductInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutRecipesAsProductInput, ItemUpdateWithoutRecipesAsProductInput>, ItemUncheckedUpdateWithoutRecipesAsProductInput>
  }

  export type RecipeMaterialUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeMaterialCreateWithoutRecipeInput, RecipeMaterialUncheckedCreateWithoutRecipeInput> | RecipeMaterialCreateWithoutRecipeInput[] | RecipeMaterialUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutRecipeInput | RecipeMaterialCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeMaterialUpsertWithWhereUniqueWithoutRecipeInput | RecipeMaterialUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeMaterialCreateManyRecipeInputEnvelope
    set?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    disconnect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    delete?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    update?: RecipeMaterialUpdateWithWhereUniqueWithoutRecipeInput | RecipeMaterialUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeMaterialUpdateManyWithWhereWithoutRecipeInput | RecipeMaterialUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeMaterialScalarWhereInput | RecipeMaterialScalarWhereInput[]
  }

  export type RecipeMaterialUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeMaterialCreateWithoutRecipeInput, RecipeMaterialUncheckedCreateWithoutRecipeInput> | RecipeMaterialCreateWithoutRecipeInput[] | RecipeMaterialUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMaterialCreateOrConnectWithoutRecipeInput | RecipeMaterialCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeMaterialUpsertWithWhereUniqueWithoutRecipeInput | RecipeMaterialUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeMaterialCreateManyRecipeInputEnvelope
    set?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    disconnect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    delete?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    connect?: RecipeMaterialWhereUniqueInput | RecipeMaterialWhereUniqueInput[]
    update?: RecipeMaterialUpdateWithWhereUniqueWithoutRecipeInput | RecipeMaterialUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeMaterialUpdateManyWithWhereWithoutRecipeInput | RecipeMaterialUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeMaterialScalarWhereInput | RecipeMaterialScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<RecipeCreateWithoutMaterialsInput, RecipeUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutMaterialsInput
    connect?: RecipeWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutRecipeMaterialsInput = {
    create?: XOR<ItemCreateWithoutRecipeMaterialsInput, ItemUncheckedCreateWithoutRecipeMaterialsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutRecipeMaterialsInput
    connect?: ItemWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<RecipeCreateWithoutMaterialsInput, RecipeUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutMaterialsInput
    upsert?: RecipeUpsertWithoutMaterialsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutMaterialsInput, RecipeUpdateWithoutMaterialsInput>, RecipeUncheckedUpdateWithoutMaterialsInput>
  }

  export type ItemUpdateOneRequiredWithoutRecipeMaterialsNestedInput = {
    create?: XOR<ItemCreateWithoutRecipeMaterialsInput, ItemUncheckedCreateWithoutRecipeMaterialsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutRecipeMaterialsInput
    upsert?: ItemUpsertWithoutRecipeMaterialsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutRecipeMaterialsInput, ItemUpdateWithoutRecipeMaterialsInput>, ItemUncheckedUpdateWithoutRecipeMaterialsInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WildAreaCreateNestedOneWithoutPopulationsInput = {
    create?: XOR<WildAreaCreateWithoutPopulationsInput, WildAreaUncheckedCreateWithoutPopulationsInput>
    connectOrCreate?: WildAreaCreateOrConnectWithoutPopulationsInput
    connect?: WildAreaWhereUniqueInput
  }

  export type WildAreaUpdateOneRequiredWithoutPopulationsNestedInput = {
    create?: XOR<WildAreaCreateWithoutPopulationsInput, WildAreaUncheckedCreateWithoutPopulationsInput>
    connectOrCreate?: WildAreaCreateOrConnectWithoutPopulationsInput
    upsert?: WildAreaUpsertWithoutPopulationsInput
    connect?: WildAreaWhereUniqueInput
    update?: XOR<XOR<WildAreaUpdateToOneWithWhereWithoutPopulationsInput, WildAreaUpdateWithoutPopulationsInput>, WildAreaUncheckedUpdateWithoutPopulationsInput>
  }

  export type NPCCreateNestedManyWithoutLanguageInput = {
    create?: XOR<NPCCreateWithoutLanguageInput, NPCUncheckedCreateWithoutLanguageInput> | NPCCreateWithoutLanguageInput[] | NPCUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLanguageInput | NPCCreateOrConnectWithoutLanguageInput[]
    createMany?: NPCCreateManyLanguageInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type UserLanguageCreateNestedManyWithoutLanguageInput = {
    create?: XOR<UserLanguageCreateWithoutLanguageInput, UserLanguageUncheckedCreateWithoutLanguageInput> | UserLanguageCreateWithoutLanguageInput[] | UserLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutLanguageInput | UserLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: UserLanguageCreateManyLanguageInputEnvelope
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
  }

  export type NPCUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<NPCCreateWithoutLanguageInput, NPCUncheckedCreateWithoutLanguageInput> | NPCCreateWithoutLanguageInput[] | NPCUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLanguageInput | NPCCreateOrConnectWithoutLanguageInput[]
    createMany?: NPCCreateManyLanguageInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type UserLanguageUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<UserLanguageCreateWithoutLanguageInput, UserLanguageUncheckedCreateWithoutLanguageInput> | UserLanguageCreateWithoutLanguageInput[] | UserLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutLanguageInput | UserLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: UserLanguageCreateManyLanguageInputEnvelope
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
  }

  export type NPCUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<NPCCreateWithoutLanguageInput, NPCUncheckedCreateWithoutLanguageInput> | NPCCreateWithoutLanguageInput[] | NPCUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLanguageInput | NPCCreateOrConnectWithoutLanguageInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutLanguageInput | NPCUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: NPCCreateManyLanguageInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutLanguageInput | NPCUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutLanguageInput | NPCUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type UserLanguageUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<UserLanguageCreateWithoutLanguageInput, UserLanguageUncheckedCreateWithoutLanguageInput> | UserLanguageCreateWithoutLanguageInput[] | UserLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutLanguageInput | UserLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: UserLanguageUpsertWithWhereUniqueWithoutLanguageInput | UserLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: UserLanguageCreateManyLanguageInputEnvelope
    set?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    disconnect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    delete?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    update?: UserLanguageUpdateWithWhereUniqueWithoutLanguageInput | UserLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: UserLanguageUpdateManyWithWhereWithoutLanguageInput | UserLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: UserLanguageScalarWhereInput | UserLanguageScalarWhereInput[]
  }

  export type NPCUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<NPCCreateWithoutLanguageInput, NPCUncheckedCreateWithoutLanguageInput> | NPCCreateWithoutLanguageInput[] | NPCUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLanguageInput | NPCCreateOrConnectWithoutLanguageInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutLanguageInput | NPCUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: NPCCreateManyLanguageInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutLanguageInput | NPCUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutLanguageInput | NPCUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type UserLanguageUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<UserLanguageCreateWithoutLanguageInput, UserLanguageUncheckedCreateWithoutLanguageInput> | UserLanguageCreateWithoutLanguageInput[] | UserLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UserLanguageCreateOrConnectWithoutLanguageInput | UserLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: UserLanguageUpsertWithWhereUniqueWithoutLanguageInput | UserLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: UserLanguageCreateManyLanguageInputEnvelope
    set?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    disconnect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    delete?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    connect?: UserLanguageWhereUniqueInput | UserLanguageWhereUniqueInput[]
    update?: UserLanguageUpdateWithWhereUniqueWithoutLanguageInput | UserLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: UserLanguageUpdateManyWithWhereWithoutLanguageInput | UserLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: UserLanguageScalarWhereInput | UserLanguageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<UserCreateWithoutLanguagesInput, UserUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLanguagesInput
    connect?: UserWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutUserLanguagesInput = {
    create?: XOR<LanguageCreateWithoutUserLanguagesInput, LanguageUncheckedCreateWithoutUserLanguagesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutUserLanguagesInput
    connect?: LanguageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<UserCreateWithoutLanguagesInput, UserUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLanguagesInput
    upsert?: UserUpsertWithoutLanguagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLanguagesInput, UserUpdateWithoutLanguagesInput>, UserUncheckedUpdateWithoutLanguagesInput>
  }

  export type LanguageUpdateOneRequiredWithoutUserLanguagesNestedInput = {
    create?: XOR<LanguageCreateWithoutUserLanguagesInput, LanguageUncheckedCreateWithoutUserLanguagesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutUserLanguagesInput
    upsert?: LanguageUpsertWithoutUserLanguagesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutUserLanguagesInput, LanguageUpdateWithoutUserLanguagesInput>, LanguageUncheckedUpdateWithoutUserLanguagesInput>
  }

  export type ArtifactCreateNestedManyWithoutReligionInput = {
    create?: XOR<ArtifactCreateWithoutReligionInput, ArtifactUncheckedCreateWithoutReligionInput> | ArtifactCreateWithoutReligionInput[] | ArtifactUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutReligionInput | ArtifactCreateOrConnectWithoutReligionInput[]
    createMany?: ArtifactCreateManyReligionInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type NPCCreateNestedManyWithoutReligionInput = {
    create?: XOR<NPCCreateWithoutReligionInput, NPCUncheckedCreateWithoutReligionInput> | NPCCreateWithoutReligionInput[] | NPCUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutReligionInput | NPCCreateOrConnectWithoutReligionInput[]
    createMany?: NPCCreateManyReligionInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutReligionInput = {
    create?: XOR<ArtifactCreateWithoutReligionInput, ArtifactUncheckedCreateWithoutReligionInput> | ArtifactCreateWithoutReligionInput[] | ArtifactUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutReligionInput | ArtifactCreateOrConnectWithoutReligionInput[]
    createMany?: ArtifactCreateManyReligionInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type NPCUncheckedCreateNestedManyWithoutReligionInput = {
    create?: XOR<NPCCreateWithoutReligionInput, NPCUncheckedCreateWithoutReligionInput> | NPCCreateWithoutReligionInput[] | NPCUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutReligionInput | NPCCreateOrConnectWithoutReligionInput[]
    createMany?: NPCCreateManyReligionInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type ArtifactUpdateManyWithoutReligionNestedInput = {
    create?: XOR<ArtifactCreateWithoutReligionInput, ArtifactUncheckedCreateWithoutReligionInput> | ArtifactCreateWithoutReligionInput[] | ArtifactUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutReligionInput | ArtifactCreateOrConnectWithoutReligionInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutReligionInput | ArtifactUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: ArtifactCreateManyReligionInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutReligionInput | ArtifactUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutReligionInput | ArtifactUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type NPCUpdateManyWithoutReligionNestedInput = {
    create?: XOR<NPCCreateWithoutReligionInput, NPCUncheckedCreateWithoutReligionInput> | NPCCreateWithoutReligionInput[] | NPCUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutReligionInput | NPCCreateOrConnectWithoutReligionInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutReligionInput | NPCUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: NPCCreateManyReligionInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutReligionInput | NPCUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutReligionInput | NPCUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutReligionNestedInput = {
    create?: XOR<ArtifactCreateWithoutReligionInput, ArtifactUncheckedCreateWithoutReligionInput> | ArtifactCreateWithoutReligionInput[] | ArtifactUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutReligionInput | ArtifactCreateOrConnectWithoutReligionInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutReligionInput | ArtifactUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: ArtifactCreateManyReligionInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutReligionInput | ArtifactUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutReligionInput | ArtifactUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type NPCUncheckedUpdateManyWithoutReligionNestedInput = {
    create?: XOR<NPCCreateWithoutReligionInput, NPCUncheckedCreateWithoutReligionInput> | NPCCreateWithoutReligionInput[] | NPCUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutReligionInput | NPCCreateOrConnectWithoutReligionInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutReligionInput | NPCUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: NPCCreateManyReligionInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutReligionInput | NPCUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutReligionInput | NPCUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type ReligionCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<ReligionCreateWithoutArtifactsInput, ReligionUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutArtifactsInput
    connect?: ReligionWhereUniqueInput
  }

  export type ReligionUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<ReligionCreateWithoutArtifactsInput, ReligionUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutArtifactsInput
    upsert?: ReligionUpsertWithoutArtifactsInput
    connect?: ReligionWhereUniqueInput
    update?: XOR<XOR<ReligionUpdateToOneWithWhereWithoutArtifactsInput, ReligionUpdateWithoutArtifactsInput>, ReligionUncheckedUpdateWithoutArtifactsInput>
  }

  export type CityCreateNestedOneWithoutWeatherInput = {
    create?: XOR<CityCreateWithoutWeatherInput, CityUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: CityCreateOrConnectWithoutWeatherInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutWeatherNestedInput = {
    create?: XOR<CityCreateWithoutWeatherInput, CityUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: CityCreateOrConnectWithoutWeatherInput
    upsert?: CityUpsertWithoutWeatherInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutWeatherInput, CityUpdateWithoutWeatherInput>, CityUncheckedUpdateWithoutWeatherInput>
  }

  export type NPCCreateNestedOneWithoutStoriesInput = {
    create?: XOR<NPCCreateWithoutStoriesInput, NPCUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: NPCCreateOrConnectWithoutStoriesInput
    connect?: NPCWhereUniqueInput
  }

  export type NPCUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<NPCCreateWithoutStoriesInput, NPCUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: NPCCreateOrConnectWithoutStoriesInput
    upsert?: NPCUpsertWithoutStoriesInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutStoriesInput, NPCUpdateWithoutStoriesInput>, NPCUncheckedUpdateWithoutStoriesInput>
  }

  export type UserCreateNestedOneWithoutTitlesInput = {
    create?: XOR<UserCreateWithoutTitlesInput, UserUncheckedCreateWithoutTitlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTitlesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTitlesNestedInput = {
    create?: XOR<UserCreateWithoutTitlesInput, UserUncheckedCreateWithoutTitlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTitlesInput
    upsert?: UserUpsertWithoutTitlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTitlesInput, UserUpdateWithoutTitlesInput>, UserUncheckedUpdateWithoutTitlesInput>
  }

  export type CityCreateNestedOneWithoutEconomiesInput = {
    create?: XOR<CityCreateWithoutEconomiesInput, CityUncheckedCreateWithoutEconomiesInput>
    connectOrCreate?: CityCreateOrConnectWithoutEconomiesInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutEconomiesNestedInput = {
    create?: XOR<CityCreateWithoutEconomiesInput, CityUncheckedCreateWithoutEconomiesInput>
    connectOrCreate?: CityCreateOrConnectWithoutEconomiesInput
    upsert?: CityUpsertWithoutEconomiesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutEconomiesInput, CityUpdateWithoutEconomiesInput>, CityUncheckedUpdateWithoutEconomiesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PlayerProfessionCreateWithoutUserInput = {
    type: string
    skillLevel?: number
    experience?: number
  }

  export type PlayerProfessionUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    skillLevel?: number
    experience?: number
  }

  export type PlayerProfessionCreateOrConnectWithoutUserInput = {
    where: PlayerProfessionWhereUniqueInput
    create: XOR<PlayerProfessionCreateWithoutUserInput, PlayerProfessionUncheckedCreateWithoutUserInput>
  }

  export type PlayerProfessionCreateManyUserInputEnvelope = {
    data: PlayerProfessionCreateManyUserInput | PlayerProfessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ItemInstanceCreateWithoutUserInput = {
    quantity: number
    item: ItemCreateNestedOneWithoutInstancesInput
  }

  export type ItemInstanceUncheckedCreateWithoutUserInput = {
    id?: number
    itemId: number
    quantity: number
  }

  export type ItemInstanceCreateOrConnectWithoutUserInput = {
    where: ItemInstanceWhereUniqueInput
    create: XOR<ItemInstanceCreateWithoutUserInput, ItemInstanceUncheckedCreateWithoutUserInput>
  }

  export type ItemInstanceCreateManyUserInputEnvelope = {
    data: ItemInstanceCreateManyUserInput | ItemInstanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlayerTitleCreateWithoutUserInput = {
    type: string
    region: string
    grantedAt: Date | string
    authority: number
  }

  export type PlayerTitleUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    region: string
    grantedAt: Date | string
    authority: number
  }

  export type PlayerTitleCreateOrConnectWithoutUserInput = {
    where: PlayerTitleWhereUniqueInput
    create: XOR<PlayerTitleCreateWithoutUserInput, PlayerTitleUncheckedCreateWithoutUserInput>
  }

  export type PlayerTitleCreateManyUserInputEnvelope = {
    data: PlayerTitleCreateManyUserInput | PlayerTitleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLanguageCreateWithoutUserInput = {
    fluency: number
    language: LanguageCreateNestedOneWithoutUserLanguagesInput
  }

  export type UserLanguageUncheckedCreateWithoutUserInput = {
    id?: number
    languageId: number
    fluency: number
  }

  export type UserLanguageCreateOrConnectWithoutUserInput = {
    where: UserLanguageWhereUniqueInput
    create: XOR<UserLanguageCreateWithoutUserInput, UserLanguageUncheckedCreateWithoutUserInput>
  }

  export type UserLanguageCreateManyUserInputEnvelope = {
    data: UserLanguageCreateManyUserInput | UserLanguageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestCreateWithoutTakerInput = {
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    issuer?: NPCCreateNestedOneWithoutQuestsInput
  }

  export type QuestUncheckedCreateWithoutTakerInput = {
    id?: number
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    issuerId?: number | null
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestCreateOrConnectWithoutTakerInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutTakerInput, QuestUncheckedCreateWithoutTakerInput>
  }

  export type QuestCreateManyTakerInputEnvelope = {
    data: QuestCreateManyTakerInput | QuestCreateManyTakerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerProfessionUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayerProfessionWhereUniqueInput
    update: XOR<PlayerProfessionUpdateWithoutUserInput, PlayerProfessionUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerProfessionCreateWithoutUserInput, PlayerProfessionUncheckedCreateWithoutUserInput>
  }

  export type PlayerProfessionUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayerProfessionWhereUniqueInput
    data: XOR<PlayerProfessionUpdateWithoutUserInput, PlayerProfessionUncheckedUpdateWithoutUserInput>
  }

  export type PlayerProfessionUpdateManyWithWhereWithoutUserInput = {
    where: PlayerProfessionScalarWhereInput
    data: XOR<PlayerProfessionUpdateManyMutationInput, PlayerProfessionUncheckedUpdateManyWithoutUserInput>
  }

  export type PlayerProfessionScalarWhereInput = {
    AND?: PlayerProfessionScalarWhereInput | PlayerProfessionScalarWhereInput[]
    OR?: PlayerProfessionScalarWhereInput[]
    NOT?: PlayerProfessionScalarWhereInput | PlayerProfessionScalarWhereInput[]
    id?: IntFilter<"PlayerProfession"> | number
    userId?: IntFilter<"PlayerProfession"> | number
    type?: StringFilter<"PlayerProfession"> | string
    skillLevel?: IntFilter<"PlayerProfession"> | number
    experience?: IntFilter<"PlayerProfession"> | number
  }

  export type ItemInstanceUpsertWithWhereUniqueWithoutUserInput = {
    where: ItemInstanceWhereUniqueInput
    update: XOR<ItemInstanceUpdateWithoutUserInput, ItemInstanceUncheckedUpdateWithoutUserInput>
    create: XOR<ItemInstanceCreateWithoutUserInput, ItemInstanceUncheckedCreateWithoutUserInput>
  }

  export type ItemInstanceUpdateWithWhereUniqueWithoutUserInput = {
    where: ItemInstanceWhereUniqueInput
    data: XOR<ItemInstanceUpdateWithoutUserInput, ItemInstanceUncheckedUpdateWithoutUserInput>
  }

  export type ItemInstanceUpdateManyWithWhereWithoutUserInput = {
    where: ItemInstanceScalarWhereInput
    data: XOR<ItemInstanceUpdateManyMutationInput, ItemInstanceUncheckedUpdateManyWithoutUserInput>
  }

  export type ItemInstanceScalarWhereInput = {
    AND?: ItemInstanceScalarWhereInput | ItemInstanceScalarWhereInput[]
    OR?: ItemInstanceScalarWhereInput[]
    NOT?: ItemInstanceScalarWhereInput | ItemInstanceScalarWhereInput[]
    id?: IntFilter<"ItemInstance"> | number
    userId?: IntFilter<"ItemInstance"> | number
    itemId?: IntFilter<"ItemInstance"> | number
    quantity?: IntFilter<"ItemInstance"> | number
  }

  export type PlayerTitleUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayerTitleWhereUniqueInput
    update: XOR<PlayerTitleUpdateWithoutUserInput, PlayerTitleUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerTitleCreateWithoutUserInput, PlayerTitleUncheckedCreateWithoutUserInput>
  }

  export type PlayerTitleUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayerTitleWhereUniqueInput
    data: XOR<PlayerTitleUpdateWithoutUserInput, PlayerTitleUncheckedUpdateWithoutUserInput>
  }

  export type PlayerTitleUpdateManyWithWhereWithoutUserInput = {
    where: PlayerTitleScalarWhereInput
    data: XOR<PlayerTitleUpdateManyMutationInput, PlayerTitleUncheckedUpdateManyWithoutUserInput>
  }

  export type PlayerTitleScalarWhereInput = {
    AND?: PlayerTitleScalarWhereInput | PlayerTitleScalarWhereInput[]
    OR?: PlayerTitleScalarWhereInput[]
    NOT?: PlayerTitleScalarWhereInput | PlayerTitleScalarWhereInput[]
    id?: IntFilter<"PlayerTitle"> | number
    userId?: IntFilter<"PlayerTitle"> | number
    type?: StringFilter<"PlayerTitle"> | string
    region?: StringFilter<"PlayerTitle"> | string
    grantedAt?: DateTimeFilter<"PlayerTitle"> | Date | string
    authority?: IntFilter<"PlayerTitle"> | number
  }

  export type UserLanguageUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLanguageWhereUniqueInput
    update: XOR<UserLanguageUpdateWithoutUserInput, UserLanguageUncheckedUpdateWithoutUserInput>
    create: XOR<UserLanguageCreateWithoutUserInput, UserLanguageUncheckedCreateWithoutUserInput>
  }

  export type UserLanguageUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLanguageWhereUniqueInput
    data: XOR<UserLanguageUpdateWithoutUserInput, UserLanguageUncheckedUpdateWithoutUserInput>
  }

  export type UserLanguageUpdateManyWithWhereWithoutUserInput = {
    where: UserLanguageScalarWhereInput
    data: XOR<UserLanguageUpdateManyMutationInput, UserLanguageUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLanguageScalarWhereInput = {
    AND?: UserLanguageScalarWhereInput | UserLanguageScalarWhereInput[]
    OR?: UserLanguageScalarWhereInput[]
    NOT?: UserLanguageScalarWhereInput | UserLanguageScalarWhereInput[]
    id?: IntFilter<"UserLanguage"> | number
    userId?: IntFilter<"UserLanguage"> | number
    languageId?: IntFilter<"UserLanguage"> | number
    fluency?: IntFilter<"UserLanguage"> | number
  }

  export type QuestUpsertWithWhereUniqueWithoutTakerInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutTakerInput, QuestUncheckedUpdateWithoutTakerInput>
    create: XOR<QuestCreateWithoutTakerInput, QuestUncheckedCreateWithoutTakerInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutTakerInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutTakerInput, QuestUncheckedUpdateWithoutTakerInput>
  }

  export type QuestUpdateManyWithWhereWithoutTakerInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutTakerInput>
  }

  export type QuestScalarWhereInput = {
    AND?: QuestScalarWhereInput | QuestScalarWhereInput[]
    OR?: QuestScalarWhereInput[]
    NOT?: QuestScalarWhereInput | QuestScalarWhereInput[]
    id?: IntFilter<"Quest"> | number
    title?: StringFilter<"Quest"> | string
    description?: StringFilter<"Quest"> | string
    isTaken?: BoolFilter<"Quest"> | boolean
    takenAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    reputationRequired?: IntFilter<"Quest"> | number
    notorietyTrigger?: BoolFilter<"Quest"> | boolean
    issuerId?: IntNullableFilter<"Quest"> | number | null
    takerId?: IntNullableFilter<"Quest"> | number | null
    bountyTargetId?: IntNullableFilter<"Quest"> | number | null
    metadata?: JsonNullableFilter<"Quest">
  }

  export type CityCreateWithoutNpcsInput = {
    name: string
    description: string
    population: number
    country: CountryCreateNestedOneWithoutCitiesInput
    wildAreas?: WildAreaCreateNestedManyWithoutCityInput
    dungeons?: DungeonCreateNestedManyWithoutCityInput
    weather?: WeatherCreateNestedOneWithoutCityInput
    economies?: EconomyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutNpcsInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCityInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCityInput
    weather?: WeatherUncheckedCreateNestedOneWithoutCityInput
    economies?: EconomyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutNpcsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutNpcsInput, CityUncheckedCreateWithoutNpcsInput>
  }

  export type LanguageCreateWithoutSpeakersInput = {
    name: string
    isAncient?: boolean
    region?: string | null
    userLanguages?: UserLanguageCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutSpeakersInput = {
    id?: number
    name: string
    isAncient?: boolean
    region?: string | null
    userLanguages?: UserLanguageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutSpeakersInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutSpeakersInput, LanguageUncheckedCreateWithoutSpeakersInput>
  }

  export type ReligionCreateWithoutFollowersInput = {
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    artifacts?: ArtifactCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateWithoutFollowersInput = {
    id?: number
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionCreateOrConnectWithoutFollowersInput = {
    where: ReligionWhereUniqueInput
    create: XOR<ReligionCreateWithoutFollowersInput, ReligionUncheckedCreateWithoutFollowersInput>
  }

  export type NPCStoryCreateWithoutNpcInput = {
    title: string
    summary: string
    createdAt?: Date | string
  }

  export type NPCStoryUncheckedCreateWithoutNpcInput = {
    id?: number
    title: string
    summary: string
    createdAt?: Date | string
  }

  export type NPCStoryCreateOrConnectWithoutNpcInput = {
    where: NPCStoryWhereUniqueInput
    create: XOR<NPCStoryCreateWithoutNpcInput, NPCStoryUncheckedCreateWithoutNpcInput>
  }

  export type NPCStoryCreateManyNpcInputEnvelope = {
    data: NPCStoryCreateManyNpcInput | NPCStoryCreateManyNpcInput[]
    skipDuplicates?: boolean
  }

  export type QuestCreateWithoutIssuerInput = {
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    taker?: UserCreateNestedOneWithoutQuestsInput
  }

  export type QuestUncheckedCreateWithoutIssuerInput = {
    id?: number
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    takerId?: number | null
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestCreateOrConnectWithoutIssuerInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutIssuerInput, QuestUncheckedCreateWithoutIssuerInput>
  }

  export type QuestCreateManyIssuerInputEnvelope = {
    data: QuestCreateManyIssuerInput | QuestCreateManyIssuerInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutNpcsInput = {
    update: XOR<CityUpdateWithoutNpcsInput, CityUncheckedUpdateWithoutNpcsInput>
    create: XOR<CityCreateWithoutNpcsInput, CityUncheckedCreateWithoutNpcsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutNpcsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutNpcsInput, CityUncheckedUpdateWithoutNpcsInput>
  }

  export type CityUpdateWithoutNpcsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUpdateManyWithoutCityNestedInput
    weather?: WeatherUpdateOneWithoutCityNestedInput
    economies?: EconomyUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutNpcsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCityNestedInput
    weather?: WeatherUncheckedUpdateOneWithoutCityNestedInput
    economies?: EconomyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type LanguageUpsertWithoutSpeakersInput = {
    update: XOR<LanguageUpdateWithoutSpeakersInput, LanguageUncheckedUpdateWithoutSpeakersInput>
    create: XOR<LanguageCreateWithoutSpeakersInput, LanguageUncheckedCreateWithoutSpeakersInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutSpeakersInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutSpeakersInput, LanguageUncheckedUpdateWithoutSpeakersInput>
  }

  export type LanguageUpdateWithoutSpeakersInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    userLanguages?: UserLanguageUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutSpeakersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    userLanguages?: UserLanguageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type ReligionUpsertWithoutFollowersInput = {
    update: XOR<ReligionUpdateWithoutFollowersInput, ReligionUncheckedUpdateWithoutFollowersInput>
    create: XOR<ReligionCreateWithoutFollowersInput, ReligionUncheckedCreateWithoutFollowersInput>
    where?: ReligionWhereInput
  }

  export type ReligionUpdateToOneWithWhereWithoutFollowersInput = {
    where?: ReligionWhereInput
    data: XOR<ReligionUpdateWithoutFollowersInput, ReligionUncheckedUpdateWithoutFollowersInput>
  }

  export type ReligionUpdateWithoutFollowersInput = {
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
    artifacts?: ArtifactUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateWithoutFollowersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
    artifacts?: ArtifactUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type NPCStoryUpsertWithWhereUniqueWithoutNpcInput = {
    where: NPCStoryWhereUniqueInput
    update: XOR<NPCStoryUpdateWithoutNpcInput, NPCStoryUncheckedUpdateWithoutNpcInput>
    create: XOR<NPCStoryCreateWithoutNpcInput, NPCStoryUncheckedCreateWithoutNpcInput>
  }

  export type NPCStoryUpdateWithWhereUniqueWithoutNpcInput = {
    where: NPCStoryWhereUniqueInput
    data: XOR<NPCStoryUpdateWithoutNpcInput, NPCStoryUncheckedUpdateWithoutNpcInput>
  }

  export type NPCStoryUpdateManyWithWhereWithoutNpcInput = {
    where: NPCStoryScalarWhereInput
    data: XOR<NPCStoryUpdateManyMutationInput, NPCStoryUncheckedUpdateManyWithoutNpcInput>
  }

  export type NPCStoryScalarWhereInput = {
    AND?: NPCStoryScalarWhereInput | NPCStoryScalarWhereInput[]
    OR?: NPCStoryScalarWhereInput[]
    NOT?: NPCStoryScalarWhereInput | NPCStoryScalarWhereInput[]
    id?: IntFilter<"NPCStory"> | number
    npcId?: IntFilter<"NPCStory"> | number
    title?: StringFilter<"NPCStory"> | string
    summary?: StringFilter<"NPCStory"> | string
    createdAt?: DateTimeFilter<"NPCStory"> | Date | string
  }

  export type QuestUpsertWithWhereUniqueWithoutIssuerInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutIssuerInput, QuestUncheckedUpdateWithoutIssuerInput>
    create: XOR<QuestCreateWithoutIssuerInput, QuestUncheckedCreateWithoutIssuerInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutIssuerInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutIssuerInput, QuestUncheckedUpdateWithoutIssuerInput>
  }

  export type QuestUpdateManyWithWhereWithoutIssuerInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutIssuerInput>
  }

  export type CountryCreateWithoutCitiesInput = {
    name: string
    description: string
    language: string
    wildAreas?: WildAreaCreateNestedManyWithoutCountryInput
    dungeons?: DungeonCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: number
    name: string
    description: string
    language: string
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCountryInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type WildAreaCreateWithoutCityInput = {
    name: string
    type: string
    dangerLevel: number
    country: CountryCreateNestedOneWithoutWildAreasInput
    populations?: AnimalPopulationCreateNestedManyWithoutAreaInput
  }

  export type WildAreaUncheckedCreateWithoutCityInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    countryId: number
    populations?: AnimalPopulationUncheckedCreateNestedManyWithoutAreaInput
  }

  export type WildAreaCreateOrConnectWithoutCityInput = {
    where: WildAreaWhereUniqueInput
    create: XOR<WildAreaCreateWithoutCityInput, WildAreaUncheckedCreateWithoutCityInput>
  }

  export type WildAreaCreateManyCityInputEnvelope = {
    data: WildAreaCreateManyCityInput | WildAreaCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type DungeonCreateWithoutCityInput = {
    name: string
    levelRequirement: number
    isRaid: boolean
    country: CountryCreateNestedOneWithoutDungeonsInput
  }

  export type DungeonUncheckedCreateWithoutCityInput = {
    id?: number
    name: string
    levelRequirement: number
    isRaid: boolean
    countryId: number
  }

  export type DungeonCreateOrConnectWithoutCityInput = {
    where: DungeonWhereUniqueInput
    create: XOR<DungeonCreateWithoutCityInput, DungeonUncheckedCreateWithoutCityInput>
  }

  export type DungeonCreateManyCityInputEnvelope = {
    data: DungeonCreateManyCityInput | DungeonCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type WeatherCreateWithoutCityInput = {
    condition: string
    updatedAt: Date | string
  }

  export type WeatherUncheckedCreateWithoutCityInput = {
    id?: number
    condition: string
    updatedAt: Date | string
  }

  export type WeatherCreateOrConnectWithoutCityInput = {
    where: WeatherWhereUniqueInput
    create: XOR<WeatherCreateWithoutCityInput, WeatherUncheckedCreateWithoutCityInput>
  }

  export type NPCCreateWithoutCityInput = {
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    language: LanguageCreateNestedOneWithoutSpeakersInput
    religion?: ReligionCreateNestedOneWithoutFollowersInput
    stories?: NPCStoryCreateNestedManyWithoutNpcInput
    quests?: QuestCreateNestedManyWithoutIssuerInput
  }

  export type NPCUncheckedCreateWithoutCityInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId?: number | null
    stories?: NPCStoryUncheckedCreateNestedManyWithoutNpcInput
    quests?: QuestUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type NPCCreateOrConnectWithoutCityInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutCityInput, NPCUncheckedCreateWithoutCityInput>
  }

  export type NPCCreateManyCityInputEnvelope = {
    data: NPCCreateManyCityInput | NPCCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type EconomyCreateWithoutCityInput = {
    item: string
    price: number
    demand: string
    supply: string
  }

  export type EconomyUncheckedCreateWithoutCityInput = {
    id?: number
    item: string
    price: number
    demand: string
    supply: string
  }

  export type EconomyCreateOrConnectWithoutCityInput = {
    where: EconomyWhereUniqueInput
    create: XOR<EconomyCreateWithoutCityInput, EconomyUncheckedCreateWithoutCityInput>
  }

  export type EconomyCreateManyCityInputEnvelope = {
    data: EconomyCreateManyCityInput | EconomyCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    wildAreas?: WildAreaUpdateManyWithoutCountryNestedInput
    dungeons?: DungeonUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCountryNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type WildAreaUpsertWithWhereUniqueWithoutCityInput = {
    where: WildAreaWhereUniqueInput
    update: XOR<WildAreaUpdateWithoutCityInput, WildAreaUncheckedUpdateWithoutCityInput>
    create: XOR<WildAreaCreateWithoutCityInput, WildAreaUncheckedCreateWithoutCityInput>
  }

  export type WildAreaUpdateWithWhereUniqueWithoutCityInput = {
    where: WildAreaWhereUniqueInput
    data: XOR<WildAreaUpdateWithoutCityInput, WildAreaUncheckedUpdateWithoutCityInput>
  }

  export type WildAreaUpdateManyWithWhereWithoutCityInput = {
    where: WildAreaScalarWhereInput
    data: XOR<WildAreaUpdateManyMutationInput, WildAreaUncheckedUpdateManyWithoutCityInput>
  }

  export type WildAreaScalarWhereInput = {
    AND?: WildAreaScalarWhereInput | WildAreaScalarWhereInput[]
    OR?: WildAreaScalarWhereInput[]
    NOT?: WildAreaScalarWhereInput | WildAreaScalarWhereInput[]
    id?: IntFilter<"WildArea"> | number
    name?: StringFilter<"WildArea"> | string
    type?: StringFilter<"WildArea"> | string
    dangerLevel?: IntFilter<"WildArea"> | number
    countryId?: IntFilter<"WildArea"> | number
    cityId?: IntNullableFilter<"WildArea"> | number | null
  }

  export type DungeonUpsertWithWhereUniqueWithoutCityInput = {
    where: DungeonWhereUniqueInput
    update: XOR<DungeonUpdateWithoutCityInput, DungeonUncheckedUpdateWithoutCityInput>
    create: XOR<DungeonCreateWithoutCityInput, DungeonUncheckedCreateWithoutCityInput>
  }

  export type DungeonUpdateWithWhereUniqueWithoutCityInput = {
    where: DungeonWhereUniqueInput
    data: XOR<DungeonUpdateWithoutCityInput, DungeonUncheckedUpdateWithoutCityInput>
  }

  export type DungeonUpdateManyWithWhereWithoutCityInput = {
    where: DungeonScalarWhereInput
    data: XOR<DungeonUpdateManyMutationInput, DungeonUncheckedUpdateManyWithoutCityInput>
  }

  export type DungeonScalarWhereInput = {
    AND?: DungeonScalarWhereInput | DungeonScalarWhereInput[]
    OR?: DungeonScalarWhereInput[]
    NOT?: DungeonScalarWhereInput | DungeonScalarWhereInput[]
    id?: IntFilter<"Dungeon"> | number
    name?: StringFilter<"Dungeon"> | string
    levelRequirement?: IntFilter<"Dungeon"> | number
    isRaid?: BoolFilter<"Dungeon"> | boolean
    countryId?: IntFilter<"Dungeon"> | number
    cityId?: IntNullableFilter<"Dungeon"> | number | null
  }

  export type WeatherUpsertWithoutCityInput = {
    update: XOR<WeatherUpdateWithoutCityInput, WeatherUncheckedUpdateWithoutCityInput>
    create: XOR<WeatherCreateWithoutCityInput, WeatherUncheckedCreateWithoutCityInput>
    where?: WeatherWhereInput
  }

  export type WeatherUpdateToOneWithWhereWithoutCityInput = {
    where?: WeatherWhereInput
    data: XOR<WeatherUpdateWithoutCityInput, WeatherUncheckedUpdateWithoutCityInput>
  }

  export type WeatherUpdateWithoutCityInput = {
    condition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCUpsertWithWhereUniqueWithoutCityInput = {
    where: NPCWhereUniqueInput
    update: XOR<NPCUpdateWithoutCityInput, NPCUncheckedUpdateWithoutCityInput>
    create: XOR<NPCCreateWithoutCityInput, NPCUncheckedCreateWithoutCityInput>
  }

  export type NPCUpdateWithWhereUniqueWithoutCityInput = {
    where: NPCWhereUniqueInput
    data: XOR<NPCUpdateWithoutCityInput, NPCUncheckedUpdateWithoutCityInput>
  }

  export type NPCUpdateManyWithWhereWithoutCityInput = {
    where: NPCScalarWhereInput
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyWithoutCityInput>
  }

  export type NPCScalarWhereInput = {
    AND?: NPCScalarWhereInput | NPCScalarWhereInput[]
    OR?: NPCScalarWhereInput[]
    NOT?: NPCScalarWhereInput | NPCScalarWhereInput[]
    id?: IntFilter<"NPC"> | number
    name?: StringFilter<"NPC"> | string
    gender?: StringFilter<"NPC"> | string
    birthYear?: IntFilter<"NPC"> | number
    deathYear?: IntNullableFilter<"NPC"> | number | null
    isAlive?: BoolFilter<"NPC"> | boolean
    mood?: StringFilter<"NPC"> | string
    fame?: IntFilter<"NPC"> | number
    notoriety?: IntFilter<"NPC"> | number
    cityId?: IntFilter<"NPC"> | number
    partnerId?: IntNullableFilter<"NPC"> | number | null
    parent1Id?: IntNullableFilter<"NPC"> | number | null
    parent2Id?: IntNullableFilter<"NPC"> | number | null
    isNoble?: BoolFilter<"NPC"> | boolean
    nobleTitle?: StringNullableFilter<"NPC"> | string | null
    personality?: StringNullableFilter<"NPC"> | string | null
    background?: StringFilter<"NPC"> | string
    job?: StringFilter<"NPC"> | string
    skills?: StringFilter<"NPC"> | string
    languageId?: IntFilter<"NPC"> | number
    religionId?: IntNullableFilter<"NPC"> | number | null
  }

  export type EconomyUpsertWithWhereUniqueWithoutCityInput = {
    where: EconomyWhereUniqueInput
    update: XOR<EconomyUpdateWithoutCityInput, EconomyUncheckedUpdateWithoutCityInput>
    create: XOR<EconomyCreateWithoutCityInput, EconomyUncheckedCreateWithoutCityInput>
  }

  export type EconomyUpdateWithWhereUniqueWithoutCityInput = {
    where: EconomyWhereUniqueInput
    data: XOR<EconomyUpdateWithoutCityInput, EconomyUncheckedUpdateWithoutCityInput>
  }

  export type EconomyUpdateManyWithWhereWithoutCityInput = {
    where: EconomyScalarWhereInput
    data: XOR<EconomyUpdateManyMutationInput, EconomyUncheckedUpdateManyWithoutCityInput>
  }

  export type EconomyScalarWhereInput = {
    AND?: EconomyScalarWhereInput | EconomyScalarWhereInput[]
    OR?: EconomyScalarWhereInput[]
    NOT?: EconomyScalarWhereInput | EconomyScalarWhereInput[]
    id?: IntFilter<"Economy"> | number
    cityId?: IntFilter<"Economy"> | number
    item?: StringFilter<"Economy"> | string
    price?: IntFilter<"Economy"> | number
    demand?: StringFilter<"Economy"> | string
    supply?: StringFilter<"Economy"> | string
  }

  export type CityCreateWithoutCountryInput = {
    name: string
    description: string
    population: number
    wildAreas?: WildAreaCreateNestedManyWithoutCityInput
    dungeons?: DungeonCreateNestedManyWithoutCityInput
    weather?: WeatherCreateNestedOneWithoutCityInput
    npcs?: NPCCreateNestedManyWithoutCityInput
    economies?: EconomyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    description: string
    population: number
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCityInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCityInput
    weather?: WeatherUncheckedCreateNestedOneWithoutCityInput
    npcs?: NPCUncheckedCreateNestedManyWithoutCityInput
    economies?: EconomyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type WildAreaCreateWithoutCountryInput = {
    name: string
    type: string
    dangerLevel: number
    populations?: AnimalPopulationCreateNestedManyWithoutAreaInput
    city?: CityCreateNestedOneWithoutWildAreasInput
  }

  export type WildAreaUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    cityId?: number | null
    populations?: AnimalPopulationUncheckedCreateNestedManyWithoutAreaInput
  }

  export type WildAreaCreateOrConnectWithoutCountryInput = {
    where: WildAreaWhereUniqueInput
    create: XOR<WildAreaCreateWithoutCountryInput, WildAreaUncheckedCreateWithoutCountryInput>
  }

  export type WildAreaCreateManyCountryInputEnvelope = {
    data: WildAreaCreateManyCountryInput | WildAreaCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type DungeonCreateWithoutCountryInput = {
    name: string
    levelRequirement: number
    isRaid: boolean
    city?: CityCreateNestedOneWithoutDungeonsInput
  }

  export type DungeonUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    levelRequirement: number
    isRaid: boolean
    cityId?: number | null
  }

  export type DungeonCreateOrConnectWithoutCountryInput = {
    where: DungeonWhereUniqueInput
    create: XOR<DungeonCreateWithoutCountryInput, DungeonUncheckedCreateWithoutCountryInput>
  }

  export type DungeonCreateManyCountryInputEnvelope = {
    data: DungeonCreateManyCountryInput | DungeonCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: IntFilter<"City"> | number
    name?: StringFilter<"City"> | string
    description?: StringFilter<"City"> | string
    population?: IntFilter<"City"> | number
    countryId?: IntFilter<"City"> | number
  }

  export type WildAreaUpsertWithWhereUniqueWithoutCountryInput = {
    where: WildAreaWhereUniqueInput
    update: XOR<WildAreaUpdateWithoutCountryInput, WildAreaUncheckedUpdateWithoutCountryInput>
    create: XOR<WildAreaCreateWithoutCountryInput, WildAreaUncheckedCreateWithoutCountryInput>
  }

  export type WildAreaUpdateWithWhereUniqueWithoutCountryInput = {
    where: WildAreaWhereUniqueInput
    data: XOR<WildAreaUpdateWithoutCountryInput, WildAreaUncheckedUpdateWithoutCountryInput>
  }

  export type WildAreaUpdateManyWithWhereWithoutCountryInput = {
    where: WildAreaScalarWhereInput
    data: XOR<WildAreaUpdateManyMutationInput, WildAreaUncheckedUpdateManyWithoutCountryInput>
  }

  export type DungeonUpsertWithWhereUniqueWithoutCountryInput = {
    where: DungeonWhereUniqueInput
    update: XOR<DungeonUpdateWithoutCountryInput, DungeonUncheckedUpdateWithoutCountryInput>
    create: XOR<DungeonCreateWithoutCountryInput, DungeonUncheckedCreateWithoutCountryInput>
  }

  export type DungeonUpdateWithWhereUniqueWithoutCountryInput = {
    where: DungeonWhereUniqueInput
    data: XOR<DungeonUpdateWithoutCountryInput, DungeonUncheckedUpdateWithoutCountryInput>
  }

  export type DungeonUpdateManyWithWhereWithoutCountryInput = {
    where: DungeonScalarWhereInput
    data: XOR<DungeonUpdateManyMutationInput, DungeonUncheckedUpdateManyWithoutCountryInput>
  }

  export type CountryCreateWithoutWildAreasInput = {
    name: string
    description: string
    language: string
    cities?: CityCreateNestedManyWithoutCountryInput
    dungeons?: DungeonCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutWildAreasInput = {
    id?: number
    name: string
    description: string
    language: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutWildAreasInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutWildAreasInput, CountryUncheckedCreateWithoutWildAreasInput>
  }

  export type AnimalPopulationCreateWithoutAreaInput = {
    species: string
    type: string
    population: number
  }

  export type AnimalPopulationUncheckedCreateWithoutAreaInput = {
    id?: number
    species: string
    type: string
    population: number
  }

  export type AnimalPopulationCreateOrConnectWithoutAreaInput = {
    where: AnimalPopulationWhereUniqueInput
    create: XOR<AnimalPopulationCreateWithoutAreaInput, AnimalPopulationUncheckedCreateWithoutAreaInput>
  }

  export type AnimalPopulationCreateManyAreaInputEnvelope = {
    data: AnimalPopulationCreateManyAreaInput | AnimalPopulationCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutWildAreasInput = {
    name: string
    description: string
    population: number
    country: CountryCreateNestedOneWithoutCitiesInput
    dungeons?: DungeonCreateNestedManyWithoutCityInput
    weather?: WeatherCreateNestedOneWithoutCityInput
    npcs?: NPCCreateNestedManyWithoutCityInput
    economies?: EconomyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutWildAreasInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCityInput
    weather?: WeatherUncheckedCreateNestedOneWithoutCityInput
    npcs?: NPCUncheckedCreateNestedManyWithoutCityInput
    economies?: EconomyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutWildAreasInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutWildAreasInput, CityUncheckedCreateWithoutWildAreasInput>
  }

  export type CountryUpsertWithoutWildAreasInput = {
    update: XOR<CountryUpdateWithoutWildAreasInput, CountryUncheckedUpdateWithoutWildAreasInput>
    create: XOR<CountryCreateWithoutWildAreasInput, CountryUncheckedCreateWithoutWildAreasInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutWildAreasInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutWildAreasInput, CountryUncheckedUpdateWithoutWildAreasInput>
  }

  export type CountryUpdateWithoutWildAreasInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    dungeons?: DungeonUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutWildAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type AnimalPopulationUpsertWithWhereUniqueWithoutAreaInput = {
    where: AnimalPopulationWhereUniqueInput
    update: XOR<AnimalPopulationUpdateWithoutAreaInput, AnimalPopulationUncheckedUpdateWithoutAreaInput>
    create: XOR<AnimalPopulationCreateWithoutAreaInput, AnimalPopulationUncheckedCreateWithoutAreaInput>
  }

  export type AnimalPopulationUpdateWithWhereUniqueWithoutAreaInput = {
    where: AnimalPopulationWhereUniqueInput
    data: XOR<AnimalPopulationUpdateWithoutAreaInput, AnimalPopulationUncheckedUpdateWithoutAreaInput>
  }

  export type AnimalPopulationUpdateManyWithWhereWithoutAreaInput = {
    where: AnimalPopulationScalarWhereInput
    data: XOR<AnimalPopulationUpdateManyMutationInput, AnimalPopulationUncheckedUpdateManyWithoutAreaInput>
  }

  export type AnimalPopulationScalarWhereInput = {
    AND?: AnimalPopulationScalarWhereInput | AnimalPopulationScalarWhereInput[]
    OR?: AnimalPopulationScalarWhereInput[]
    NOT?: AnimalPopulationScalarWhereInput | AnimalPopulationScalarWhereInput[]
    id?: IntFilter<"AnimalPopulation"> | number
    species?: StringFilter<"AnimalPopulation"> | string
    type?: StringFilter<"AnimalPopulation"> | string
    population?: IntFilter<"AnimalPopulation"> | number
    areaId?: IntFilter<"AnimalPopulation"> | number
  }

  export type CityUpsertWithoutWildAreasInput = {
    update: XOR<CityUpdateWithoutWildAreasInput, CityUncheckedUpdateWithoutWildAreasInput>
    create: XOR<CityCreateWithoutWildAreasInput, CityUncheckedCreateWithoutWildAreasInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutWildAreasInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutWildAreasInput, CityUncheckedUpdateWithoutWildAreasInput>
  }

  export type CityUpdateWithoutWildAreasInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    dungeons?: DungeonUpdateManyWithoutCityNestedInput
    weather?: WeatherUpdateOneWithoutCityNestedInput
    npcs?: NPCUpdateManyWithoutCityNestedInput
    economies?: EconomyUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutWildAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    dungeons?: DungeonUncheckedUpdateManyWithoutCityNestedInput
    weather?: WeatherUncheckedUpdateOneWithoutCityNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutCityNestedInput
    economies?: EconomyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CountryCreateWithoutDungeonsInput = {
    name: string
    description: string
    language: string
    cities?: CityCreateNestedManyWithoutCountryInput
    wildAreas?: WildAreaCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutDungeonsInput = {
    id?: number
    name: string
    description: string
    language: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutDungeonsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutDungeonsInput, CountryUncheckedCreateWithoutDungeonsInput>
  }

  export type CityCreateWithoutDungeonsInput = {
    name: string
    description: string
    population: number
    country: CountryCreateNestedOneWithoutCitiesInput
    wildAreas?: WildAreaCreateNestedManyWithoutCityInput
    weather?: WeatherCreateNestedOneWithoutCityInput
    npcs?: NPCCreateNestedManyWithoutCityInput
    economies?: EconomyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutDungeonsInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCityInput
    weather?: WeatherUncheckedCreateNestedOneWithoutCityInput
    npcs?: NPCUncheckedCreateNestedManyWithoutCityInput
    economies?: EconomyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDungeonsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDungeonsInput, CityUncheckedCreateWithoutDungeonsInput>
  }

  export type CountryUpsertWithoutDungeonsInput = {
    update: XOR<CountryUpdateWithoutDungeonsInput, CountryUncheckedUpdateWithoutDungeonsInput>
    create: XOR<CountryCreateWithoutDungeonsInput, CountryUncheckedCreateWithoutDungeonsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutDungeonsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutDungeonsInput, CountryUncheckedUpdateWithoutDungeonsInput>
  }

  export type CountryUpdateWithoutDungeonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutDungeonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutDungeonsInput = {
    update: XOR<CityUpdateWithoutDungeonsInput, CityUncheckedUpdateWithoutDungeonsInput>
    create: XOR<CityCreateWithoutDungeonsInput, CityUncheckedCreateWithoutDungeonsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDungeonsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDungeonsInput, CityUncheckedUpdateWithoutDungeonsInput>
  }

  export type CityUpdateWithoutDungeonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCityNestedInput
    weather?: WeatherUpdateOneWithoutCityNestedInput
    npcs?: NPCUpdateManyWithoutCityNestedInput
    economies?: EconomyUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutDungeonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCityNestedInput
    weather?: WeatherUncheckedUpdateOneWithoutCityNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutCityNestedInput
    economies?: EconomyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type NPCCreateWithoutQuestsInput = {
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    city: CityCreateNestedOneWithoutNpcsInput
    language: LanguageCreateNestedOneWithoutSpeakersInput
    religion?: ReligionCreateNestedOneWithoutFollowersInput
    stories?: NPCStoryCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutQuestsInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId?: number | null
    stories?: NPCStoryUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutQuestsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
  }

  export type UserCreateWithoutQuestsInput = {
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceCreateNestedManyWithoutUserInput
    titles?: PlayerTitleCreateNestedManyWithoutUserInput
    languages?: UserLanguageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestsInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionUncheckedCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceUncheckedCreateNestedManyWithoutUserInput
    titles?: PlayerTitleUncheckedCreateNestedManyWithoutUserInput
    languages?: UserLanguageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestsInput, UserUncheckedCreateWithoutQuestsInput>
  }

  export type NPCUpsertWithoutQuestsInput = {
    update: XOR<NPCUpdateWithoutQuestsInput, NPCUncheckedUpdateWithoutQuestsInput>
    create: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutQuestsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutQuestsInput, NPCUncheckedUpdateWithoutQuestsInput>
  }

  export type NPCUpdateWithoutQuestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutNpcsNestedInput
    language?: LanguageUpdateOneRequiredWithoutSpeakersNestedInput
    religion?: ReligionUpdateOneWithoutFollowersNestedInput
    stories?: NPCStoryUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
    stories?: NPCStoryUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type UserUpsertWithoutQuestsInput = {
    update: XOR<UserUpdateWithoutQuestsInput, UserUncheckedUpdateWithoutQuestsInput>
    create: XOR<UserCreateWithoutQuestsInput, UserUncheckedCreateWithoutQuestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestsInput, UserUncheckedUpdateWithoutQuestsInput>
  }

  export type UserUpdateWithoutQuestsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUncheckedUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUncheckedUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUncheckedUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfessionInput = {
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    inventory?: ItemInstanceCreateNestedManyWithoutUserInput
    titles?: PlayerTitleCreateNestedManyWithoutUserInput
    languages?: UserLanguageCreateNestedManyWithoutUserInput
    quests?: QuestCreateNestedManyWithoutTakerInput
  }

  export type UserUncheckedCreateWithoutProfessionInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    inventory?: ItemInstanceUncheckedCreateNestedManyWithoutUserInput
    titles?: PlayerTitleUncheckedCreateNestedManyWithoutUserInput
    languages?: UserLanguageUncheckedCreateNestedManyWithoutUserInput
    quests?: QuestUncheckedCreateNestedManyWithoutTakerInput
  }

  export type UserCreateOrConnectWithoutProfessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfessionInput, UserUncheckedCreateWithoutProfessionInput>
  }

  export type UserUpsertWithoutProfessionInput = {
    update: XOR<UserUpdateWithoutProfessionInput, UserUncheckedUpdateWithoutProfessionInput>
    create: XOR<UserCreateWithoutProfessionInput, UserUncheckedCreateWithoutProfessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfessionInput, UserUncheckedUpdateWithoutProfessionInput>
  }

  export type UserUpdateWithoutProfessionInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    inventory?: ItemInstanceUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUpdateManyWithoutUserNestedInput
    quests?: QuestUpdateManyWithoutTakerNestedInput
  }

  export type UserUncheckedUpdateWithoutProfessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    inventory?: ItemInstanceUncheckedUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUncheckedUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUncheckedUpdateManyWithoutUserNestedInput
    quests?: QuestUncheckedUpdateManyWithoutTakerNestedInput
  }

  export type ItemInstanceCreateWithoutItemInput = {
    quantity: number
    user: UserCreateNestedOneWithoutInventoryInput
  }

  export type ItemInstanceUncheckedCreateWithoutItemInput = {
    id?: number
    userId: number
    quantity: number
  }

  export type ItemInstanceCreateOrConnectWithoutItemInput = {
    where: ItemInstanceWhereUniqueInput
    create: XOR<ItemInstanceCreateWithoutItemInput, ItemInstanceUncheckedCreateWithoutItemInput>
  }

  export type ItemInstanceCreateManyItemInputEnvelope = {
    data: ItemInstanceCreateManyItemInput | ItemInstanceCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutProductInput = {
    name: string
    profession: string
    difficulty: number
    materials?: RecipeMaterialCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    profession: string
    difficulty: number
    materials?: RecipeMaterialUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutProductInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutProductInput, RecipeUncheckedCreateWithoutProductInput>
  }

  export type RecipeCreateManyProductInputEnvelope = {
    data: RecipeCreateManyProductInput | RecipeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RecipeMaterialCreateWithoutItemInput = {
    quantity: number
    recipe: RecipeCreateNestedOneWithoutMaterialsInput
  }

  export type RecipeMaterialUncheckedCreateWithoutItemInput = {
    id?: number
    recipeId: number
    quantity: number
  }

  export type RecipeMaterialCreateOrConnectWithoutItemInput = {
    where: RecipeMaterialWhereUniqueInput
    create: XOR<RecipeMaterialCreateWithoutItemInput, RecipeMaterialUncheckedCreateWithoutItemInput>
  }

  export type RecipeMaterialCreateManyItemInputEnvelope = {
    data: RecipeMaterialCreateManyItemInput | RecipeMaterialCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemInstanceUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemInstanceWhereUniqueInput
    update: XOR<ItemInstanceUpdateWithoutItemInput, ItemInstanceUncheckedUpdateWithoutItemInput>
    create: XOR<ItemInstanceCreateWithoutItemInput, ItemInstanceUncheckedCreateWithoutItemInput>
  }

  export type ItemInstanceUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemInstanceWhereUniqueInput
    data: XOR<ItemInstanceUpdateWithoutItemInput, ItemInstanceUncheckedUpdateWithoutItemInput>
  }

  export type ItemInstanceUpdateManyWithWhereWithoutItemInput = {
    where: ItemInstanceScalarWhereInput
    data: XOR<ItemInstanceUpdateManyMutationInput, ItemInstanceUncheckedUpdateManyWithoutItemInput>
  }

  export type RecipeUpsertWithWhereUniqueWithoutProductInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutProductInput, RecipeUncheckedUpdateWithoutProductInput>
    create: XOR<RecipeCreateWithoutProductInput, RecipeUncheckedCreateWithoutProductInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutProductInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutProductInput, RecipeUncheckedUpdateWithoutProductInput>
  }

  export type RecipeUpdateManyWithWhereWithoutProductInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutProductInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: IntFilter<"Recipe"> | number
    name?: StringFilter<"Recipe"> | string
    profession?: StringFilter<"Recipe"> | string
    difficulty?: IntFilter<"Recipe"> | number
    productId?: IntFilter<"Recipe"> | number
  }

  export type RecipeMaterialUpsertWithWhereUniqueWithoutItemInput = {
    where: RecipeMaterialWhereUniqueInput
    update: XOR<RecipeMaterialUpdateWithoutItemInput, RecipeMaterialUncheckedUpdateWithoutItemInput>
    create: XOR<RecipeMaterialCreateWithoutItemInput, RecipeMaterialUncheckedCreateWithoutItemInput>
  }

  export type RecipeMaterialUpdateWithWhereUniqueWithoutItemInput = {
    where: RecipeMaterialWhereUniqueInput
    data: XOR<RecipeMaterialUpdateWithoutItemInput, RecipeMaterialUncheckedUpdateWithoutItemInput>
  }

  export type RecipeMaterialUpdateManyWithWhereWithoutItemInput = {
    where: RecipeMaterialScalarWhereInput
    data: XOR<RecipeMaterialUpdateManyMutationInput, RecipeMaterialUncheckedUpdateManyWithoutItemInput>
  }

  export type RecipeMaterialScalarWhereInput = {
    AND?: RecipeMaterialScalarWhereInput | RecipeMaterialScalarWhereInput[]
    OR?: RecipeMaterialScalarWhereInput[]
    NOT?: RecipeMaterialScalarWhereInput | RecipeMaterialScalarWhereInput[]
    id?: IntFilter<"RecipeMaterial"> | number
    recipeId?: IntFilter<"RecipeMaterial"> | number
    itemId?: IntFilter<"RecipeMaterial"> | number
    quantity?: IntFilter<"RecipeMaterial"> | number
  }

  export type UserCreateWithoutInventoryInput = {
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionCreateNestedManyWithoutUserInput
    titles?: PlayerTitleCreateNestedManyWithoutUserInput
    languages?: UserLanguageCreateNestedManyWithoutUserInput
    quests?: QuestCreateNestedManyWithoutTakerInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionUncheckedCreateNestedManyWithoutUserInput
    titles?: PlayerTitleUncheckedCreateNestedManyWithoutUserInput
    languages?: UserLanguageUncheckedCreateNestedManyWithoutUserInput
    quests?: QuestUncheckedCreateNestedManyWithoutTakerInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type ItemCreateWithoutInstancesInput = {
    name: string
    quality: number
    recipesAsProduct?: RecipeCreateNestedManyWithoutProductInput
    recipeMaterials?: RecipeMaterialCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInstancesInput = {
    id?: number
    name: string
    quality: number
    recipesAsProduct?: RecipeUncheckedCreateNestedManyWithoutProductInput
    recipeMaterials?: RecipeMaterialUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInstancesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInstancesInput, ItemUncheckedCreateWithoutInstancesInput>
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUpdateManyWithoutUserNestedInput
    quests?: QuestUpdateManyWithoutTakerNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUncheckedUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUncheckedUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUncheckedUpdateManyWithoutUserNestedInput
    quests?: QuestUncheckedUpdateManyWithoutTakerNestedInput
  }

  export type ItemUpsertWithoutInstancesInput = {
    update: XOR<ItemUpdateWithoutInstancesInput, ItemUncheckedUpdateWithoutInstancesInput>
    create: XOR<ItemCreateWithoutInstancesInput, ItemUncheckedCreateWithoutInstancesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInstancesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInstancesInput, ItemUncheckedUpdateWithoutInstancesInput>
  }

  export type ItemUpdateWithoutInstancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    recipesAsProduct?: RecipeUpdateManyWithoutProductNestedInput
    recipeMaterials?: RecipeMaterialUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInstancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    recipesAsProduct?: RecipeUncheckedUpdateManyWithoutProductNestedInput
    recipeMaterials?: RecipeMaterialUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateWithoutRecipesAsProductInput = {
    name: string
    quality: number
    instances?: ItemInstanceCreateNestedManyWithoutItemInput
    recipeMaterials?: RecipeMaterialCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutRecipesAsProductInput = {
    id?: number
    name: string
    quality: number
    instances?: ItemInstanceUncheckedCreateNestedManyWithoutItemInput
    recipeMaterials?: RecipeMaterialUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutRecipesAsProductInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutRecipesAsProductInput, ItemUncheckedCreateWithoutRecipesAsProductInput>
  }

  export type RecipeMaterialCreateWithoutRecipeInput = {
    quantity: number
    item: ItemCreateNestedOneWithoutRecipeMaterialsInput
  }

  export type RecipeMaterialUncheckedCreateWithoutRecipeInput = {
    id?: number
    itemId: number
    quantity: number
  }

  export type RecipeMaterialCreateOrConnectWithoutRecipeInput = {
    where: RecipeMaterialWhereUniqueInput
    create: XOR<RecipeMaterialCreateWithoutRecipeInput, RecipeMaterialUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeMaterialCreateManyRecipeInputEnvelope = {
    data: RecipeMaterialCreateManyRecipeInput | RecipeMaterialCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutRecipesAsProductInput = {
    update: XOR<ItemUpdateWithoutRecipesAsProductInput, ItemUncheckedUpdateWithoutRecipesAsProductInput>
    create: XOR<ItemCreateWithoutRecipesAsProductInput, ItemUncheckedCreateWithoutRecipesAsProductInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutRecipesAsProductInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutRecipesAsProductInput, ItemUncheckedUpdateWithoutRecipesAsProductInput>
  }

  export type ItemUpdateWithoutRecipesAsProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    instances?: ItemInstanceUpdateManyWithoutItemNestedInput
    recipeMaterials?: RecipeMaterialUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutRecipesAsProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    instances?: ItemInstanceUncheckedUpdateManyWithoutItemNestedInput
    recipeMaterials?: RecipeMaterialUncheckedUpdateManyWithoutItemNestedInput
  }

  export type RecipeMaterialUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeMaterialWhereUniqueInput
    update: XOR<RecipeMaterialUpdateWithoutRecipeInput, RecipeMaterialUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeMaterialCreateWithoutRecipeInput, RecipeMaterialUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeMaterialUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeMaterialWhereUniqueInput
    data: XOR<RecipeMaterialUpdateWithoutRecipeInput, RecipeMaterialUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeMaterialUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeMaterialScalarWhereInput
    data: XOR<RecipeMaterialUpdateManyMutationInput, RecipeMaterialUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeCreateWithoutMaterialsInput = {
    name: string
    profession: string
    difficulty: number
    product: ItemCreateNestedOneWithoutRecipesAsProductInput
  }

  export type RecipeUncheckedCreateWithoutMaterialsInput = {
    id?: number
    name: string
    profession: string
    difficulty: number
    productId: number
  }

  export type RecipeCreateOrConnectWithoutMaterialsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutMaterialsInput, RecipeUncheckedCreateWithoutMaterialsInput>
  }

  export type ItemCreateWithoutRecipeMaterialsInput = {
    name: string
    quality: number
    instances?: ItemInstanceCreateNestedManyWithoutItemInput
    recipesAsProduct?: RecipeCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutRecipeMaterialsInput = {
    id?: number
    name: string
    quality: number
    instances?: ItemInstanceUncheckedCreateNestedManyWithoutItemInput
    recipesAsProduct?: RecipeUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutRecipeMaterialsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutRecipeMaterialsInput, ItemUncheckedCreateWithoutRecipeMaterialsInput>
  }

  export type RecipeUpsertWithoutMaterialsInput = {
    update: XOR<RecipeUpdateWithoutMaterialsInput, RecipeUncheckedUpdateWithoutMaterialsInput>
    create: XOR<RecipeCreateWithoutMaterialsInput, RecipeUncheckedCreateWithoutMaterialsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutMaterialsInput, RecipeUncheckedUpdateWithoutMaterialsInput>
  }

  export type RecipeUpdateWithoutMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    product?: ItemUpdateOneRequiredWithoutRecipesAsProductNestedInput
  }

  export type RecipeUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemUpsertWithoutRecipeMaterialsInput = {
    update: XOR<ItemUpdateWithoutRecipeMaterialsInput, ItemUncheckedUpdateWithoutRecipeMaterialsInput>
    create: XOR<ItemCreateWithoutRecipeMaterialsInput, ItemUncheckedCreateWithoutRecipeMaterialsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutRecipeMaterialsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutRecipeMaterialsInput, ItemUncheckedUpdateWithoutRecipeMaterialsInput>
  }

  export type ItemUpdateWithoutRecipeMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    instances?: ItemInstanceUpdateManyWithoutItemNestedInput
    recipesAsProduct?: RecipeUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutRecipeMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quality?: IntFieldUpdateOperationsInput | number
    instances?: ItemInstanceUncheckedUpdateManyWithoutItemNestedInput
    recipesAsProduct?: RecipeUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WildAreaCreateWithoutPopulationsInput = {
    name: string
    type: string
    dangerLevel: number
    country: CountryCreateNestedOneWithoutWildAreasInput
    city?: CityCreateNestedOneWithoutWildAreasInput
  }

  export type WildAreaUncheckedCreateWithoutPopulationsInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    countryId: number
    cityId?: number | null
  }

  export type WildAreaCreateOrConnectWithoutPopulationsInput = {
    where: WildAreaWhereUniqueInput
    create: XOR<WildAreaCreateWithoutPopulationsInput, WildAreaUncheckedCreateWithoutPopulationsInput>
  }

  export type WildAreaUpsertWithoutPopulationsInput = {
    update: XOR<WildAreaUpdateWithoutPopulationsInput, WildAreaUncheckedUpdateWithoutPopulationsInput>
    create: XOR<WildAreaCreateWithoutPopulationsInput, WildAreaUncheckedCreateWithoutPopulationsInput>
    where?: WildAreaWhereInput
  }

  export type WildAreaUpdateToOneWithWhereWithoutPopulationsInput = {
    where?: WildAreaWhereInput
    data: XOR<WildAreaUpdateWithoutPopulationsInput, WildAreaUncheckedUpdateWithoutPopulationsInput>
  }

  export type WildAreaUpdateWithoutPopulationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutWildAreasNestedInput
    city?: CityUpdateOneWithoutWildAreasNestedInput
  }

  export type WildAreaUncheckedUpdateWithoutPopulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NPCCreateWithoutLanguageInput = {
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    city: CityCreateNestedOneWithoutNpcsInput
    religion?: ReligionCreateNestedOneWithoutFollowersInput
    stories?: NPCStoryCreateNestedManyWithoutNpcInput
    quests?: QuestCreateNestedManyWithoutIssuerInput
  }

  export type NPCUncheckedCreateWithoutLanguageInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    religionId?: number | null
    stories?: NPCStoryUncheckedCreateNestedManyWithoutNpcInput
    quests?: QuestUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type NPCCreateOrConnectWithoutLanguageInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutLanguageInput, NPCUncheckedCreateWithoutLanguageInput>
  }

  export type NPCCreateManyLanguageInputEnvelope = {
    data: NPCCreateManyLanguageInput | NPCCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type UserLanguageCreateWithoutLanguageInput = {
    fluency: number
    user: UserCreateNestedOneWithoutLanguagesInput
  }

  export type UserLanguageUncheckedCreateWithoutLanguageInput = {
    id?: number
    userId: number
    fluency: number
  }

  export type UserLanguageCreateOrConnectWithoutLanguageInput = {
    where: UserLanguageWhereUniqueInput
    create: XOR<UserLanguageCreateWithoutLanguageInput, UserLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type UserLanguageCreateManyLanguageInputEnvelope = {
    data: UserLanguageCreateManyLanguageInput | UserLanguageCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type NPCUpsertWithWhereUniqueWithoutLanguageInput = {
    where: NPCWhereUniqueInput
    update: XOR<NPCUpdateWithoutLanguageInput, NPCUncheckedUpdateWithoutLanguageInput>
    create: XOR<NPCCreateWithoutLanguageInput, NPCUncheckedCreateWithoutLanguageInput>
  }

  export type NPCUpdateWithWhereUniqueWithoutLanguageInput = {
    where: NPCWhereUniqueInput
    data: XOR<NPCUpdateWithoutLanguageInput, NPCUncheckedUpdateWithoutLanguageInput>
  }

  export type NPCUpdateManyWithWhereWithoutLanguageInput = {
    where: NPCScalarWhereInput
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyWithoutLanguageInput>
  }

  export type UserLanguageUpsertWithWhereUniqueWithoutLanguageInput = {
    where: UserLanguageWhereUniqueInput
    update: XOR<UserLanguageUpdateWithoutLanguageInput, UserLanguageUncheckedUpdateWithoutLanguageInput>
    create: XOR<UserLanguageCreateWithoutLanguageInput, UserLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type UserLanguageUpdateWithWhereUniqueWithoutLanguageInput = {
    where: UserLanguageWhereUniqueInput
    data: XOR<UserLanguageUpdateWithoutLanguageInput, UserLanguageUncheckedUpdateWithoutLanguageInput>
  }

  export type UserLanguageUpdateManyWithWhereWithoutLanguageInput = {
    where: UserLanguageScalarWhereInput
    data: XOR<UserLanguageUpdateManyMutationInput, UserLanguageUncheckedUpdateManyWithoutLanguageInput>
  }

  export type UserCreateWithoutLanguagesInput = {
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceCreateNestedManyWithoutUserInput
    titles?: PlayerTitleCreateNestedManyWithoutUserInput
    quests?: QuestCreateNestedManyWithoutTakerInput
  }

  export type UserUncheckedCreateWithoutLanguagesInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionUncheckedCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceUncheckedCreateNestedManyWithoutUserInput
    titles?: PlayerTitleUncheckedCreateNestedManyWithoutUserInput
    quests?: QuestUncheckedCreateNestedManyWithoutTakerInput
  }

  export type UserCreateOrConnectWithoutLanguagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLanguagesInput, UserUncheckedCreateWithoutLanguagesInput>
  }

  export type LanguageCreateWithoutUserLanguagesInput = {
    name: string
    isAncient?: boolean
    region?: string | null
    speakers?: NPCCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutUserLanguagesInput = {
    id?: number
    name: string
    isAncient?: boolean
    region?: string | null
    speakers?: NPCUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutUserLanguagesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutUserLanguagesInput, LanguageUncheckedCreateWithoutUserLanguagesInput>
  }

  export type UserUpsertWithoutLanguagesInput = {
    update: XOR<UserUpdateWithoutLanguagesInput, UserUncheckedUpdateWithoutLanguagesInput>
    create: XOR<UserCreateWithoutLanguagesInput, UserUncheckedCreateWithoutLanguagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLanguagesInput, UserUncheckedUpdateWithoutLanguagesInput>
  }

  export type UserUpdateWithoutLanguagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUpdateManyWithoutUserNestedInput
    quests?: QuestUpdateManyWithoutTakerNestedInput
  }

  export type UserUncheckedUpdateWithoutLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUncheckedUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUncheckedUpdateManyWithoutUserNestedInput
    titles?: PlayerTitleUncheckedUpdateManyWithoutUserNestedInput
    quests?: QuestUncheckedUpdateManyWithoutTakerNestedInput
  }

  export type LanguageUpsertWithoutUserLanguagesInput = {
    update: XOR<LanguageUpdateWithoutUserLanguagesInput, LanguageUncheckedUpdateWithoutUserLanguagesInput>
    create: XOR<LanguageCreateWithoutUserLanguagesInput, LanguageUncheckedCreateWithoutUserLanguagesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutUserLanguagesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutUserLanguagesInput, LanguageUncheckedUpdateWithoutUserLanguagesInput>
  }

  export type LanguageUpdateWithoutUserLanguagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NPCUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutUserLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAncient?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NPCUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type ArtifactCreateWithoutReligionInput = {
    name: string
    lore: string
    powerHint: string
  }

  export type ArtifactUncheckedCreateWithoutReligionInput = {
    id?: number
    name: string
    lore: string
    powerHint: string
  }

  export type ArtifactCreateOrConnectWithoutReligionInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutReligionInput, ArtifactUncheckedCreateWithoutReligionInput>
  }

  export type ArtifactCreateManyReligionInputEnvelope = {
    data: ArtifactCreateManyReligionInput | ArtifactCreateManyReligionInput[]
    skipDuplicates?: boolean
  }

  export type NPCCreateWithoutReligionInput = {
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    city: CityCreateNestedOneWithoutNpcsInput
    language: LanguageCreateNestedOneWithoutSpeakersInput
    stories?: NPCStoryCreateNestedManyWithoutNpcInput
    quests?: QuestCreateNestedManyWithoutIssuerInput
  }

  export type NPCUncheckedCreateWithoutReligionInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    stories?: NPCStoryUncheckedCreateNestedManyWithoutNpcInput
    quests?: QuestUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type NPCCreateOrConnectWithoutReligionInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutReligionInput, NPCUncheckedCreateWithoutReligionInput>
  }

  export type NPCCreateManyReligionInputEnvelope = {
    data: NPCCreateManyReligionInput | NPCCreateManyReligionInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactUpsertWithWhereUniqueWithoutReligionInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutReligionInput, ArtifactUncheckedUpdateWithoutReligionInput>
    create: XOR<ArtifactCreateWithoutReligionInput, ArtifactUncheckedCreateWithoutReligionInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutReligionInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutReligionInput, ArtifactUncheckedUpdateWithoutReligionInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutReligionInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutReligionInput>
  }

  export type ArtifactScalarWhereInput = {
    AND?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    OR?: ArtifactScalarWhereInput[]
    NOT?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    id?: IntFilter<"Artifact"> | number
    name?: StringFilter<"Artifact"> | string
    lore?: StringFilter<"Artifact"> | string
    powerHint?: StringFilter<"Artifact"> | string
    religionId?: IntFilter<"Artifact"> | number
  }

  export type NPCUpsertWithWhereUniqueWithoutReligionInput = {
    where: NPCWhereUniqueInput
    update: XOR<NPCUpdateWithoutReligionInput, NPCUncheckedUpdateWithoutReligionInput>
    create: XOR<NPCCreateWithoutReligionInput, NPCUncheckedCreateWithoutReligionInput>
  }

  export type NPCUpdateWithWhereUniqueWithoutReligionInput = {
    where: NPCWhereUniqueInput
    data: XOR<NPCUpdateWithoutReligionInput, NPCUncheckedUpdateWithoutReligionInput>
  }

  export type NPCUpdateManyWithWhereWithoutReligionInput = {
    where: NPCScalarWhereInput
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyWithoutReligionInput>
  }

  export type ReligionCreateWithoutArtifactsInput = {
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    followers?: NPCCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateWithoutArtifactsInput = {
    id?: number
    name: string
    originRegion: string
    description: string
    doctrine: string
    influenceLevel: number
    estimatedFollowers: number
    followers?: NPCUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionCreateOrConnectWithoutArtifactsInput = {
    where: ReligionWhereUniqueInput
    create: XOR<ReligionCreateWithoutArtifactsInput, ReligionUncheckedCreateWithoutArtifactsInput>
  }

  export type ReligionUpsertWithoutArtifactsInput = {
    update: XOR<ReligionUpdateWithoutArtifactsInput, ReligionUncheckedUpdateWithoutArtifactsInput>
    create: XOR<ReligionCreateWithoutArtifactsInput, ReligionUncheckedCreateWithoutArtifactsInput>
    where?: ReligionWhereInput
  }

  export type ReligionUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: ReligionWhereInput
    data: XOR<ReligionUpdateWithoutArtifactsInput, ReligionUncheckedUpdateWithoutArtifactsInput>
  }

  export type ReligionUpdateWithoutArtifactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
    followers?: NPCUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateWithoutArtifactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originRegion?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    doctrine?: StringFieldUpdateOperationsInput | string
    influenceLevel?: IntFieldUpdateOperationsInput | number
    estimatedFollowers?: IntFieldUpdateOperationsInput | number
    followers?: NPCUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type CityCreateWithoutWeatherInput = {
    name: string
    description: string
    population: number
    country: CountryCreateNestedOneWithoutCitiesInput
    wildAreas?: WildAreaCreateNestedManyWithoutCityInput
    dungeons?: DungeonCreateNestedManyWithoutCityInput
    npcs?: NPCCreateNestedManyWithoutCityInput
    economies?: EconomyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutWeatherInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCityInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCityInput
    npcs?: NPCUncheckedCreateNestedManyWithoutCityInput
    economies?: EconomyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutWeatherInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutWeatherInput, CityUncheckedCreateWithoutWeatherInput>
  }

  export type CityUpsertWithoutWeatherInput = {
    update: XOR<CityUpdateWithoutWeatherInput, CityUncheckedUpdateWithoutWeatherInput>
    create: XOR<CityCreateWithoutWeatherInput, CityUncheckedCreateWithoutWeatherInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutWeatherInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutWeatherInput, CityUncheckedUpdateWithoutWeatherInput>
  }

  export type CityUpdateWithoutWeatherInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUpdateManyWithoutCityNestedInput
    npcs?: NPCUpdateManyWithoutCityNestedInput
    economies?: EconomyUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutWeatherInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCityNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutCityNestedInput
    economies?: EconomyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type NPCCreateWithoutStoriesInput = {
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    city: CityCreateNestedOneWithoutNpcsInput
    language: LanguageCreateNestedOneWithoutSpeakersInput
    religion?: ReligionCreateNestedOneWithoutFollowersInput
    quests?: QuestCreateNestedManyWithoutIssuerInput
  }

  export type NPCUncheckedCreateWithoutStoriesInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId?: number | null
    quests?: QuestUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type NPCCreateOrConnectWithoutStoriesInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutStoriesInput, NPCUncheckedCreateWithoutStoriesInput>
  }

  export type NPCUpsertWithoutStoriesInput = {
    update: XOR<NPCUpdateWithoutStoriesInput, NPCUncheckedUpdateWithoutStoriesInput>
    create: XOR<NPCCreateWithoutStoriesInput, NPCUncheckedCreateWithoutStoriesInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutStoriesInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutStoriesInput, NPCUncheckedUpdateWithoutStoriesInput>
  }

  export type NPCUpdateWithoutStoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutNpcsNestedInput
    language?: LanguageUpdateOneRequiredWithoutSpeakersNestedInput
    religion?: ReligionUpdateOneWithoutFollowersNestedInput
    quests?: QuestUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateWithoutStoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
    quests?: QuestUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type UserCreateWithoutTitlesInput = {
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceCreateNestedManyWithoutUserInput
    languages?: UserLanguageCreateNestedManyWithoutUserInput
    quests?: QuestCreateNestedManyWithoutTakerInput
  }

  export type UserUncheckedCreateWithoutTitlesInput = {
    id?: number
    username: string
    password: string
    positionX?: number
    positionY?: number
    reputation?: number
    notoriety?: number
    maxHp?: number
    maxMp?: number
    isOnline?: boolean
    profession?: PlayerProfessionUncheckedCreateNestedManyWithoutUserInput
    inventory?: ItemInstanceUncheckedCreateNestedManyWithoutUserInput
    languages?: UserLanguageUncheckedCreateNestedManyWithoutUserInput
    quests?: QuestUncheckedCreateNestedManyWithoutTakerInput
  }

  export type UserCreateOrConnectWithoutTitlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTitlesInput, UserUncheckedCreateWithoutTitlesInput>
  }

  export type UserUpsertWithoutTitlesInput = {
    update: XOR<UserUpdateWithoutTitlesInput, UserUncheckedUpdateWithoutTitlesInput>
    create: XOR<UserCreateWithoutTitlesInput, UserUncheckedCreateWithoutTitlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTitlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTitlesInput, UserUncheckedUpdateWithoutTitlesInput>
  }

  export type UserUpdateWithoutTitlesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUpdateManyWithoutUserNestedInput
    quests?: QuestUpdateManyWithoutTakerNestedInput
  }

  export type UserUncheckedUpdateWithoutTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    maxMp?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    profession?: PlayerProfessionUncheckedUpdateManyWithoutUserNestedInput
    inventory?: ItemInstanceUncheckedUpdateManyWithoutUserNestedInput
    languages?: UserLanguageUncheckedUpdateManyWithoutUserNestedInput
    quests?: QuestUncheckedUpdateManyWithoutTakerNestedInput
  }

  export type CityCreateWithoutEconomiesInput = {
    name: string
    description: string
    population: number
    country: CountryCreateNestedOneWithoutCitiesInput
    wildAreas?: WildAreaCreateNestedManyWithoutCityInput
    dungeons?: DungeonCreateNestedManyWithoutCityInput
    weather?: WeatherCreateNestedOneWithoutCityInput
    npcs?: NPCCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutEconomiesInput = {
    id?: number
    name: string
    description: string
    population: number
    countryId: number
    wildAreas?: WildAreaUncheckedCreateNestedManyWithoutCityInput
    dungeons?: DungeonUncheckedCreateNestedManyWithoutCityInput
    weather?: WeatherUncheckedCreateNestedOneWithoutCityInput
    npcs?: NPCUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutEconomiesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutEconomiesInput, CityUncheckedCreateWithoutEconomiesInput>
  }

  export type CityUpsertWithoutEconomiesInput = {
    update: XOR<CityUpdateWithoutEconomiesInput, CityUncheckedUpdateWithoutEconomiesInput>
    create: XOR<CityCreateWithoutEconomiesInput, CityUncheckedCreateWithoutEconomiesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutEconomiesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutEconomiesInput, CityUncheckedUpdateWithoutEconomiesInput>
  }

  export type CityUpdateWithoutEconomiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    wildAreas?: WildAreaUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUpdateManyWithoutCityNestedInput
    weather?: WeatherUpdateOneWithoutCityNestedInput
    npcs?: NPCUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutEconomiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCityNestedInput
    weather?: WeatherUncheckedUpdateOneWithoutCityNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutCityNestedInput
  }

  export type PlayerProfessionCreateManyUserInput = {
    id?: number
    type: string
    skillLevel?: number
    experience?: number
  }

  export type ItemInstanceCreateManyUserInput = {
    id?: number
    itemId: number
    quantity: number
  }

  export type PlayerTitleCreateManyUserInput = {
    id?: number
    type: string
    region: string
    grantedAt: Date | string
    authority: number
  }

  export type UserLanguageCreateManyUserInput = {
    id?: number
    languageId: number
    fluency: number
  }

  export type QuestCreateManyTakerInput = {
    id?: number
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    issuerId?: number | null
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PlayerProfessionUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerProfessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerProfessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    skillLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutInstancesNestedInput
  }

  export type ItemInstanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerTitleUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerTitleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerTitleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: IntFieldUpdateOperationsInput | number
  }

  export type UserLanguageUpdateWithoutUserInput = {
    fluency?: IntFieldUpdateOperationsInput | number
    language?: LanguageUpdateOneRequiredWithoutUserLanguagesNestedInput
  }

  export type UserLanguageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type UserLanguageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type QuestUpdateWithoutTakerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    issuer?: NPCUpdateOneWithoutQuestsNestedInput
  }

  export type QuestUncheckedUpdateWithoutTakerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    issuerId?: NullableIntFieldUpdateOperationsInput | number | null
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestUncheckedUpdateManyWithoutTakerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    issuerId?: NullableIntFieldUpdateOperationsInput | number | null
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NPCStoryCreateManyNpcInput = {
    id?: number
    title: string
    summary: string
    createdAt?: Date | string
  }

  export type QuestCreateManyIssuerInput = {
    id?: number
    title: string
    description: string
    isTaken?: boolean
    takenAt?: Date | string | null
    completedAt?: Date | string | null
    reputationRequired: number
    notorietyTrigger: boolean
    takerId?: number | null
    bountyTargetId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NPCStoryUpdateWithoutNpcInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCStoryUncheckedUpdateWithoutNpcInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCStoryUncheckedUpdateManyWithoutNpcInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUpdateWithoutIssuerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    taker?: UserUpdateOneWithoutQuestsNestedInput
  }

  export type QuestUncheckedUpdateWithoutIssuerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    takerId?: NullableIntFieldUpdateOperationsInput | number | null
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuestUncheckedUpdateManyWithoutIssuerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    takenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationRequired?: IntFieldUpdateOperationsInput | number
    notorietyTrigger?: BoolFieldUpdateOperationsInput | boolean
    takerId?: NullableIntFieldUpdateOperationsInput | number | null
    bountyTargetId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WildAreaCreateManyCityInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    countryId: number
  }

  export type DungeonCreateManyCityInput = {
    id?: number
    name: string
    levelRequirement: number
    isRaid: boolean
    countryId: number
  }

  export type NPCCreateManyCityInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
    religionId?: number | null
  }

  export type EconomyCreateManyCityInput = {
    id?: number
    item: string
    price: number
    demand: string
    supply: string
  }

  export type WildAreaUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutWildAreasNestedInput
    populations?: AnimalPopulationUpdateManyWithoutAreaNestedInput
  }

  export type WildAreaUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    populations?: AnimalPopulationUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type WildAreaUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type DungeonUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    country?: CountryUpdateOneRequiredWithoutDungeonsNestedInput
  }

  export type DungeonUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type DungeonUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type NPCUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    language?: LanguageUpdateOneRequiredWithoutSpeakersNestedInput
    religion?: ReligionUpdateOneWithoutFollowersNestedInput
    stories?: NPCStoryUpdateManyWithoutNpcNestedInput
    quests?: QuestUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
    stories?: NPCStoryUncheckedUpdateManyWithoutNpcNestedInput
    quests?: QuestUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EconomyUpdateWithoutCityInput = {
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
  }

  export type EconomyUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
  }

  export type EconomyUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    item?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    demand?: StringFieldUpdateOperationsInput | string
    supply?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateManyCountryInput = {
    id?: number
    name: string
    description: string
    population: number
  }

  export type WildAreaCreateManyCountryInput = {
    id?: number
    name: string
    type: string
    dangerLevel: number
    cityId?: number | null
  }

  export type DungeonCreateManyCountryInput = {
    id?: number
    name: string
    levelRequirement: number
    isRaid: boolean
    cityId?: number | null
  }

  export type CityUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUpdateManyWithoutCityNestedInput
    weather?: WeatherUpdateOneWithoutCityNestedInput
    npcs?: NPCUpdateManyWithoutCityNestedInput
    economies?: EconomyUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
    wildAreas?: WildAreaUncheckedUpdateManyWithoutCityNestedInput
    dungeons?: DungeonUncheckedUpdateManyWithoutCityNestedInput
    weather?: WeatherUncheckedUpdateOneWithoutCityNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutCityNestedInput
    economies?: EconomyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type WildAreaUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    populations?: AnimalPopulationUpdateManyWithoutAreaNestedInput
    city?: CityUpdateOneWithoutWildAreasNestedInput
  }

  export type WildAreaUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    populations?: AnimalPopulationUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type WildAreaUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dangerLevel?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DungeonUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    city?: CityUpdateOneWithoutDungeonsNestedInput
  }

  export type DungeonUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DungeonUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    levelRequirement?: IntFieldUpdateOperationsInput | number
    isRaid?: BoolFieldUpdateOperationsInput | boolean
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnimalPopulationCreateManyAreaInput = {
    id?: number
    species: string
    type: string
    population: number
  }

  export type AnimalPopulationUpdateWithoutAreaInput = {
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type AnimalPopulationUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type AnimalPopulationUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    species?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceCreateManyItemInput = {
    id?: number
    userId: number
    quantity: number
  }

  export type RecipeCreateManyProductInput = {
    id?: number
    name: string
    profession: string
    difficulty: number
  }

  export type RecipeMaterialCreateManyItemInput = {
    id?: number
    recipeId: number
    quantity: number
  }

  export type ItemInstanceUpdateWithoutItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type ItemInstanceUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ItemInstanceUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    materials?: RecipeMaterialUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    materials?: RecipeMaterialUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialUpdateWithoutItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type RecipeMaterialUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialCreateManyRecipeInput = {
    id?: number
    itemId: number
    quantity: number
  }

  export type RecipeMaterialUpdateWithoutRecipeInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutRecipeMaterialsNestedInput
  }

  export type RecipeMaterialUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeMaterialUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type NPCCreateManyLanguageInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    religionId?: number | null
  }

  export type UserLanguageCreateManyLanguageInput = {
    id?: number
    userId: number
    fluency: number
  }

  export type NPCUpdateWithoutLanguageInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutNpcsNestedInput
    religion?: ReligionUpdateOneWithoutFollowersNestedInput
    stories?: NPCStoryUpdateManyWithoutNpcNestedInput
    quests?: QuestUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
    stories?: NPCStoryUncheckedUpdateManyWithoutNpcNestedInput
    quests?: QuestUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateManyWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    religionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserLanguageUpdateWithoutLanguageInput = {
    fluency?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type UserLanguageUncheckedUpdateWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type UserLanguageUncheckedUpdateManyWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
  }

  export type ArtifactCreateManyReligionInput = {
    id?: number
    name: string
    lore: string
    powerHint: string
  }

  export type NPCCreateManyReligionInput = {
    id?: number
    name: string
    gender: string
    birthYear: number
    deathYear?: number | null
    isAlive?: boolean
    mood: string
    fame?: number
    notoriety?: number
    cityId: number
    partnerId?: number | null
    parent1Id?: number | null
    parent2Id?: number | null
    isNoble?: boolean
    nobleTitle?: string | null
    personality?: string | null
    background: string
    job: string
    skills: string
    languageId: number
  }

  export type ArtifactUpdateWithoutReligionInput = {
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactUncheckedUpdateWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactUncheckedUpdateManyWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lore?: StringFieldUpdateOperationsInput | string
    powerHint?: StringFieldUpdateOperationsInput | string
  }

  export type NPCUpdateWithoutReligionInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutNpcsNestedInput
    language?: LanguageUpdateOneRequiredWithoutSpeakersNestedInput
    stories?: NPCStoryUpdateManyWithoutNpcNestedInput
    quests?: QuestUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
    stories?: NPCStoryUncheckedUpdateManyWithoutNpcNestedInput
    quests?: QuestUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type NPCUncheckedUpdateManyWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthYear?: IntFieldUpdateOperationsInput | number
    deathYear?: NullableIntFieldUpdateOperationsInput | number | null
    isAlive?: BoolFieldUpdateOperationsInput | boolean
    mood?: StringFieldUpdateOperationsInput | string
    fame?: IntFieldUpdateOperationsInput | number
    notoriety?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    partnerId?: NullableIntFieldUpdateOperationsInput | number | null
    parent1Id?: NullableIntFieldUpdateOperationsInput | number | null
    parent2Id?: NullableIntFieldUpdateOperationsInput | number | null
    isNoble?: BoolFieldUpdateOperationsInput | boolean
    nobleTitle?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    background?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}